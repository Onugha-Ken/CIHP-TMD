from flask import (render_template, url_for, redirect, session, request, make_response, jsonify)
# from flask_cors import CORS
import sqlite3
import argon2 
import json
import csv
import io

import pandas as pd
import numpy as np
from datetime import datetime

import hvplot.pandas
import holoviews as hv
from holoviews import opts
hv.extension("bokeh")

from datetime import timedelta


import warnings
warnings.filterwarnings('ignore')


from application import app
# CORS(app)

argon2Hasher = argon2.PasswordHasher(
    time_cost=3,  # number of iterations
    memory_cost=64 * 1024,  # 64mb
    parallelism=1,  # how many parallel threads to use
    hash_len=32,  # the size of the derived key
    salt_len=16  # the size of the random generated salt in bytes
)


# Set a secret key for session management
app.secret_key = 'inkpl,n,28675837'


@app.route('/')    
def index(): 
    return redirect(url_for('login'))  # Redirecting to another route


@app.route('/login', methods=['GET', 'POST'])
def login():
    # Initialize the error message variable
    failed_attempt = ""
    # Check if user is already logged in
    if 'username' in session:
        return redirect('/Request_Returned')
    # Handle POST request (form submission)
    if request.method == 'POST':
        # Get form data
        username = request.form.get('username', '').strip()
        password = request.form.get('password', '').strip()
        remember_me = request.form.get('remember_me')

        # Check if username or password is null/empty
        if not username or not password:
            failed_attempt = "Username and password cannot be empty."
            return render_template('index.html', failed_attempt=failed_attempt)

        # Connect to the database
        connection = sqlite3.connect("C:\\Users\\konugha\\cihp_tmd\\cihp_tmd\\TMD.db",
                                     check_same_thread=False)
        connection.row_factory = sqlite3.Row
        cursor = connection.cursor()

        # Query the database for the provided username
        cursor.execute("SELECT * FROM ROUTINE WHERE Username=?", (username,))
        user = cursor.fetchone()

        if user is not None:
            # User found, verify password
            stored_password_hash = user['Password']  
            try:
                argon2Hasher.verify(stored_password_hash, password)
                # If Password is correct, log the user in
                session['loggedin'] = True
                session['username'] = username

                # Handle "Remember Me" functionality
                if remember_me:
                    session.permanent = True
                    app.permanent_session_lifetime = timedelta(days=7)  # Keep the session for 7 days if "Remember Me" is checked
                else:
                    session.permanent = False  # Session expires when the browser is closed

                return redirect(url_for('Request_Returned'))
            except:
                # Password is incorrect
                failed_attempt = "Invalid username or password. Please try again."
        else:
            # User not found
            failed_attempt = "Invalid username or password. Please try again."

        # Close the connection
        connection.close()
        
        pass
        session.clear()  # Clear any session data when visiting the login page
    else:
        print("Request method is not POST")

    # Render the login page with any error message
    return render_template('index.html', failed_attempt=failed_attempt)


# Enable the below for timeout
@app.before_request
def before_request():
    session.permanent = True
    app.permanent_session_lifetime = timedelta(minutes=4)

# favicon
@app.route('/favicon.ico')
def favicon():
    return url_for('static', filename='images/my_favicon.jpg')

@app.route('/logout')
def logout():
    session.clear()  # Clears the entire session
    return redirect(url_for('login'))


from bokeh.resources import CDN
from bokeh.settings import settings
settings.resources = 'inline'
from bokeh.embed import file_html, json_item
from bokeh.io import curdoc
from bokeh.models import NumeralTickFormatter, CustomJS, Button, HoverTool, CrosshairTool, PanTool, BoxZoomTool, SaveTool, ResetTool
from bokeh.models import ColumnDataSource, LabelSet, FactorRange, LinearAxis, Range1d
from bokeh.palettes import Spectral
import pandas_bokeh
from holoviews.plotting.bokeh import BokehRenderer
from bokeh.plotting import figure
from bokeh.transform import dodge, cumsum
from math import pi
import folium
from folium.plugins import MarkerCluster
# from folium import Popup, Tooltip
from folium.features import Popup, Tooltip


###################### Import temp tables ###################### tx_curr_lga_temp_tbl, df_pbs_ml_list, df_pbs_rec_ml_list,
from .dt_structures import (temp_table_curr, tx_curr_temp_tbl, df_curr_list, df_pbs_list, 
                            tx_new_temp_tbl, df_new_list, df_new_listmth1,df_new_listmth2, df_new_listmth3, df_pbs_new_list, df_cd4_new_list, df_ml_new_list, 
                            tx_ml_df, tx_ml_df_ip_mmd, tx_ml_df_state_mmd, tx_ml_df_lga_mmd, tx_ml_df_comd_mmd, tx_ml_df_fac_mmd, df_ml_list, df_ml_2_list, df_ml_iit_list, tx_ml_df_sorted, df_ml_iit_days_list, 
                            tx_pvls_temp_tbl, grouped_pvls, tx_pvls_ip, tx_pvls_ip3, tx_pvls_temp_tbl_all_age, tx_pvls_temp_tbl_age_female, tx_pvls_temp_tbl_age_male,
                            tx_pvls_state, tx_pvls_state2, grouped_pvls_state, pvls_temp_tbl_all_age_state, pvls_temp_tbl_age_state_female, pvls_temp_tbl_age_state_male, 
                            tx_pvls_lga, tx_pvls_lga3, grouped_pvls_lga, pvls_temp_tbl_all_age_lga, pvls_temp_tbl_age_lga_female, pvls_temp_tbl_age_lga_male,
                            tx_pvls_comd, tx_pvls_comd3, grouped_pvls_comd, pvls_temp_tbl_all_age_comd, pvls_temp_tbl_age_comd_female, pvls_temp_tbl_age_comd_male,
                            tx_pvls_fac, tx_pvls_fac3, grouped_pvls_fac, pvls_temp_tbl_all_age_fac, pvls_temp_tbl_age_fac_female, pvls_temp_tbl_age_fac_male,
                            tx_rtt_temp_tbl, df_rtt_list, rtt_pbs_list, rtt_cd4_list, 
                            pbfw_pvls_temp_tbl, df_pbfw_list, pw_pvls_temp_tbl, bfw_pvls_temp_tbl)

# remove bokeh default logo
def remove_bokeh_logo(plot, element):
    plot.state.toolbar.logo = None


height=400
plot_width = 565

###################### For folium maps ######################
# # Function to format a number with thousand separator
def format_with_thousand_separator(value):    
    return '{:,.0f}'.format(value)

locations_ip = [
    {"location": [10.3764, 7.7095], "popup": "Kaduna"},
    {"location": [7.7337, 6.6906], "popup": "Kogi"},
    {"location": [6.5227, 3.6218], "popup": "Lagos"}]

# Define coordinates for the center of each state
state_coordinates = {
    'Kaduna': [10.3764, 7.7095],
    'Kogi': [7.7337, 6.6906],
    'Lagos': [6.5227, 3.6218]
}    

lga_coordinates = {
    # Kaduna
    'Birnin Gwari': [10.666667, 6.55],
    'Chikun': [10.285, 7.110278],
    'Giwa': [11.28016380,7.41785700],
    'Igabi': [10.783333, 7.766667],
    'Ikara': [11.183333, 8.233333],
    'Jaba': [9.48185, 8.04372],
    "Jema'a": [9.38269, 8.26813],
    'Kachia': [9.86896500,7.95186300],
    'Kaduna North': [10.568, 7.452],
    'Kaduna South': [10.468, 7.421],
    'Kagarko': [9.45, 7.683333],
    'Kajuru': [10.32281, 7.68462],
    'Kaura': [9.61232, 8.46992],
    'Kauru': [10.65, 8.15],
    'Kubau': [10.87876, 8.38294],
    'Kudan': [11.273, 7.799],
    'Lere': [10.38584, 8.57286],
    'Makarfi': [11.2979, 7.9691],
    'Sabon Gari': [11.116667, 7.733333],
    'Sanga': [9.25, 8.45],
    'Soba': [10.98409280, 8.06015800],
    'Zangon Kataf': [9.8, 8.3],
    'Zaria': [11.066667, 7.7],
    # Kogi
    'Adavi': [7.666667, 6.45],
    'Ajaokuta': [7.556111, 6.655],
    'Ankpa': [7.433333, 7.633333],
    'Bassa': [7.9, 7.05],
    'Dekina': [7.583333, 7.2],
    'Idah': [7.097778, 6.743333],
    'Ijumu': [7.85, 5.966667],
    'Kabba/Bunu': [8.116667, 6.15],
    'Kogi': [8.1, 6.8],
    'Lokoja': [7.801944, 6.744167],
    'Ofu': [7.333333, 7.083333],
    'Ogori/Magongo': [7.483333, 6.216667],
    'Okehi': [7.7, 6.3],
    'Okene': [7.55, 6.233333],
    'Olamaboro': [7.183333, 7.566667],
    'Omala': [7.816667, 7.516667],
    'Yagba West': [8.25, 5.55],
    # Lagos
    'Alimosho': [6.610556, 3.295833],
    'Amuwo Odofin': [6.45, 3.266667],
    'Epe': [6.583333, 3.983333],
    'Eti Osa': [6.458985, 3.601521],
    'ibeju-lekki': [6.4167, 2.8833],
    'ifako-ijaiye': [6.684722, 3.288889],
    'Ikeja': [6.6, 3.35],
    'Mushin': [6.533333, 3.35],
    'Oshodi_Isolo': [6.514193, 3.308678],
}

comd_coordinates = {
    # Kaduna
    'Birnin Gwari': [10.666667, 6.55],
    'Chikun': [10.285, 7.110278],
    'Giwa': [11.28016380,7.41785700],
    'Igabi': [10.783333, 7.766667],
    'Ikara': [11.183333, 8.233333],
    'Jaba': [9.48185, 8.04372],
    "Jema'a": [9.38269, 8.26813],
    'Kachia': [9.86896500,7.95186300],
    'Kaduna North': [10.568, 7.452],
    'Kaduna South': [10.468, 7.421],
    'Kagarko': [9.45, 7.683333],
    'Kajuru': [10.32281, 7.68462],
    'Kaura': [9.61232, 8.46992],
    'Kauru': [10.65, 8.15],
    'Kubau': [10.87876, 8.38294],
    'Kudan': [11.273, 7.799],
    'Lere': [10.38584, 8.57286],
    'Makarfi': [11.2979, 7.9691],
    'Sabon Gari': [11.116667, 7.733333],
    'Sanga': [9.25, 8.45],
    'Soba': [10.98409280, 8.06015800],
    'Zangon Kataf': [9.8, 8.3],
    'Zaria': [11.066667, 7.7],
    # Kogi
    'Adavi': [7.666667, 6.45],
    'Ajaokuta': [7.556111, 6.655],
    'Ankpa': [7.433333, 7.633333],
    'Bassa': [7.9, 7.05],
    'Dekina': [7.583333, 7.2],
    'Idah': [7.097778, 6.743333],
    'Ijumu': [7.85, 5.966667],
    'Kabba/Bunu': [8.116667, 6.15],
    'Kogi': [8.1, 6.8],
    'Lokoja': [7.801944, 6.744167],
    'Ofu': [7.333333, 7.083333],
    'Ogori/Magongo': [7.483333, 6.216667],
    'Okehi': [7.7, 6.3],
    'Okene': [7.55, 6.233333],
    'Olamaboro': [7.183333, 7.566667],
    'Omala': [7.816667, 7.516667],
    'Yagba West': [8.25, 5.55],
    # Lagos
    'Alimosho': [6.610556, 3.295833],
    'Amuwo Odofin': [6.45, 3.266667],
    'Epe': [6.583333, 3.983333],
    'Eti Osa': [6.458985, 3.601521],
    'ibeju-lekki': [6.4167, 2.8833],
    'ifako-ijaiye': [6.684722, 3.288889],
    'Ikeja': [6.6, 3.35],
    'Mushin': [6.533333, 3.35],
    'Oshodi_Isolo': [6.514193, 3.308678]
}  

fac_coordinates = {
    # Kaduna
    'Jibrin Maigwari General Hospital': [10.65826, 6.53479],
    'Amina Hospital': [10.4554067, 7.4258814],
    'Sabon Tasha General Hospital': [10.4489626, 7.478136],
    'Sabo Tsaha Primary Health Center': [10.4564222, 7.4538917],
    'Kujama Rural Hospital': [10.4061661, 7.704165],
    'Ahmadu Bello University Teaching Hospital Shika Zaria': [11.0748561, 7.6826276],
    'General Hospital Giwa': [11.2482513, 7.4768502],
    'Jaji Comprehensive Health Center': [10.8236673, 7.5701068],
    'Rigasa General Hospital': [10.54579, 7.35651],
    'Turunku Rural Hospital': [10.8035916, 7.7101077],
    'Ikara General Hospital': [11.1547035, 8.2316977],
    'Kwoi General Hospital': [9.4604752, 7.9955248],
    'Kafanchan Family Health Unit': [9.5831722, 8.2915233],
    'Kafanchan General Hospital': [9.5831722, 8.2915233],
    'Foltz Medical Center - Katari': [9.6964232, 7.4534875],
    'Kachia General Hospital': [9.8601862, 7.96255],
    'Doka Rural Hospital': [9.9227924, 7.4312123],
    'Badarawa Primary Health Center': [10.5592211, 7.4477926],
    'Barau Dikko Specialist Hospital': [10.5253783, 7.4420041],
    'Federation of Muslim Women Association of Nigeria (FOMWAN) Hospital': [10.5576883, 7.4521891],
    'Kawo General Hospital': [10.58293333, 7.4463913],
    'Giwa Hospital': [10.5430337, 7.4345863],
    'Jowako Hospital': [10.5141785, 7.4327164],
    'Police Medical Center': [10.5083044, 7.4408297],
    'Salamat Hospital': [10.5105616, 7.4048481],
    'Zakari Isah Memorial Clinic': [10.5092126, 7.43175],
    'Gwamna Awan General Hospital': [10.465898, 7.4023337],
    'Harmony Hospital': [10.4772698, 7.4371777],
    'Makera I Primary Health Center': [10.4671368, 7.4112677],
    'Maneks Hospital': [10.4678021, 7.4135583],
    'Barnawa Primary Health Center': [10.4816, 7.42964],
    'Sefa Hospital': [10.5391763, 7.4203914],
    "St. Gerald's Hospital - Kaduna": [10.4679478, 7.4214052],
    'Yusuf Dantsoho Memorial Hospital': [10.521141666666665, 7.417315],
    'Kagarko General Hospital': [9.4895499, 7.6816829],
    'Idon Rural Hospital': [10.1083293, 7.9113984],
    'Manchok Maternal and Child Health Clinic': [9.6687091, 8.5122343],
    'Kaura Rural Hospital': [9.667003, 8.4714648],
    'Turaki Buga Memorial Hospital': [9.63452, 8.39633],
    'Rural Hospital Kauru': [10.5732974, 8.1436652],
    'Pambegua General Hospital': [10.68278636, 8.274129118],
    'Hunkuyi General Hospital': [11.2597332, 7.6484487],
    'General Hospital Saminaka': [10.4148417, 8.6778333],
    'General Hospital Makarfi': [11.3798125, 7.8854057],
    'Major Ibrahim Bello Abdullahi Memorial Hospital Sabongari': [11.1065561, 7.7271235],
    'Gwantu General Hospital': [9.22246, 8.46283],
    'Maigana General Hospital': [11.0275239, 7.9390537],
    'St. Louis Hospital - Zonkwa': [9.7781454, 8.2777168],
    'Zonkwa Regional Hospital': [9.7700651, 8.2808499],
    'Zango-Kataf General Hospital': [9.8280814, 8.3987504],
    'Anna-Kitcher Hospital': [11.0748561, 7.682676],
    'Hajiya Gambo Sawaba Hospital': [11.04043, 7.69805],
    'Muslim Specialist Hospital': [11.0790931, 7.687342],
    'National Tuberculosis And Leprosy Training Center - Zaria': [11.0404511, 7.6427805],
    "St. Luke's Hospital, Wusasa": [11.0764519, 7.6792299],
    'Kaduna State One Stop Shop (OSS) - Kaduna': [10.472571, 7.430123],
    'Virtual Hospital': [10.456535, 7.454334],
    # Kogi
    'Abejukolo General Hospital': [7.8714702, 7.5086497],
    'Aiyetoro Gbede General Hospital': [7.9780697, 6.2055386],
    'Ajaokuta Steel Medical Center': [7.5745439, 6.6380683],
    'Ankpa General Hospital': [7.3991652, 7.6275033],
    'Ankpa OSS': [7.3949235, 7.6194837],
    'Dekina General Hospital': [7.6979388, 7.0432909],
    'ECWA Hospital, Egbe': [8.2119057, 5.5164779],
    'Egume General Hospital': [7.4719133, 7.2519083],
    'Kabba General Hospital': [7.8233923, 6.0898554],
    'Grimmard Hospital - Anyingba': [7.5019931, 7.1701031],
    'Holley Memorial - Ochadamu': [7.3903306, 7.032745],
    'Idah General Hospital': [7.1082729, 6.7224738],
    'Ika Christian Hospital': [7.5939225, 7.702546],
    'Iyale General Hospital': [7.6354648, 7.3191915],
    'Kogi Diagnosis Referral Hospital': [7.479951, 7.1692031],
    'Kogi State Specialist Hospital': [7.793555, 6.73119],
    'Koton-Karfe General Hospital': [8.0953917, 6.8006466],
    'KPIF_Adavi OSS': [7.5589596, 6.2386025],
    'KPIF_Dekina OSS': [7.4858687, 7.1702666],
    'KPIF_Lokoja OSS': [7.5789439, 6.6380683],
    'Lokoja Federal Medical Center': [7.7990433, 6.7439417],
    'Maria Goretti Hospital': [7.5099575, 7.1705129],
    'Nagazi Comprehensive Health Centre': [7.5848683, 6.22893],
    'Obangede General Hospital': [7.6104246, 6.2055386],
    'Ogori General Hospital': [5.139, 7.1392],
    'Oguma General Hospital': [7.8690964, 7.066543],
    'Okene General Hospital': [7.5541743, 6.237765],
    'Okengwe General Hospital': [7.54705, 6.196565],
    'Okpo General Hospital': [7.2068493, 7.5475734],
    'St John\'s Hospital Kabba': [9.0766777, 7.4645452],
    'Ugwolawo General Hospital': [7.2265267, 6.9150304],
    # Lagos
    'Ifako Ijaiye General Hospital': [6.643524, 3.325695],
    'Ipaja Primary Health Center': [6.6043429, 3.2543631],
    'Gowon Estate Hospital - Ipaja': [6.6020488, 3.2835163],
    'Ancilla Catholic Hospital': [6.6685161, 3.3286609],
    'Meiran Primary Health Center': [6.6392959, 3.2962101],
    'Ifako Primary Health Centre': [6.645305, 3.325668],
    'Agbado Kola Primary Health Center': [6.6750186, 3.2737077],
    # 'LONGE MEDICAL CENTER': [6.6761658, 3.31096],
    'General Hospital Epe': [6.58639, 3.97115],
    'General Hospital Agbowa': [6.63742, 3.71461],
    'Epe OSS': [6.587438, 3.951128],
    'Ajeabo Primary Health Center': [6.5201697, 3.3373203],
    'Ayantuga Primary Health Center': [6.5271421, 3.3659042],
    'Lagos State University Teaching Hospital': [6.5920646, 3.3428272],
    'Lagos University Teaching Hospital (LUTH)': [6.5181444, 3.3539997],
    'Mushin General Hospital': [6.5317637, 3.3461088],
    'Mushin KP One Stop Shop': [6.533645, 3.3453989],
    'Ojodu Primary Health Care': [6.6476393, 3.3576273],
    'Palm Avenue Primary Health Center': [6.5364636, 3.3497958],
    'St. Leo Medical Centre': [6.5967211, 3.3509754],
    'Agboju Primary Health Center': [6.458635, 3.291201],
    'Akonwonjo Primary Health Center': [6.592709, 3.287266],
    'Alimosho General Hospital': [6.561324, 3.250486],
    'Amuwo Odofin KP OSS': [6.484425, 3.316097],
    'Aregbesola Primary Health Center': [6.576341, 3.280671],
    'Christ the King Catholic Hospital - Akowonjo': [6.598786, 3.308008],
    'Holy Family Hospital_Lagos': [6.468485, 3.282894],
    'Ikotun Primary Health Center': [6.55256, 3.269397],
    'Mary the Queen Hospital - Akowonjo': [6.591706, 3.299583],
    'Mother Theresa Medical Center - Idimu': [6.565093, 3.28065],
    'St. Joseph Mission Clinic Kirikiri': [6.445789, 3.311995],
    'Ajah Primary Health Center': [6.4865867, 3.5776311],
    'Badore Primary Health Center': [6.5094063, 3.6114382],
    'Eti-Osa KP On Stop Shop': [6.4520639, 3.5429054],
    'Falomo Police Hospital': [6.4429338, 3.4287074],
    'Ikate Primary Health Center': [6.4363107, 3.486087],
    'Iru Primary Health Center': [6.4326766, 3.4389499],
    'St. Kizito Clinic': [6.4349185, 3.5053913],
    'Ibeju-Lekki General Hospital': [6.4391803, 3.93466],
    'General Hospital Isolo':[6.53134,3.34066],
    'Isolo OSS':[6.41236,3.41445],
    'St. Catherine of Siena Medical Centre â€“ Mafoluku':[6.453100,3.23136]
}
       

@app.after_request
def add_header(response):
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '-1'
    return response



@app.route('/download_line_list', methods=['POST'])
def download_line_list():
    # Extract form data from the request
    ip = request.form.get('selectedIP')
    state = json.loads(request.form.get('selectedState', '[]'))
    lga = json.loads(request.form.get('selectedLGA', '[]'))
    command = json.loads(request.form.get('selectedCommand', '[]'))
    facility = json.loads(request.form.get('selectedFacility', '[]'))
    indicator = request.form.get('indicator')

    # Match the indicator to the correct column dynamically
    indicator_column_map = {
        'TX_CURR': 'TX_CURR',
        'PBS_CURR': 'PBS_CURR',
        'TX_NEW': 'TX_NEW',
        'TX_PVLS': 'TX_PVLS',
        'TX_RTT': 'TX_RTT',
        'TX_ML': 'TX_ML',
        'PBFW VLS': 'PBFW VLS',
        'PW VLS': 'PW VLS',
        'BFW VLS': 'BFW VLS'
    }
    indicator_column = indicator_column_map.get(indicator, None)
    # Apply the filtering logic
    if indicator_column:
        filtered_df = temp_table_curr[
            (temp_table_curr[indicator_column] == "Yes") &
            (temp_table_curr['IP'] == ip if ip else True) &
            (temp_table_curr['State'].isin(state) if state else True) &
            (temp_table_curr['LGA'].isin(lga) if lga else True) &
            (temp_table_curr['SurgeCommand'].isin(command) if command else True) &
            (temp_table_curr['FacilityName'].isin(facility) if facility else True)
        ]
    else:
        filtered_df = pd.DataFrame()

    if filtered_df.empty:
        # Return a specific status code for the frontend to handle
        return '', 204

    output = io.StringIO()
    filtered_df.to_csv(output, index=False)
    output.seek(0)

    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=line_list.csv"
    response.headers["Content-type"] = "text/csv"
    return response


data_response = {} 
############################################################################################
# DEFINE INDICATOR VALUES AND PLOTS FUNCTIONS
############################################################################################
@app.route('/Request_Returned', methods=['GET', 'POST'])
def Request_Returned():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        data = request.json
        if not data:
            return "Bad Request: No JSON data found", 400
    elif request.method == 'GET':
        return render_template('tmd_curr_rpt.html', username=session['username'])

    # Extract the selected options from the form data using AJAX request (Access the form data)
    selected_indicator = data.get('indicator')
    selected_ip = data.get('selectedIP') 
    selected_states = data.get('selectedState')
    selected_lgas = data.get('selectedLGA')
    selected_commands = data.get('selectedCommand')
    selected_facility = data.get('selectedFacility')    

    if selected_indicator == 'TX_CURR' and selected_ip == 'CIHP':
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment current indicator
        data_1 = tx_curr_temp_tbl[tx_curr_temp_tbl['IP'] == selected_ip]   
        # Number of facilities
        fac_num_curr_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_curr_dict = int(data_1['TX_CURR'].sum())        
        # Biometrics Captured
        achieved_pbs_curr_dict = int(data_1['Biometrics Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_curr_percent = (achieved_pbs_curr_dict / achieved_tx_curr_dict) * 100
        percent_pbs_curr_dict = f"{pbs_curr_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_curr_dict = int(data_1['Biometrics Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_curr_percent = (achieved_pbs_rec_tx_curr_dict / achieved_pbs_curr_dict) * 100
        percent_pbs_rec_tx_curr_dict = f"{pbs_rec_tx_curr_percent:.1f}"             
        ############################################################################################       
        # Treatment Current By Pediatric & Adult Clients & Sex above 
        data_4 = df_curr_list[df_curr_list['IP'] == selected_ip]
        longfm1_ip_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_curr_widefm2_ip_age_sex = longfm1_ip_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='CurrentARTStatus_28Days')
        plot1=tx_curr_widefm2_ip_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                            fontsize={'xticks': 10, 'yticks': 10, 'title': 10},  width=plot_width, height=height, 
                                            title='Treatment Current By Pediatric & Adult Clients & Sex').opts(
                                            hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_CURR', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the current document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_curr_widefm2_ip_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)
        
                                       
        # Treatment Current Distribution By Sex 
        data_5 = df_curr_list[df_curr_list['IP'] == selected_ip]        
        data_5agg = data_5.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b['color'] = ["#2b9eb0", "#9ecae1"]         
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Creating chart
        chart = figure(height=height, width=plot_width, title="Treatment Current By Sex", 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")

       
        # Treatment Current By AgeGroup & Sex   
        data_2 = df_curr_list[df_curr_list['IP'] == selected_ip]     
        age_group_tx_curr = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_curr = age_group_tx_curr.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_curr)
        plot3 = age_group_tx_curr.plot_bokeh.barh(title='Treatment Current By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.toolbar.logo = None
        plot3.x_range.start = 0        
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_curr)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment Current By Age Group & Sex
        # Filter the data
        data_3 = df_pbs_list[df_pbs_list['IP'] == selected_ip]
        # Create crosstab
        age_group_pbs_curr = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_curr = age_group_pbs_curr.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_curr)
        # Plot ylabel=''
        plot4 = age_group_pbs_curr.plot_bokeh.barh(title='Treatment Current Biometrics By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0       
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_curr 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")
             

        # Treatment Current MMD Distribution
        data_5 = df_curr_list[df_curr_list['IP'] == selected_ip]        
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()        
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)] 
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b["value"] = data_5b['value'].astype(str)
        data_5b["value"] = data_5b["value"].str.pad(35, side="left")
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Creating chart
        chart = figure(height=height, width=plot_width, title="Treatment Current By Multi-Month Dispensing (MMD)", 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@mmd: @formatted_value, Percentage: @percentage{0.0}%",x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, inner_radius=0.20, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='mmd', source=source)
      
        # Callouts for labels
        callouts = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-25, source=source, render_mode='canvas',
                            text_align="center", angle=0, text_font_size='10pt', text_color='#000000')
        chart.add_layout(callouts)
        percentage_callouts = LabelSet(x="cos2", y="sin2", y_offset=-25, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')
        chart.add_layout(percentage_callouts)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None   
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((chart, export_button), CDN, "plot5")
        

        # Treatment Current By MMD & 5-Year Age Band
        data_7 = df_curr_list[df_curr_list['IP'] == selected_ip]     
        # Perform crosstab to get counts by AgeGroup and MMD
        tx_curr_age_mmd = pd.crosstab(data_7['AgeGroup'], data_7['mmd']).reset_index()
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(tx_curr_age_mmd)
        # List of MMD factors
        mmd_factors = tx_curr_age_mmd.columns[1:]
        # Create the Bokeh figure for stacked column chart
        plot = figure(x_range=tx_curr_age_mmd['AgeGroup'], 
                    title="Treatment Current By MMD & 5-Year Age Band", x_axis_label="", y_axis_label="Number of clients", 
                    height=height, plot_width=plot_width,  # Set the plot width
                    toolbar_location='right', tools=[CrosshairTool(), PanTool(), BoxZoomTool(), SaveTool(), ResetTool()])

        # Add a HoverTool to display details on hover
        hover = HoverTool(tooltips=[("Age Band", "@AgeGroup"), ("MMD", "$name"), ("TX_CURR", "@$name{0,0}")])
        plot.add_tools(hover)
        # Add stacked columns to the figure
        colors = ["#2b9eb0", '#2beaea', '#2b9eea', "#9ecae1"]
        plot.vbar_stack(stackers=mmd_factors, x='AgeGroup', width=0.8, color=colors, 
                        source=source, legend_label=[str(mmd) for mmd in mmd_factors])
        # Customize plot
        plot.xaxis.major_label_orientation = 1.2
        plot.toolbar.logo = None
        plot.y_range.start = 0 
        # Format y-axis with thousand separators
        plot.yaxis.formatter = NumeralTickFormatter(format="0,0")
        # Add legend click policy
        plot.legend.click_policy = "hide"
        plot.toolbar.autohide = True
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD & 5yr age.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label="Export CSV", button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot, export_button), CDN, "plot6")


        data_6 = tx_curr_temp_tbl[tx_curr_temp_tbl['IP'] == selected_ip]  
        data_6b = data_6.groupby('State')[['TX_CURR','Biometrics Captured', 'Biometrics Recaptured']].sum()   
        data_6b_curr=data_6b.reset_index()  

        def get_map_tx_curr(state_name):
            # Function to get the TX_CURR value for a given state
            tx_curr_values = tx_curr_temp_tbl.groupby('State')['TX_CURR'].sum()
            return tx_curr_values.get(state_name, "N/A")
        
        def get_map_tx_curr2(state_name):
            # Convert list to dictionary
            tx_curr_cap_dict = dict(zip(data_6b_curr['State'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Captured'] / data_6b_curr['TX_CURR']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_curr_cap_dict.get(state_name, "N/A")

        def get_map_tx_curr3(state_name):
            # Function to get the TX_PVLS value for a given state
            tx_curr_recap_dict = dict(zip(data_6b_curr['State'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Recaptured'] / data_6b_curr['Biometrics Captured']) * 100, decimals=1))))
            return tx_curr_recap_dict.get(state_name, "N/A")
        
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria 
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=600, tiles="cartodb positron")  
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Treatment Current Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_curr.reset_index(), columns=['State', 'TX_CURR'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_CURR', highlight=True).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                TX_CURR: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''        
        
        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            tx_curr_value = get_map_tx_curr(loc["popup"])
            tx_curr_formatted = format_with_thousand_separator(tx_curr_value)            
            tx_curr_cap_dict = get_map_tx_curr2(loc["popup"])
            tx_curr_recap_dict = get_map_tx_curr3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_curr_formatted, 
                                                tx_curr_cap_dict, 
                                                tx_curr_recap_dict) 
            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip  # Add the tooltip
            ).add_to(marker_cluster) 
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_curr)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_curr_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()      

        ####################### DATATABLE ######################################################################################
        plot19_html = tx_curr_temp_tbl.to_html(index=False, table_id="table_cur" ,classes=['tbl_ip', 'table table-bordered',"display"], escape=False)
      

        data_response = {
            'fac_num': fac_num_curr_dict,
            'achieved': achieved_tx_curr_dict,
            'achieved_pbs': achieved_pbs_curr_dict,
            'percent_pbs': percent_pbs_curr_dict,
            'achieved_recapture': achieved_pbs_rec_tx_curr_dict,
            'percent_recaptured': percent_pbs_rec_tx_curr_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot17': {'main': plot17_html, 'additional': tx_curr_button_json}, 
            'plot19': plot19_html
        }     
           
        
    elif (selected_indicator == 'TX_NEW' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_new_temp_tbl[tx_new_temp_tbl['IP'] == selected_ip]
        # Number of facilities
        fac_num_tx_new_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_new_dict = int(data_1['TX_NEW'].sum())        
        # TX_NEW Captured
        achieved_pbs_tx_new_dict = int(data_1['TX_NEW Captured'].sum())        
        # TX_NEW Coverage (%)
        pbs_new_percent = (achieved_pbs_tx_new_dict / achieved_tx_new_dict) * 100
        percent_pbs_tx_new_dict = f"{pbs_new_percent:.1f}"        
        # TX_NEW Recaptured
        achieved_pbs_rec_tx_new_dict = int(data_1['TX_NEW Recaptured'].sum())        
        # Recaptured TX_NEW Coverage (%)
        pbs_rec_tx_new_percent = (achieved_pbs_rec_tx_new_dict / achieved_pbs_tx_new_dict) * 100
        percent_pbs_rec_tx_new_dict = f"{pbs_rec_tx_new_percent:.1f}"                 
        ############################################################################################
        # Handle data elements from the line list table
        data_2 = df_new_list[df_new_list['IP'] == selected_ip]        
        # Treatment New By Pediatric & Adult Clients & Sex
        data_4 = df_new_list[df_new_list['IP'] == selected_ip]
        longfm1_ip_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_new_widefm2_ip_age_sex = longfm1_ip_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_NEW')
        plot1=tx_new_widefm2_ip_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title='Treatment New By Pediatric & Adult Clients & Sex').opts(
                                        hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_NEW', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the New document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_new_widefm2_ip_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment New CD4 Distribution
        data_5 = df_cd4_new_list[df_cd4_new_list['IP'] == selected_ip]        
        data_5agg = data_5.TX_NEW_CD4.value_counts().reset_index().rename(columns={'index':'TX_NEW_CD4', 'TX_NEW_CD4':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        value = data_5b["value"].values
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]        
        data_5b['color'] = ["#2b9eb0", '#2b9eea', "#9ecae1"]     
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b) 
        # Creating chart
        chart = figure(height=height, width=plot_width, title="Treatment New By CD4 Count", 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW_CD4: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW_CD4', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
                        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")

        
        # Treatment New By AgeGroup & Sex
        age_group_tx_new = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_new = age_group_tx_new.set_index('AgeGroup')
        plot3 = age_group_tx_new.plot_bokeh.barh(title='Treatment New By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.x_range.start = 0
        plot3.toolbar.logo = None   
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment New By Age Group & Sex
        data_3 = df_pbs_new_list[df_pbs_new_list['IP'] == selected_ip]
        age_group_pbs_tx_new = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_tx_new = age_group_pbs_tx_new.set_index('AgeGroup')
        plot4 = age_group_pbs_tx_new.plot_bokeh.barh(title='Treatment New Biometrics By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None   
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_pbs_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new pbs by age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")


        # TX_NEW By Month 
        data_8 = df_new_list[df_new_list['IP'] == selected_ip]
        data_8agg = data_8.TX_NEW_month.value_counts().reset_index().rename(columns={'index':'TX_NEW_month', 'TX_NEW_month':'value'})
        data_8_count = data_8agg.copy()
        data_8_count['formatted_value']=["{:,.0f}".format(val) for val in data_8_count['value']]        
        plot5new_days=data_8_count.hvplot.bar(x="TX_NEW_month", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='',  width=plot_width, 
                                        title="TX_NEW By Month").opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW_month")                                

        labels = hv.Labels(data=data_8_count, kdims=['TX_NEW_month', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("TX_NEW Month", "@TX_NEW_month"), ("TX_NEW", "@value{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by month.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotnew_month_html = file_html((bokeh_model, export_button), CDN, "plot5")


        # Treatment New in Month 1 By AgeGroup & Sex
        data_9 = df_new_listmth1[df_new_listmth1['IP'] == selected_ip]
        age_sex_tx_new_month1 = pd.crosstab(data_9['AgeGroup'], data_9['Sex']).reset_index()
        age_sex_tx_new_month1 = age_sex_tx_new_month1.set_index('AgeGroup')           
        if not age_sex_tx_new_month1.empty:
            plot6 = age_sex_tx_new_month1.plot_bokeh.barh(title='Treatment New In Month 1 By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)
            # Set the width and height of the plot
            plot6.plot.width = plot_width
            # Adjusting toolbar size
            plot6.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot6.x_range.start = 0
            plot6.toolbar.logo = None    
            plot6.toolbar.active_scroll = None
            plot6.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month1)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 1 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot6_html = file_html((plot6, export_button), CDN, "plot6")
        else:
            # Handle the empty data case
            plot6_html = "No Treatment New In Month 1 By 5-Year Age Band & Sex data available to plot."           


        # Treatment New in Month 2 By AgeGroup & Sex
        data_9 = df_new_listmth2[df_new_listmth2['IP'] == selected_ip]
        age_sex_tx_new_month2 = pd.crosstab(data_9['AgeGroup'], data_9['Sex']).reset_index()
        age_sex_tx_new_month2 = age_sex_tx_new_month2.set_index('AgeGroup')          
        if not age_sex_tx_new_month2.empty:
            plot9 = age_sex_tx_new_month2.plot_bokeh.bar(title='Treatment New In Month 2 By 5-Year Age Band & Sex', legend = "top_right",line_width=8.0, show_figure=False)
            # Set the width and height of the plot
            plot9.plot.width = 800
            # Adjusting toolbar size
            plot9.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot9.y_range.start = 0
            plot9.toolbar.logo = None    
            plot9.toolbar.active_scroll = None
            plot9.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month2)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 2 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot9_html = file_html((plot9, export_button), CDN, "plot9")
        else:
            # Handle the empty data case
            plot9_html = "No Treatment New In Month 2 By 5-Year Age Band & Sex data available to plot."            


        # Treatment New in Month 3 By AgeGroup & Sex
        data_10 = df_new_listmth3[df_new_listmth3['IP'] == selected_ip]
        age_sex_tx_new_month3 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month3 = age_sex_tx_new_month3.set_index('AgeGroup')          
        if not age_sex_tx_new_month3.empty:
            plot10 = age_sex_tx_new_month3.plot_bokeh.bar(title='Treatment New In Month 3 By 5-Year Age Band & Sex', legend = "top_right",line_width=8.0, show_figure=False)
            # Set the width and height of the plot
            plot10.plot.width = 800
            # Adjusting toolbar size
            plot10.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot10.y_range.start = 0
            plot10.toolbar.logo = None   
            plot10.toolbar.active_scroll = None
            plot10.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month3)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 3 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot10_html = file_html((plot10, export_button), CDN, "plot10")
        else:
            # Handle the empty data case
            plot10_html = "No Treatment New In Month 3 By 5-Year Age Band & Sex data available to plot."               


        # Treatment New ML Distribution
        data_7 = df_ml_new_list[df_ml_new_list['IP'] == selected_ip]        
        data_7agg = data_7['TX_NEW ML'].value_counts().reset_index().rename(columns={'index':'TX_NEW ML', 'TX_NEW ML':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.28
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.28
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # data_7b['color'] = ["#2b9eb0", '#2b9eea', '#2beaea', "#9ecae1"]      
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]       
        # Pad the 'value' column with spaces to improve label alignment
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Creating chart vertical
        chart = figure(height=height, width=620, title="Treatment New Mortality & Loss Total = {:,.0f}".format(total_count), 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW ML: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW ML', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-9, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-9, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None        
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new ml.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot11_html = file_html((chart, export_button), CDN, "plot11")  


        data_6 = tx_new_temp_tbl[tx_new_temp_tbl['IP'] == selected_ip]   
        data_6b = data_6.groupby('State')['TX_NEW', 'TX_NEW month 1','TX_NEW month 2', 'TX_NEW month 3'].sum()   
        data_6b_new=data_6b.reset_index() 

        def get_map_tx_new(state_name):
            # Function to get the TX_NEW value for a given state
            tx_new_values = data_6b_new.groupby('State')['TX_NEW'].sum()
            return tx_new_values.get(state_name, "N/A")
        
        def get_map_tx_new_month_1(state_name):
            # Function to get the TX_NEW value for a given state
            tx_new_month_1 = data_6b_new.groupby('State')['TX_NEW month 1'].sum()
            return tx_new_month_1.get(state_name, "N/A")
        
        def get_map_tx_new_month_2(state_name):
            # Function to get the TX_NEW value for a given state
            tx_new_month_2 = data_6b_new.groupby('State')['TX_NEW month 2'].sum()
            return tx_new_month_2.get(state_name, "N/A")
        
        def get_map_tx_new_month_3(state_name):
            # Function to get the TX_NEW value for a given state
            tx_new_month_3 = data_6b_new.groupby('State')['TX_NEW month 3'].sum()
            return tx_new_month_3.get(state_name, "N/A")

        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=600, tiles="cartodb positron")  
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Treatment New Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_new, columns=['State', 'TX_NEW'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_NEW', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                TX_NEW: {}<br>
                Month 1: {}<br>
                Month 2: {}<br>
                Month 3: {}
            </div>
        '''
        
        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            tx_new_value = get_map_tx_new(loc["popup"])
            tx_new_formatted = format_with_thousand_separator(tx_new_value)  
            tx_new_month_1 = get_map_tx_new_month_1(loc["popup"])
            tx_new_mth_1_formatted = format_with_thousand_separator(tx_new_month_1) 

            tx_new_month_2 = get_map_tx_new_month_2(loc["popup"])
            tx_new_mth_2_formatted = format_with_thousand_separator(tx_new_month_2) 

            tx_new_month_3 = get_map_tx_new_month_3(loc["popup"])
            tx_new_mth_3_formatted = format_with_thousand_separator(tx_new_month_3)             
            
            popup_content = popup_style.format(loc["popup"], tx_new_formatted, tx_new_mth_1_formatted,
                                               tx_new_mth_2_formatted, tx_new_mth_3_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip  # Add the tooltip
            ).add_to(marker_cluster) 
        
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_new)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_new_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()
        

        ####################### DATATABLE ###################################################################################### tbl_ip_nu
        plot19_html = data_1.to_html(index=False, table_id="table_nu" , classes=['tbl_ip', 'table table-bordered',"display"], escape=False)
 

        data_response = {
            'fac_num': fac_num_tx_new_dict,
            'achieved': achieved_tx_new_dict,
            'achieved_pbs': achieved_pbs_tx_new_dict,
            'percent_pbs': percent_pbs_tx_new_dict,
            'achieved_recapture': achieved_pbs_rec_tx_new_dict,
            'percent_recaptured': percent_pbs_rec_tx_new_dict,
            'plot1': {'main': plot1_html, 'additional': button_json}, 
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plotnew_month_html,
            'plot6': plot6_html, 
            'plot9': plot9_html,  
            'plot10': plot10_html, 
            'plot11': plot11_html,           
            'plot17': {'main': plot17_html, 'additional': tx_new_button_json}, 
            'plot19': plot19_html
        }       
                 
                               
    elif (selected_indicator == 'TX_ML' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment ml indicator
        data_1 = tx_ml_df[tx_ml_df['IP'] == selected_ip]
        # Number of facilities
        fac_num_tx_ml_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_ml_dict = int(data_1['TX_ML'].sum())  
        # TX_ML Captured
        achieved_pbs_tx_ml_dict = int(data_1['TX_ML Captured'].sum())        
        # TX_ML Coverage (%)
        pbs_ml_percent = (achieved_pbs_tx_ml_dict / achieved_tx_ml_dict) * 100
        percent_pbs_tx_ml_dict = f"{pbs_ml_percent:.1f}"        
        # TX_ML Recaptured
        achieved_pbs_rec_tx_ml_dict = int(data_1['TX_ML Recaptured'].sum())        
        # Recaptured TX_ML Coverage (%)
        pbs_rec_tx_ml_percent = (achieved_pbs_rec_tx_ml_dict / achieved_pbs_tx_ml_dict) * 100
        percent_pbs_rec_tx_ml_dict = f"{pbs_rec_tx_ml_percent:.1f}"             
        ############################################################################################
        # Treatment Mortality & Loss By Pediatric & Adult Clients & Sex
        data_4 = df_ml_list[df_ml_list['IP'] == selected_ip]
        longfm1_ip_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_ml_widefm2_ip_age_sex = longfm1_ip_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_ML')
        plot1ml=tx_ml_widefm2_ip_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title='Treatment Mortality & Loss By Pediatric & Adult Clients & Sex').opts(
                                        hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model
        bokeh_model = hv.render(plot1ml, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_ML', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_ml_widefm2_ip_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)      
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment Mortality & Loss Outcomes
        data_5 = df_ml_2_list[df_ml_2_list['IP'] == selected_ip]        
        data_5agg = data_5.TX_ML_Outcome_2.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome_2', 'TX_ML_Outcome_2':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)] 
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        # Format the 'value' column with thousand separators
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        # Pad the 'value' column with spaces to improve label alignment
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Creating chart
        chart = figure(height=height, width=plot_width, title="Treatment Mortality & Loss Outcomes", 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,box_zoom,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome_2: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome_2', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-15, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-15, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml outcomes.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")        

        
        # Interrution in Treatment By Age Group & Sex 
        data_4b = df_ml_iit_list[df_ml_iit_list['IP'] == selected_ip]
        age_group_iit = pd.crosstab(data_4b['AgeGroup'], data_4b['Sex']).reset_index()
        age_group_iit = age_group_iit.set_index('AgeGroup')
        plot4 = age_group_iit.plot_bokeh.barh(title='IIT By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None  
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_iit)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT By 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")


        # Interrution in Treatment in Days 
        data_4c = df_ml_iit_days_list[df_ml_iit_days_list['IP'] == selected_ip]
        data_4agg = data_4c.IIT_duration_days.value_counts().reset_index().rename(columns={'index':'IIT_duration_days', 'IIT_duration_days':'value'})
        data_4c_count = data_4agg.copy()
        # Define the custom order
        custom_order = ['IIT for â‰¤30 days', 'IIT for 31 to 60 days', 'IIT for 61 to 180 days', 'IIT for >180 days']
        # Convert the IIT_duration_days column to a categorical type with the custom order
        data_4c_count['IIT_duration_days'] = pd.Categorical(data_4c_count['IIT_duration_days'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order   
        data_4c_count = data_4c_count.sort_values('IIT_duration_days')         
        data_4c_count['formatted_value']=["{:,.0f}".format(val) for val in data_4c_count['value']]        
        plot1iit_days=data_4c_count.hvplot.bar(x="IIT_duration_days", y='value', height=height, color='#6d99ff', grid=True, rot=30, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title="IIT Duration (Days)").opts(hooks=[remove_bokeh_logo], toolbar='above')                             
        
        labels = hv.Labels(data=data_4c_count, kdims=['IIT_duration_days', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_iit = plot1iit_days * labels
        bokeh_model = hv.render(plot_iit, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("IIT Duration in Days", "@IIT_duration_days"), ("Days", "@value{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(data_4agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT duration in days.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotiit_days_html = file_html((bokeh_model, export_button), CDN, "plot4")

   
        # Overall IIT Rate
        tx_ml_df_ip = tx_ml_df[tx_ml_df['IP'] == selected_ip]
        tx_ml_df_ip = tx_ml_df_ip.groupby('IP', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_ip['IIT Rate (%)'] = np.round((tx_ml_df_ip['IIT'] / tx_ml_df_ip['TX_CURR']) * 100, decimals=1)
        data_7 = tx_ml_df_ip.copy()
        source = ColumnDataSource(data_7)
        # Create a new plot with a title and axis labels 700
        p = figure(x_range=FactorRange(*['CIHP']), plot_height=height, plot_width=plot_width, title="CIHP IIT Rate",
                    toolbar_location="above")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('IP', -0.3, range=p.x_range), top='TX_CURR', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('IP', -0.1, range=p.x_range), top='IIT', width=0.18, source=source,
                                    color="#71aebf", legend_label="IIT")}        
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))
        # Add labels for bars
        p.text(x=dodge('IP', -0.3, range=p.x_range), y='TX_CURR', text='TX_CURR',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('IP', -0.1, range=p.x_range), y='IIT', text='IIT',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.2]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('IP', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('IP', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        # Format y-axis labels with thousands separators
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 
        # Hide the toolbar
        p.toolbar.autohide = True
        # Adjusting legend label size
        p.legend.label_text_font_size = '10pt'
        # Position the legend outside the plot area 
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        p.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'overall IIT rate.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((p, export_button), CDN, "plot5")


        # IIT By MMD
        data_8 = tx_ml_df_ip_mmd[tx_ml_df_ip_mmd['IP'] == selected_ip]    
        # Define the data source
        source = ColumnDataSource(data_8)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title="% IIT By MMD",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('mmd', -0.2, range=p.x_range), top='TX_CURR', width=0.2, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('mmd', 0.1, range=p.x_range), top='IIT', width=0.2, source=source,
                color="#71aebf", legend_label="IIT")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('mmd', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('mmd', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.legend.label_text_font_size = '10pt'
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        p.toolbar.logo = None
        p.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_8)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((p, export_button), CDN, "plot6") 


        # % IIT By Supported States
        data_9 = tx_ml_df[tx_ml_df['IP'] == selected_ip]  
        tx_ml_df_ip_state = data_9.groupby('State', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_ip_state['IIT Rate (%)'] = np.round((tx_ml_df_ip_state['IIT'] / tx_ml_df_ip_state['TX_CURR']) * 100, decimals=1)   
        # Define the data source
        source = ColumnDataSource(tx_ml_df_ip_state)
        states = source.data["State"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=states, plot_height=height, plot_width=800, title="% IIT By Supported States",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('State', -0.2, range=p.x_range), top='TX_CURR', width=0.25, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('State', 0.1, range=p.x_range), top='IIT', width=0.25, source=source,
                color="#71aebf", legend_label="IIT")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('State', '@State'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('State', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('State', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('State', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('State', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '10pt'        
        p.add_layout(p.legend[0], 'right')
        p.legend.click_policy = "hide"
        # Create csv table for export
        source = ColumnDataSource(tx_ml_df_ip_state)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by state.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((p, export_button), CDN, "plot9")


        # Interrution in Treatment Distribution
        data_7 = df_ml_iit_list[df_ml_iit_list['IP'] == selected_ip]        
        data_7agg = data_7.TX_ML_Outcome.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome', 'TX_ML_Outcome':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.27
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.27
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]        
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Creating chart vertical
        chart = figure(height=height, width=620, title="Interrution In Treatment (IIT) Total = {:,.0f}".format(total_count), 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot10_html = file_html((chart, export_button), CDN, "plot10") 

        
        data_6 = tx_ml_df[tx_ml_df['IP'] == selected_ip]    
        data_6b = data_6.groupby('State')['TX_ML','IIT', 'Stopped Treatment', 'Transferred Out', 'Dead'].sum() 
        data_6b_df = data_6b.reset_index()
        def get_map_tx_ml(state_name):
            # Function to get the TX_ML value for a given state
            tx_ml_values = data_6b_df.groupby('State')['TX_ML'].sum()
            return tx_ml_values.get(state_name, "N/A")
        
        def get_map_tx_ml_iit(state_name):
            # Function to get the IIT value for a given state
            tx_ml_iit = data_6b_df.groupby('State')['IIT'].sum()
            return tx_ml_iit.get(state_name, "N/A")
        
        def get_map_tx_ml_stopped(state_name):
            # Function to get the Stopped value for a given state
            tx_ml_stopped = data_6b_df.groupby('State')['Stopped Treatment'].sum()
            return tx_ml_stopped.get(state_name, "N/A")
        
        def get_map_tx_ml_to(state_name):
            # Function to get the Transferred Out value for a given state
            tx_ml_to = data_6b_df.groupby('State')['Transferred Out'].sum()
            return tx_ml_to.get(state_name, "N/A")
        
        def get_map_tx_ml_dead(state_name):
            # Function to get the Dead value for a given state
            tx_ml_dead = data_6b_df.groupby('State')['Dead'].sum()
            return tx_ml_dead.get(state_name, "N/A")
   
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=600, tiles="cartodb positron")  
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Treatment Mortality & Loss Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['State', 'TX_ML'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_ML', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                TX_ML: {}<br>
                IIT: {}<br>
                Stopped: {}<br>
                Transferred Out: {}<br>
                Dead: {}
            </div>
        '''
        
        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            tx_ml_value = get_map_tx_ml(loc["popup"])
            tx_ml_formatted = format_with_thousand_separator(tx_ml_value)   

            tx_ml_iit = get_map_tx_ml_iit(loc["popup"])
            tx_ml_iit_formatted = format_with_thousand_separator(tx_ml_iit)  

            tx_ml_stopped = get_map_tx_ml_stopped(loc["popup"])
            tx_ml_stopped_formatted = format_with_thousand_separator(tx_ml_stopped) 

            tx_ml_to = get_map_tx_ml_to(loc["popup"])
            tx_ml_to_formatted = format_with_thousand_separator(tx_ml_to) 

            tx_ml_dead = get_map_tx_ml_dead(loc["popup"])
            tx_ml_dead_formatted = format_with_thousand_separator(tx_ml_dead) 

            popup_content = popup_style.format(loc["popup"], tx_ml_formatted, tx_ml_iit_formatted, tx_ml_stopped_formatted, 
                                               tx_ml_to_formatted, tx_ml_dead_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip  # Add the tooltip
            ).add_to(marker_cluster) 

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_ml_button_json = json_item(export_button)  
        plot17_html = ng_map.get_root().render()       
   
        
    ####################### DATATABLE ######################################################################################        
        plot19_html = tx_ml_df_sorted.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)
        
        data_response = {
            'fac_num': fac_num_tx_ml_dict,
            'achieved': achieved_tx_ml_dict,
            'achieved_pbs': achieved_pbs_tx_ml_dict,
            'percent_pbs': percent_pbs_tx_ml_dict,
            'achieved_recapture': achieved_pbs_rec_tx_ml_dict,
            'percent_recaptured': percent_pbs_rec_tx_ml_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot4_html,
            'plot4': plotiit_days_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': tx_ml_button_json}, 
            'plot19': plot19_html
        }     
      

    elif (selected_indicator == 'TX_RTT' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['IP'] == selected_ip]
        # Number of facilities
        fac_num_tx_rtt_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_rtt_dict = int(data_1['TX_RTT'].sum())        
        # TX_RTT Captured
        achieved_pbs_tx_rtt_dict = int(data_1['TX_RTT Captured'].sum())        
        # TX_RTT Coverage (%)
        pbs_rtt_percent = (achieved_pbs_tx_rtt_dict / achieved_tx_rtt_dict) * 100
        percent_pbs_tx_rtt_dict = f"{pbs_rtt_percent:.1f}"        
        # TX_RTT Recaptured
        achieved_pbs_rec_tx_rtt_dict = int(data_1['TX_RTT Recaptured'].sum())        
        # Recaptured TX_RTT Coverage (%)
        pbs_rec_tx_rtt_percent = (achieved_pbs_rec_tx_rtt_dict / achieved_pbs_tx_rtt_dict) * 100
        percent_pbs_rec_tx_rtt_dict = f"{pbs_rec_tx_rtt_percent:.1f}"            
        ############################################################################################
        # Returned To Treatment Distribution By Sex 
        data_2 = df_rtt_list[df_rtt_list['IP'] == selected_ip]        
        data_2agg = data_2.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_2b = data_2agg.copy()
        total_count = data_2b['value'].sum()
        data_2b['angle'] = data_2b['value'] / total_count * 2 * pi
        value = data_2b["value"].values
        data_2b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_2b['cos'] = np.cos(data_2b['cumulative_angle']) * 0.32
        data_2b['sin'] = np.sin(data_2b['cumulative_angle']) * 0.32
        data_2b['cos2'] = np.cos(data_2b['cumulative_angle']) * 0.41
        data_2b['sin2'] = np.sin(data_2b['cumulative_angle']) * 0.41
        data_2b['formatted_value']=["{:,.0f}".format(val) for val in data_2b['value']]
        data_2b['percentage'] = (data_2b['value'] / total_count) * 100
        data_2b['label']=["({:.1f}%)".format(val) for val in data_2b['percentage']]
        data_2b['color'] = ['#2b9eea', '#2beaea'] 
        # Pad the 'value' column with spaces to improve label alignment
        data_2b["value"] = data_2b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_2b)
        # Creating chart
        chart = figure(height=height, width=plot_width, title="Returned To Treatment By Sex", 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_2agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((chart, export_button), CDN, "plot3")


        # Returned To Treatment Distribution
        data_3 = df_rtt_list[df_rtt_list['IP'] == selected_ip]        
        data_3agg = data_3.TX_RTT_Outcome.value_counts().reset_index().rename(columns={'index':'TX_RTT_Outcome', 'TX_RTT_Outcome':'value'})
        data_3b = data_3agg.copy()
        total_count = data_3b['value'].sum()
        value = data_3b["value"].values
        data_3b['angle'] = data_3b['value'] / total_count * 2 * pi
        data_3b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_3b['cos'] = np.cos(data_3b['cumulative_angle']) * 0.27
        data_3b['sin'] = np.sin(data_3b['cumulative_angle']) * 0.27
        data_3b['cos2'] = np.cos(data_3b['cumulative_angle']) * 0.35
        data_3b['sin2'] = np.sin(data_3b['cumulative_angle']) * 0.35
        data_3b['formatted_value']=["{:,.0f}".format(val) for val in data_3b['value']]
        data_3b['percentage'] = (data_3b['value'] / total_count) * 100
        data_3b['label']=["({:.1f}%)".format(val) for val in data_3b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_3b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_3b['color'] = color_palette[:len(data_3b)]        
        # Pad the 'value' column with spaces to improve label alignment
        data_3b["value"] = data_3b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Creating chart vertical
        chart = figure(height=height, width=620, title="Returned To Treatment (TX_RTT) Total = {:,.0f}".format(total_count), 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@TX_RTT_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_RTT_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_3agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot4_html = file_html((chart, export_button), CDN, "plot4")


        # Returned To Treatment By AgeGroup & Sex        
        age_group_tx_rtt = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_tx_rtt = age_group_tx_rtt.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_rtt)
        plot5 = age_group_tx_rtt.plot_bokeh.barh(title='Returned To Treatment By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot5.plot.width = plot_width
        # Adjusting toolbar size
        plot5.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot5.x_range.start = 0
        plot5.toolbar.logo = None    
        plot5.toolbar.active_scroll = None
        plot5.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_rtt)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh plot to HTML
        plot5_html = file_html((plot5, export_button), CDN, "plot5")        


        # Returned To Treatment By Age Group & Sex (Biometrics)
        # Filter the data
        data_4 = rtt_pbs_list[rtt_pbs_list['IP'] == selected_ip]
        # Create crosstab
        age_group_pbs_rtt = pd.crosstab(data_4['AgeGroup'], data_4['Sex']).reset_index()
        age_group_pbs_rtt = age_group_pbs_rtt.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_rtt)
        # Plot 
        plot4 = age_group_pbs_rtt.plot_bokeh.barh(title='TX_RTT Biometrics Captured By 5-Year Age Band & Sex', legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0        
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_rtt 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot4, export_button), CDN, "plot6")


        # Returned To Treatment MMD Distribution
        data_5 = df_rtt_list[df_rtt_list['IP'] == selected_ip]  
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        # Define the custom order
        custom_order = ['MMD <3', 'MMD 3', 'MMD 4-5', 'MMD 6']
        # Convert the mmd column to a categorical type with the custom order
        data_5agg['mmd'] = pd.Categorical(data_5agg['mmd'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order
        data_5agg = data_5agg.sort_values('mmd')
        data_5_count = data_5agg.copy()
        data_5_count['formatted_value'] = ["{:,.0f}".format(val) for val in data_5_count['value']]
        # Define colors for each bar
        colors = ['#ff6f61', '#6aff99', '#6d99ff', '#aa66cc']
        data_5_count['color'] = colors[:len(data_5_count)]
        # Create the bar plot
        plot5new_days = data_5_count.hvplot.barh(
            x="mmd", y='value', height=height, color='color', grid=True, xlabel='', line_color=None, fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, 
            ylabel='', width=plot_width, title="Returned To Treatment By MMD").opts(hooks=[remove_bokeh_logo], toolbar='above')

        # Add labels
        labels = hv.Labels(data=data_5_count, kdims=['mmd', 'value'], vdims='formatted_value')
        # Overlay labels on the bar plot
        plot_new = plot5new_days * labels
        # Get the underlying Bokeh plot
        bokeh_plot = hv.render(plot_new)
        # Format the x-axis with a thousand separator
        bokeh_plot.xaxis[0].formatter = NumeralTickFormatter(format="0,0")       
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("MMD", "@mmd"), ("TX_RTT", "@value{0,0}")]
        bokeh_plot.add_tools(hover)  
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)

        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot7_html = file_html((bokeh_plot, export_button), CDN, "plot7")           

        
        # Returned To Treatment CD4 Distribution
        data_6 = rtt_cd4_list[rtt_cd4_list['IP'] == selected_ip]
        data_6agg = data_6.TX_RTT_CD4.value_counts().reset_index().rename(columns={'index':'TX_RTT_CD4', 'TX_RTT_CD4':'value'})
        data_6_count = data_6agg.copy()
        data_6_count['formatted_value']=["{:,.0f}".format(val) for val in data_6_count['value']]        
        plot5new_days=data_6_count.hvplot.bar(x="TX_RTT_CD4", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title="Returned To Treatment By CD4 Count").opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT_CD4")                                

        labels = hv.Labels(data=data_6_count, kdims=['TX_RTT_CD4', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("TX_RTT By CD4", "@TX_RTT_CD4"), ("TX_RTT", "@value{0,0}")]
        bokeh_model.add_tools(hover)  
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_6agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot8_html = file_html((bokeh_model, export_button), CDN, "plot8")        


        data_7 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['IP'] == selected_ip]  
        data_7b_rtt = data_7.groupby('State')[['TX_RTT','TX_RTT Captured', 'TX_RTT Recaptured']].sum()   
        data_7b_rtt=data_7b_rtt.reset_index()  

        def get_map_tx_rtt(state_name):
            # Function to get the TX_RTT value for a given state
            tx_rtt_values = data_7b_rtt.groupby('State')['TX_RTT'].sum()            
            return tx_rtt_values.get(state_name, "N/A")
        
        def get_map_tx_rtt2(state_name):
            # Convert list to dictionary
            tx_rtt_cap_dict = dict(zip(data_7b_rtt['State'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Captured'] / data_7b_rtt['TX_RTT']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_rtt_cap_dict.get(state_name, "N/A")

        def get_map_tx_rtt3(state_name):
            # Function to get the TX_PVLS value for a given state
            tx_rtt_recap_dict = dict(zip(data_7b_rtt['State'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Recaptured'] / data_7b_rtt['TX_RTT Captured']) * 100, decimals=1))))
            return tx_rtt_recap_dict.get(state_name, "N/A")
        
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria 
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=600, tiles="cartodb positron")  
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Returned to Treatment Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_7b_rtt, columns=['State', 'TX_RTT'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_RTT', highlight=True).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                TX_RTT: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''
        
        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            tx_rtt_value = get_map_tx_rtt(loc["popup"])
            tx_rtt_formatted = format_with_thousand_separator(tx_rtt_value)            
            tx_rtt_cap_dict = get_map_tx_rtt2(loc["popup"])
            tx_rtt_recap_dict = get_map_tx_rtt3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_rtt_formatted, 
                                                tx_rtt_cap_dict, 
                                                tx_rtt_recap_dict) 
            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(marker_cluster) 
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Create ColumnDataSource from the DataFrame
        source = ColumnDataSource(data_7b_rtt)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_rtt_button_json = json_item(export_button)
        plot17_html = ng_map.get_root().render() 

        ####################### DATATABLE ######################################################################################
        plot19_html = tx_rtt_temp_tbl.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_rtt_dict,
            'achieved': achieved_tx_rtt_dict,
            'achieved_pbs': achieved_pbs_tx_rtt_dict,
            'percent_pbs': percent_pbs_tx_rtt_dict,
            'achieved_recapture': achieved_pbs_rec_tx_rtt_dict,
            'percent_recaptured': percent_pbs_rec_tx_rtt_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot7': plot7_html,
            'plot8': plot8_html,
            'plot17': {'main': plot17_html, 'additional': tx_rtt_button_json}, 
            'plot19': plot19_html

        }    


    elif (selected_indicator == 'TX_PVLS' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['IP'] == selected_ip]    
        # Number of facilities
        fac_num_tx_pvls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_pvls_dict = int(data_1['TX_PVLS (D)'].sum())        
        # TX_pvls Captured
        achieved_pbs_tx_pvls_dict = int(data_1['TX_PVLS (D) Captured'].sum())        
        # TX_pvls Coverage (%)
        pbs_pvls_percent = (achieved_pbs_tx_pvls_dict / achieved_tx_pvls_dict) * 100
        percent_pbs_tx_pvls_dict = f"{pbs_pvls_percent:.1f}"        
        # TX_pvls Recaptured
        achieved_pbs_rec_tx_pvls_dict = int(data_1['TX_PVLS (D) Recaptured'].sum())        
        # Recaptured TX_pvls Coverage (%)
        pbs_rec_tx_pvls_percent = (achieved_pbs_rec_tx_pvls_dict / achieved_pbs_tx_pvls_dict) * 100
        percent_pbs_rec_tx_pvls_dict = f"{pbs_rec_tx_pvls_percent:.1f}"     
     

        data_1b = tx_pvls_ip[tx_pvls_ip['IP'] == selected_ip] 
        source = ColumnDataSource(data_1b)
        # Create a new plot with a title and axis labels 
        plot1 = figure(x_range=FactorRange(*['CIHP']), plot_height=height, plot_width=plot_width, title="CIHP Viral Load Suppression Performance",
                    toolbar_location="right")
        # Render bars
        bars = {
            'Eligible for VL': plot1.vbar(x=dodge('IP', -0.3, range=plot1.x_range), top='Eligible for VL', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': plot1.vbar(x=dodge('IP', -0.1, range=plot1.x_range), top='TX_PVLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': plot1.vbar(x=dodge('IP', 0.1, range=plot1.x_range), top='TX_PVLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N)"),
            'Undetected VL <50': plot1.vbar(x=dodge('IP', 0.3, range=plot1.x_range), top='Undetected VL <50', width=0.18, source=source,
                                            color="#A8B9E2", legend_label="Undetected VL <50")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))
        # Add labels for bars
        plot1.text(x=dodge('IP', -0.3, range=plot1.x_range), y='Eligible for VL', text='Eligible for VL',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', -0.1, range=plot1.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', 0.1, range=plot1.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', 0.3, range=plot1.x_range), y='Undetected VL <50', text='Undetected VL <50',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression', '% Undetected']
        colors = ["Magenta", "green", "blue"]
        dodge_values = [-0.2, 0, 0.2]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '4.5pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below')   #Valid place values are: above, below, left, right or center
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")


        # Viral Load Coverage & Suppression By MMD
        data_2 = grouped_pvls[grouped_pvls['IP'] == selected_ip] 
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title="Viral Load Coverage & Suppression By MMD",
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")
             
        
        ############################################################################################
        # Clients' Viral Load Suppression By Age Band
        data_3 = tx_pvls_temp_tbl_all_age[tx_pvls_temp_tbl_all_age['IP'] == selected_ip]    
        source = ColumnDataSource(data_3)
        age_groups = source.data["AgeGroup"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title="Clients' Viral Load Suppression By Age Band",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")

        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible for VL', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             

        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        # Female Clients' Viral Load Suppression By Age Band
        data_4 = tx_pvls_temp_tbl_age_female[tx_pvls_temp_tbl_age_female['IP'] == selected_ip]    
        # Define the data source
        source = ColumnDataSource(data_4)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title="Female Clients' Viral Load Suppression By Age Band",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Female)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Female)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Female)"),
            'TX_PVLS (D, Female)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Female)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Female)"),
            'TX_PVLS (N, Female)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Female)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Female)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis        
        # Add value labels  
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Female)', text='Eligible (Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Female)', text='TX_PVLS (D, Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Female)', text='TX_PVLS (N, Female)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Female)', '% Suppression (Female)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_4)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'female tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsf_html = file_html((p, export_button), CDN, "plot10")


        # Male Clients' Viral Load Suppression By Age Band
        data_5 = tx_pvls_temp_tbl_age_male[tx_pvls_temp_tbl_age_male['IP'] == selected_ip]    
        # Define the data source
        source = ColumnDataSource(data_5)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title="Male Clients' Viral Load Suppression By Age Band",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Male)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Male)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Male)"),
            'TX_PVLS (D, Male)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Male)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Male)"),
            'TX_PVLS (N, Male)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Male)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Male)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Male)', text='Eligible (Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Male)', text='TX_PVLS (D, Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Male)', text='TX_PVLS (N, Male)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Male)', '% Suppression (Male)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))
        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_5)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'male tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsm_html = file_html((p, export_button), CDN, "plot11")


        data_6 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['IP'] == selected_ip]  
        data_6b = data_6.groupby('State')[['Eligible for VL', 'VL sample taken in 1 year', 'TX_PVLS (D)', 'TX_PVLS (N)']].sum() 
        data_6b_df=data_6b.reset_index()   

        def get_map_tx_pvls(state_name):
            # Function to get the TX_PVLS value for a given state
            tx_pvls_values = data_6b_df.groupby('State')['Eligible for VL'].sum()
            return tx_pvls_values.get(state_name, "N/A")
        
        def get_map_tx_pvls2(state_name):
            # Convert list to dictionary
            tx_pvls_cov_dict = dict(zip(data_6b_df['State'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (D)'] / data_6b_df['Eligible for VL']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_pvls_cov_dict.get(state_name, "N/A")

        def get_map_tx_pvls3(state_name):
            # Function to get the TX_PVLS value for a given state
            tx_pvls_sup_dict = dict(zip(data_6b_df['State'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (N)'] / data_6b_df['TX_PVLS (D)']) * 100, decimals=1))))
            return tx_pvls_sup_dict.get(state_name, "N/A")
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=650, tiles="cartodb positron")   
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['State', 'Eligible for VL'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.5, line_opacity=0.6, legend_name="Patients' Viral Load Suppression (PVLS)", nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''

        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            tx_pvls_values = get_map_tx_pvls(loc["popup"])
            tx_pvls_formatted = format_with_thousand_separator(tx_pvls_values)     
            tx_pvls_cov_dict = get_map_tx_pvls2(loc["popup"])
            tx_pvls_sup_dict = get_map_tx_pvls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_pvls_formatted, 
                                                tx_pvls_cov_dict, 
                                                tx_pvls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip  # Add the tooltip
            ).add_to(marker_cluster) 
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        tx_pvls_button_json = json_item(export_button)    
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        plot18_html = tx_pvls_ip3.to_html(index=False, classes=['cascade', 'table table-bordered',"display"], escape=False)
        
        plot19_html = tx_pvls_temp_tbl.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_pvls_dict,
            'achieved': achieved_tx_pvls_dict,
            'achieved_pbs': achieved_pbs_tx_pvls_dict,
            'percent_pbs': percent_pbs_tx_pvls_dict,
            'achieved_recapture': achieved_pbs_rec_tx_pvls_dict,
            'percent_recaptured': percent_pbs_rec_tx_pvls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plotvlsf_html,
            'plot11': plotvlsm_html,
            'plot17': {'main': plot17_html, 'additional': tx_pvls_button_json}, 
            'plot18': plot18_html,
            'plot19': plot19_html
        }    


    elif (selected_indicator == 'PBFW VLS' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['IP'] == selected_ip]   
        # Number of facilities
        fac_num_pbfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pbfw_vls_dict = int(data_1['PBFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pbfw_vls_dict = int(data_1['PBFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pbfw_percent = (achieved_pbs_pbfw_vls_dict / achieved_pbfw_vls_dict) * 100
        percent_pbs_pbfw_vls_dict = f"{pbs_pbfw_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pbfw_vls_dict = int(data_1['PBFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pbfw_vls_percent = (achieved_pbs_rec_pbfw_vls_dict / achieved_pbs_pbfw_vls_dict) * 100
        percent_pbs_rec_pbfw_vls_dict = f"{pbs_rec_pbfw_vls_percent:.1f}"              

        # Create IP Summary Table
        data_1b = pbfw_pvls_temp_tbl.groupby('IP', as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PBFW VLS (D)'] / data_1b['PBFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PBFW VLS (N)'] / data_1b['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)
        
        # Create a new plot with a title and axis labels 
        plot1 = figure(x_range=FactorRange(*['CIHP']), plot_height=height, plot_width=plot_width, 
                       title="CIHP Pregnant & Breastfeeding Women VLS Performance", toolbar_location="right")
        # Render bars
        bars = {
            'PBFW VL Eligible': plot1.vbar(x=dodge('IP', -0.3, range=plot1.x_range), top='PBFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': plot1.vbar(x=dodge('IP', -0.1, range=plot1.x_range), top='PBFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': plot1.vbar(x=dodge('IP', 0.1, range=plot1.x_range), top='PBFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('IP', -0.3, range=plot1.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', -0.1, range=plot1.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', 0.1, range=plot1.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'IP' and 'mmd'
        data_2 = df_pbfw_list.groupby(['IP', 'mmd'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PBFW VLS (D)'] / data_2['PBFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PBFW VLS (N)'] / data_2['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title="Pregnant & Breastfeeding Women VLS By MMD",
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PBFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pbfw_vls_temp_tbl_age = df_pbfw_list.groupby(['IP', 'AgeGroup'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        pbfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (D)'] / pbfw_vls_temp_tbl_age['PBFW VL Eligible']) * 100, decimals=1)
        pbfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (N)'] / pbfw_vls_temp_tbl_age['PBFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pbfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)

        source = ColumnDataSource(data_3)
        age_groups = source.data["AgeGroup"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title="Pregnant & Breastfeeding Women VLS By Age Band",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PBFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PBFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PBFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        data_6 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['IP'] == selected_ip]  
        data_6b = data_6.groupby('State')[['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pbfw_vls(state_name):
            # Function to get the pbfw_vls value for a given state
            pbfw_vls_values = data_6b.groupby('State')['PBFW VL Eligible'].sum()
            return pbfw_vls_values.get(state_name, "N/A")
        
        def get_map_pbfw_vls2(state_name):
            # Convert list to dictionary
            pbfw_vls_cov_dict = dict(zip(data_6b['State'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (D)'] / data_6b['PBFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pbfw_vls_cov_dict.get(state_name, "N/A")

        def get_map_pbfw_vls3(state_name):
            # Function to get the pbfw_vls value for a given state
            pbfw_vls_sup_dict = dict(zip(data_6b['State'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (N)'] / data_6b['PBFW VLS (D)']) * 100, decimals=1))))
            return pbfw_vls_sup_dict.get(state_name, "N/A")
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=650, tiles="cartodb positron")   
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Pregnant & Breastfeeding Women Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['State', 'PBFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant & Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''

        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            pbfw_vls_values = get_map_pbfw_vls(loc["popup"])
            pbfw_vls_formatted = format_with_thousand_separator(pbfw_vls_values)     
            pbfw_vls_cov_dict = get_map_pbfw_vls2(loc["popup"])
            pbfw_vls_sup_dict = get_map_pbfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pbfw_vls_formatted, 
                                                pbfw_vls_cov_dict, 
                                                pbfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(marker_cluster) 

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pbfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        plot19_html = pbfw_pvls_temp_tbl.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pbfw_vls_dict,
            'achieved': achieved_pbfw_vls_dict,
            'achieved_pbs': achieved_pbs_pbfw_vls_dict,
            'percent_pbs': percent_pbs_pbfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pbfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pbfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot17': {'main': plot17_html, 'additional': pbfw_vls_button_json}, 
            'plot19': plot19_html

        } 


    elif (selected_indicator == 'PW VLS' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['IP'] == selected_ip]    
        # Number of facilities
        fac_num_pw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pw_vls_dict = int(data_1['PW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pw_vls_dict = int(data_1['PW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pw_percent = (achieved_pbs_pw_vls_dict / achieved_pw_vls_dict) * 100
        percent_pbs_pw_vls_dict = f"{pbs_pw_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pw_vls_dict = int(data_1['PW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pw_vls_percent = (achieved_pbs_rec_pw_vls_dict / achieved_pbs_pw_vls_dict) * 100
        percent_pbs_rec_pw_vls_dict = f"{pbs_rec_pw_vls_percent:.1f}"     

 
        # Create IP Summary Table
        data_1b = pw_pvls_temp_tbl.groupby('IP', as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PW VLS (D)'] / data_1b['PW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PW VLS (N)'] / data_1b['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 700
        plot1 = figure(x_range=FactorRange(*['CIHP']), plot_height=height, plot_width=plot_width, title="CIHP Pregnant Women VLS Performance",
                    toolbar_location="right")
        # Render bars
        bars = {
            'PW VL Eligible': plot1.vbar(x=dodge('IP', -0.3, range=plot1.x_range), top='PW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': plot1.vbar(x=dodge('IP', -0.1, range=plot1.x_range), top='PW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': plot1.vbar(x=dodge('IP', 0.1, range=plot1.x_range), top='PW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('IP', -0.3, range=plot1.x_range), y='PW VL Eligible', text='PW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', -0.1, range=plot1.x_range), y='PW VLS (D)', text='PW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', 0.1, range=plot1.x_range), y='PW VLS (N)', text='PW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below')  
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'IP' and 'mmd' 
        data_2 = df_pbfw_list.groupby(['IP', 'mmd'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PW VLS (D)'] / data_2['PW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PW VLS (N)'] / data_2['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title="Pregnant Women VLS By MMD",
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pw_vls_temp_tbl_age = df_pbfw_list.groupby(['IP', 'AgeGroup'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        pw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pw_vls_temp_tbl_age['PW VLS (D)'] / pw_vls_temp_tbl_age['PW VL Eligible']) * 100, decimals=1)
        pw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pw_vls_temp_tbl_age['PW VLS (N)'] / pw_vls_temp_tbl_age['PW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)

        source = ColumnDataSource(data_3)
        age_groups = source.data["AgeGroup"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title="Pregnant Women VLS By Age Band",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis
        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        data_6 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['IP'] == selected_ip]  
        data_6b = data_6.groupby('State')[['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pw_vls(state_name):
            # Function to get the pw_vls value for a given state
            pw_vls_values = data_6b.groupby('State')['PW VL Eligible'].sum()
            return pw_vls_values.get(state_name, "N/A")
        
        def get_map_pw_vls2(state_name):
            # Convert list to dictionary
            pw_vls_cov_dict = dict(zip(data_6b['State'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (D)'] / data_6b['PW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pw_vls_cov_dict.get(state_name, "N/A")

        def get_map_pw_vls3(state_name):
            # Function to get the pw_vls value for a given state
            pw_vls_sup_dict = dict(zip(data_6b['State'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (N)'] / data_6b['PW VLS (D)']) * 100, decimals=1))))
            return pw_vls_sup_dict.get(state_name, "N/A")
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=650, tiles="cartodb positron")   
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Pregnant Women Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['State', 'PW VL Eligible'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''

        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            pw_vls_values = get_map_pw_vls(loc["popup"])
            pw_vls_formatted = format_with_thousand_separator(pw_vls_values)     
            pw_vls_cov_dict = get_map_pw_vls2(loc["popup"])
            pw_vls_sup_dict = get_map_pw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pw_vls_formatted, 
                                                pw_vls_cov_dict, 
                                                pw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(marker_cluster) 

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)                
        pw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        plot19_html = pw_pvls_temp_tbl.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pw_vls_dict,
            'achieved': achieved_pw_vls_dict,
            'achieved_pbs': achieved_pbs_pw_vls_dict,
            'percent_pbs': percent_pbs_pw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot17': {'main': plot17_html, 'additional': pw_vls_button_json}, 
            'plot19': plot19_html
        } 

    
    elif (selected_indicator == 'BFW VLS' and selected_ip == 'CIHP' ):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['IP'] == selected_ip]    
        # Number of facilities
        fac_num_bfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_bfw_vls_dict = int(data_1['BFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_bfw_vls_dict = int(data_1['BFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_bfw_percent = (achieved_pbs_bfw_vls_dict / achieved_bfw_vls_dict) * 100
        percent_pbs_bfw_vls_dict = f"{pbs_bfw_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_bfw_vls_dict = int(data_1['BFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_bfw_vls_percent = (achieved_pbs_rec_bfw_vls_dict / achieved_pbs_bfw_vls_dict) * 100
        percent_pbs_rec_bfw_vls_dict = f"{pbs_rec_bfw_vls_percent:.1f}"     
 
        # Create IP Summary Table
        data_1b = bfw_pvls_temp_tbl.groupby('IP', as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['BFW VLS (D)'] / data_1b['BFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['BFW VLS (N)'] / data_1b['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 700
        plot1 = figure(x_range=FactorRange(*['CIHP']), plot_height=height, plot_width=plot_width, 
                       title="CIHP Breastfeeding Women VLS Performance", toolbar_location="right")
        # Render bars
        bars = {
            'BFW VL Eligible': plot1.vbar(x=dodge('IP', -0.3, range=plot1.x_range), top='BFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': plot1.vbar(x=dodge('IP', -0.1, range=plot1.x_range), top='BFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': plot1.vbar(x=dodge('IP', 0.1, range=plot1.x_range), top='BFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('IP', -0.3, range=plot1.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', -0.1, range=plot1.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('IP', 0.1, range=plot1.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]
        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('IP', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        plot1.toolbar.autohide = True
        plot1.legend.label_text_font_size = '7.5pt'
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'IP' and 'mmd'
        data_2 = df_pbfw_list.groupby(['IP', 'mmd'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()       
        data_2['% Coverage'] = np.round((data_2['BFW VLS (D)'] / data_2['BFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['BFW VLS (N)'] / data_2['BFW VLS (D)']) * 100, decimals=1) 
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title="Breastfeeding Women VLS By MMD",
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7.5pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # BFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        bfw_vls_temp_tbl_age = df_pbfw_list.groupby(['IP', 'AgeGroup'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        bfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (D)'] / bfw_vls_temp_tbl_age['BFW VL Eligible']) * 100, decimals=1)
        bfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (N)'] / bfw_vls_temp_tbl_age['BFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = bfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)

        source = ColumnDataSource(data_3)
        age_groups = source.data["AgeGroup"]
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title="Breastfeeding Women VLS By Age Band",
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='BFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='BFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='BFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis
        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"           
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        data_6 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['IP'] == selected_ip]  
        data_6b = data_6.groupby('State')[['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_bfw_vls(state_name):
            # Function to get the bfw_vls value for a given state
            bfw_vls_values = data_6b.groupby('State')['BFW VL Eligible'].sum()
            return bfw_vls_values.get(state_name, "N/A")
        
        def get_map_bfw_vls2(state_name):
            # Convert list to dictionary
            bfw_vls_cov_dict = dict(zip(data_6b['State'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (D)'] / data_6b['BFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return bfw_vls_cov_dict.get(state_name, "N/A")

        def get_map_bfw_vls3(state_name):
            # Function to get the bfw_vls value for a given state
            bfw_vls_sup_dict = dict(zip(data_6b['State'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (N)'] / data_6b['BFW VLS (D)']) * 100, decimals=1))))
            return bfw_vls_sup_dict.get(state_name, "N/A")
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"  
        geo_data = json.load(open(geo_json_path))
        # Initialize the Folium map to be centered around Nigeria
        ng_map = folium.Map(location=[9.0820, 8.6753], zoom_start=6, height=450, width=650, tiles="cartodb positron")   
        # Add title to the map
        title_html = '<p style="text-align:center; color: #333; font-weight: bold;">Breastfeeding Women Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['State', 'BFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='YlOrBr', fill_opacity=0.5, line_opacity=0.6, legend_name='Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''

        marker_cluster = MarkerCluster().add_to(ng_map)
        # Add popup and tooltip for each state
        for loc in locations_ip:
            bfw_vls_values = get_map_bfw_vls(loc["popup"])
            bfw_vls_formatted = format_with_thousand_separator(bfw_vls_values)     
            bfw_vls_cov_dict = get_map_bfw_vls2(loc["popup"])
            bfw_vls_sup_dict = get_map_bfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                bfw_vls_formatted, 
                                                bfw_vls_cov_dict, 
                                                bfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(marker_cluster) 

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        bfw_vls_button_json = json_item(export_button)        
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        plot19_html = bfw_pvls_temp_tbl.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_bfw_vls_dict,
            'achieved': achieved_bfw_vls_dict,
            'achieved_pbs': achieved_pbs_bfw_vls_dict,
            'percent_pbs': percent_pbs_bfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_bfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_bfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot17': {'main': plot17_html, 'additional': bfw_vls_button_json}, 
            'plot19': plot19_html
        } 


    ########################## States ###################### States ###################### States ########################
    ########################## States ###################### States ###################### States ########################
    elif selected_indicator == 'TX_CURR' and selected_states:
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment current indicator     
        data_1 = tx_curr_temp_tbl[tx_curr_temp_tbl['State'].isin(selected_states)]  
        # Number of facilities
        fac_num_curr_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_curr_dict = int(data_1['TX_CURR'].sum())        
        # Biometrics Captured
        achieved_pbs_curr_dict = int(data_1['Biometrics Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_curr_percent = (achieved_pbs_curr_dict / achieved_tx_curr_dict) * 100
        percent_pbs_curr_dict = f"{pbs_curr_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_curr_dict = int(data_1['Biometrics Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_curr_percent = (achieved_pbs_rec_tx_curr_dict / achieved_pbs_curr_dict) * 100
        percent_pbs_rec_tx_curr_dict = f"{pbs_rec_tx_curr_percent:.1f}"   
        ############################################################################################
        # Handle data elements from the line list table        
        # Treatment Current By Pediatric & Adult Clients & Sex above 
        data_4 = df_curr_list[df_curr_list['State'].isin(selected_states)]
        longfm1_state_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_curr_widefm2_state_age_sex = longfm1_state_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='CurrentARTStatus_28Days')

        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By Pediatric & Adult Clients & Sex'

        plot1=tx_curr_widefm2_state_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                            fontsize={'xticks': 10, 'yticks': 10, 'title': 10},  width=plot_width, height=height, 
                                            title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_CURR', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the current document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_curr_widefm2_state_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr peed&adult age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)
        
                                       
        # Treatment Current Distribution By Sex 
        data_5 = df_curr_list[df_curr_list['State'].isin(selected_states)]        
        data_5agg = data_5.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b['color'] = ["#2b9eb0", "#9ecae1"]         
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By Sex'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")

       
        # Treatment Current By AgeGroup & Sex   
        data_2 = df_curr_list[df_curr_list['State'].isin(selected_states)]     
        age_group_tx_curr = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_curr = age_group_tx_curr.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_curr)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By 5-Year Age Band & Sex'
        plot3 = age_group_tx_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.toolbar.logo = None
        plot3.x_range.start = 0        
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_curr)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment Current By Age Group & Sex
        # Filter the data
        data_3 = df_pbs_list[df_pbs_list['State'].isin(selected_states)]
        # Create crosstab
        age_group_pbs_curr = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_curr = age_group_pbs_curr.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_curr)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current Biometrics By 5-Year Age Band & Sex'
        # Plot 
        plot4 = age_group_pbs_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0       
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_curr 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")
             

        # Treatment Current MMD Distribution
        data_5 = df_curr_list[df_curr_list['State'].isin(selected_states)]        
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()        
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b["value"] = data_5b['value'].astype(str)
        data_5b["value"] = data_5b["value"].str.pad(35, side="left")
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By Multi-Month Dispensing (MMD)'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@mmd: @formatted_value, Percentage: @percentage{0.0}%",x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, inner_radius=0.20, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='mmd', source=source)
      
        # Callouts for labels
        callouts = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-25, source=source, render_mode='canvas',
                            text_align="center", angle=0, text_font_size='10pt', text_color='#000000')
        chart.add_layout(callouts)
        percentage_callouts = LabelSet(x="cos2", y="sin2", y_offset=-25, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')
        chart.add_layout(percentage_callouts)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None   
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((chart, export_button), CDN, "plot5")


        # Treatment Current By MMD & 5-Year Age Band
        data_7 = df_curr_list[df_curr_list['State'].isin(selected_states)]     
        # Perform crosstab to get counts by AgeGroup and MMD
        tx_curr_age_mmd = pd.crosstab(data_7['AgeGroup'], data_7['mmd']).reset_index()
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(tx_curr_age_mmd)
        # List of MMD factors
        mmd_factors = tx_curr_age_mmd.columns[1:]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By MMD & 5-Year Age Band'
        # Create the Bokeh figure for stacked column chart
        plot = figure(x_range=tx_curr_age_mmd['AgeGroup'], 
                    title=plot_title, x_axis_label="", y_axis_label="Number of clients", 
                    height=height, plot_width=plot_width,  # Set the plot width
                    toolbar_location='right', tools=[CrosshairTool(), PanTool(), BoxZoomTool(), SaveTool(), ResetTool()])

        # Add a HoverTool to display details on hover
        hover = HoverTool(tooltips=[("Age Band", "@AgeGroup"), ("MMD", "$name"), ("TX_CURR", "@$name{0,0}")])
        plot.add_tools(hover)
        # Add stacked columns to the figure
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))       
        # Get the closest supported size for the Spectral palette
        num_colors = len(mmd_factors)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        colors = color_palette[:len(data_7)]  
        # colors = ["#2b9eb0", '#2beaea', '#2b9eea', "#9ecae1"]
        plot.vbar_stack(stackers=mmd_factors, x='AgeGroup', width=0.8, color=colors, 
                        source=source, legend_label=[str(mmd) for mmd in mmd_factors])
        # Customize plot
        plot.xaxis.major_label_orientation = 1.2
        plot.toolbar.logo = None
        plot.y_range.start = 0 
        # Format y-axis with thousand separators
        plot.yaxis.formatter = NumeralTickFormatter(format="0,0")
        # Add legend click policy
        plot.legend.click_policy = "hide"
        plot.toolbar.autohide = True
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD & 5yr age.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label="Export CSV", button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot, export_button), CDN, "plot6")


        # Treatment Current Distribution By LGA
        data_8 = tx_curr_temp_tbl[tx_curr_temp_tbl['State'].isin(selected_states)] 
        data_8agg = data_8.groupby('LGA')[['TX_CURR']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_CURR']]   
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By LGA'     
        plot9=data_8_sum.hvplot.bar(x="LGA", y='TX_CURR', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_CURR")                                

        labels = hv.Labels(data=data_8_sum, kdims=['LGA', 'TX_CURR'], vdims='formatted_value').opts(text_font_size='9pt')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("Local Government", "@LGA"), ("TX_CURR", "@TX_CURR{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by lga.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((bokeh_model, export_button), CDN, "plot9")   


        # Treatment Current Distribution By SurgeCommand
        data_9 = tx_curr_temp_tbl[tx_curr_temp_tbl['State'].isin(selected_states)] 
        data_9agg = data_9.groupby('SurgeCommand')[['TX_CURR']].sum().reset_index()    
        data_9_sum = data_9agg.copy()
        data_9_sum['formatted_value']=data_9_sum['TX_CURR'].apply(lambda x: "{:,.0f}".format(x))  
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Current By Command'      
        plot10=data_9_sum.hvplot.bar(x="SurgeCommand", y='TX_CURR', height=height, color='#6ED40E', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_CURR")                                

        labels = hv.Labels(data=data_9_sum, kdims=['SurgeCommand', 'TX_CURR'], vdims='formatted_value').opts(text_font_size='9pt')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot10 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("Command", "@SurgeCommand"), ("TX_CURR", "@TX_CURR{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_9agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((bokeh_model, export_button), CDN, "plot10") 


        # Treatment Current Map
        data_6 = tx_curr_temp_tbl[tx_curr_temp_tbl['State'].isin(selected_states)]  
        data_6b = data_6.groupby('LGA')[['TX_CURR','Biometrics Captured', 'Biometrics Recaptured']].sum()   
        data_6b_curr=data_6b.reset_index()  

        def get_map_tx_curr(lga_name):
            # Function to get the TX_CURR value for a given state
            tx_curr_values = tx_curr_temp_tbl.groupby('LGA')['TX_CURR'].sum()
            return tx_curr_values.get(lga_name, "N/A")
                    
        def get_map_tx_curr2(lga_name):
            # Convert list to dictionary
            tx_curr_cap_dict = dict(zip(data_6b_curr['LGA'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Captured'] / data_6b_curr['TX_CURR']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_curr_cap_dict.get(lga_name, "N/A")

        def get_map_tx_curr3(lga_name):
            # Function to get the TX_PVLS value for a given state
            tx_curr_recap_dict = dict(zip(data_6b_curr['LGA'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Recaptured'] / data_6b_curr['Biometrics Captured']) * 100, decimals=1))))
            return tx_curr_recap_dict.get(lga_name, "N/A")
        
        # Load GeoJSON file with Nigeria's state boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected states
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)        
                    
        # Get the coordinates for the first selected state
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Treatment Current Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))

        folium.Choropleth(
            geo_data=filtered_geo_data, name='choropleth', data=data_6b_curr, columns=['LGA', 'TX_CURR'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_CURR', highlight=True).add_to(ng_map)

        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_CURR: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''        
        # Define a function to get locations for the selected states
        def get_locations_for_states(selected_states):            
            locations = []
            for state in selected_states:
                lgas_in_state = tx_curr_temp_tbl[tx_curr_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations
        
        locations = get_locations_for_states(selected_states)
        
        for loc in locations:
            tx_curr_value = get_map_tx_curr(loc["popup"])
            tx_curr_formatted = format_with_thousand_separator(tx_curr_value)            
            tx_curr_cap_dict = get_map_tx_curr2(loc["popup"])
            tx_curr_recap_dict = get_map_tx_curr3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_curr_formatted, 
                                                tx_curr_cap_dict, 
                                                tx_curr_recap_dict) 
            
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_curr)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_curr_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()      

        ####################### DATATABLE ######################################################################################        
        plot19_html = data_1.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_curr_dict,
            'achieved': achieved_tx_curr_dict,
            'achieved_pbs': achieved_pbs_curr_dict,
            'percent_pbs': percent_pbs_curr_dict,
            'achieved_recapture': achieved_pbs_rec_tx_curr_dict,
            'percent_recaptured': percent_pbs_rec_tx_curr_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': tx_curr_button_json}, 
            'plot19': plot19_html
        }   


    elif (selected_indicator == 'TX_NEW' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_new_temp_tbl[tx_new_temp_tbl['State'].isin(selected_states)]
        # Number of facilities
        fac_num_tx_new_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_new_dict = int(data_1['TX_NEW'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_new_dict = int(data_1['TX_NEW Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_new_percent = (achieved_pbs_tx_new_dict / achieved_tx_new_dict) * 100
        percent_pbs_tx_new_dict = f"{pbs_new_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_new_dict = int(data_1['TX_NEW Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_new_percent = (achieved_pbs_rec_tx_new_dict / achieved_pbs_tx_new_dict) * 100
        percent_pbs_rec_tx_new_dict = f"{pbs_rec_tx_new_percent:.1f}"            
        ############################################################################################
        # Handle data elements from the line list table
        data_2 = df_new_list[df_new_list['State'].isin(selected_states)]        
        # Treatment New By Pediatric & Adult Clients & Sex
        data_4 = df_new_list[df_new_list['State'].isin(selected_states)]
        longfm1_state_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_new_widefm2_state_age_sex = longfm1_state_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_NEW')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New By Pediatric & Adult Clients & Sex' 
        plot1=tx_new_widefm2_state_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_NEW', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the New document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_new_widefm2_state_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment New CD4 Distribution
        data_5 = df_cd4_new_list[df_cd4_new_list['State'].isin(selected_states)]        
        data_5agg = data_5.TX_NEW_CD4.value_counts().reset_index().rename(columns={'index':'TX_NEW_CD4', 'TX_NEW_CD4':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        value = data_5b["value"].values
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]        
        data_5b['color'] = ["#2b9eb0", '#2b9eea', "#9ecae1"]     
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b) 
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New By CD4 Count' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW_CD4: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW_CD4', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
                        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")

        
        # Treatment New By AgeGroup & Sex
        age_group_tx_new = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_new = age_group_tx_new.set_index('AgeGroup')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New By 5-Year Age Band & Sex' 
        plot3 = age_group_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.x_range.start = 0
        plot3.toolbar.logo = None   
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment New By Age Group & Sex
        data_3 = df_pbs_new_list[df_pbs_new_list['State'].isin(selected_states)]
        age_group_pbs_tx_new = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_tx_new = age_group_pbs_tx_new.set_index('AgeGroup')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New Biometrics By 5-Year Age Band & Sex' 
        plot4 = age_group_pbs_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None   
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_pbs_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new pbs by age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")               


        # TX_NEW By Month 
        data_8 = df_new_list[df_new_list['State'].isin(selected_states)]
        data_8agg = data_8.TX_NEW_month.value_counts().reset_index().rename(columns={'index':'TX_NEW_month', 'TX_NEW_month':'value'})
        data_8_count = data_8agg.copy()
        data_8_count['formatted_value']=["{:,.0f}".format(val) for val in data_8_count['value']]    
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} TX_NEW By Month'     
        plot5new_days=data_8_count.hvplot.bar(x="TX_NEW_month", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='',  width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW_month")                                

        labels = hv.Labels(data=data_8_count, kdims=['TX_NEW_month', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by month.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotnew_month_html = file_html((bokeh_model, export_button), CDN, "plot5")


        # Treatment New in Month 1 By AgeGroup & Sex
        data_9 = df_new_listmth1[df_new_listmth1['State'].isin(selected_states)]
        age_sex_tx_new_month1 = pd.crosstab(data_9['AgeGroup'], data_9['Sex']).reset_index()
        age_sex_tx_new_month1 = age_sex_tx_new_month1.set_index('AgeGroup')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New In Month 1 By 5-Year Age Band & Sex'  
        if not age_sex_tx_new_month1.empty:
            plot6 = age_sex_tx_new_month1.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
            # Set the width and height of the plot
            plot6.plot.width = plot_width
            # Adjusting toolbar size
            plot6.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot6.x_range.start = 0
            plot6.toolbar.logo = None    
            plot6.toolbar.active_scroll = None
            plot6.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month1)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 1 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot6_html = file_html((plot6, export_button), CDN, "plot6")
        else:
            # Handle the empty data case
            plot6_html = "No data available to plot."        


        # Treatment New in Month 2 By AgeGroup & Sex
        data_10 = df_new_listmth2[df_new_listmth2['State'].isin(selected_states)]
        age_sex_tx_new_month2 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month2 = age_sex_tx_new_month2.set_index('AgeGroup')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New In Month 2 By 5-Year Age Band & Sex'           
        if not age_sex_tx_new_month2.empty:
            plot9 = age_sex_tx_new_month2.plot_bokeh.bar(title=plot_title, legend = "top_right",line_width=8.0, show_figure=False) 
            # Set the width and height of the plot
            plot9.plot.width = 800
            # Adjusting toolbar size
            plot9.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot9.y_range.start = 0
            plot9.toolbar.logo = None    
            plot9.toolbar.active_scroll = None
            plot9.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month2)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 2 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot9_html = file_html((plot9, export_button), CDN, "plot9")
        else:
            # Handle the empty data case
            plot9_html = "No data available to plot."     
        

        # Treatment New in Month 3 By AgeGroup & Sex
        data_10 = df_new_listmth3[df_new_listmth3['State'].isin(selected_states)]
        age_sex_tx_new_month3 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month3 = age_sex_tx_new_month3.set_index('AgeGroup')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New In Month 3 By 5-Year Age Band & Sex'  
        if not age_sex_tx_new_month3.empty:
            plot10 = age_sex_tx_new_month3.plot_bokeh.bar(title=plot_title, legend="top_right", line_width=8.0, show_figure=False)
            # Set the width and height of the plot
            plot10.plot.width = 800
            # Adjusting toolbar size
            plot10.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot10.y_range.start = 0
            plot10.toolbar.logo = None   
            plot10.toolbar.active_scroll = None
            plot10.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month3)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 3 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot10_html = file_html((plot10, export_button), CDN, "plot10")
        else:
            # Handle the empty data case
            plot10_html = "No data available to plot."                    
        
                                       
        # Treatment New ML Distribution
        data_7 = df_ml_new_list[df_ml_new_list['State'].isin(selected_states)]        
        data_7agg = data_7['TX_NEW ML'].value_counts().reset_index().rename(columns={'index':'TX_NEW ML', 'TX_NEW ML':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.28
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.28
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]    
        # Pad the 'value' column with spaces to improve label alignment
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(state_names, total_count)
        # Creating chart vertical
        chart = figure(height=height, width=620, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW ML: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW ML', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-9, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-9, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None        
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new ml.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot11_html = file_html((chart, export_button), CDN, "plot11")     


        # Treatment New Distribution By LGA
        data_11 = tx_new_temp_tbl[tx_new_temp_tbl['State'].isin(selected_states)] 
        data_11agg = data_11.groupby('LGA')[['TX_NEW']].sum().reset_index()    
        data_11_sum = data_11agg.copy()
        data_11_sum['formatted_value']=["{:,.0f}".format(val) for val in data_11_sum['TX_NEW']]   
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New By LGA'      
        plot9=data_11_sum.hvplot.bar(x="LGA", y='TX_NEW', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW")                                

        labels = hv.Labels(data=data_11_sum, kdims=['LGA', 'TX_NEW'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("Local Government", "@LGA"), ("TX_NEW", "@TX_NEW{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_11agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by lga.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html = file_html((bokeh_model, export_button), CDN, "plot12")   


        # Treatment New Distribution By SurgeCommand
        data_12 = tx_new_temp_tbl[tx_new_temp_tbl['State'].isin(selected_states)] 
        data_12agg = data_12.groupby('SurgeCommand')[['TX_NEW']].sum().reset_index()    
        data_12_sum = data_12agg.copy()
        data_12_sum['formatted_value']=data_12_sum['TX_NEW'].apply(lambda x: "{:,.0f}".format(x))   
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment New By Command'    
        plot10=data_12_sum.hvplot.bar(x="SurgeCommand", y='TX_NEW', height=height, color='#6ED40E', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW")                                

        labels = hv.Labels(data=data_12_sum, kdims=['SurgeCommand', 'TX_NEW'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot10 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("SurgeCommand", "@SurgeCommand"), ("TX_NEW", "@TX_NEW{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_12agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot13_html = file_html((bokeh_model, export_button), CDN, "plot13") 


        data_6 = tx_new_temp_tbl[tx_new_temp_tbl['State'].isin(selected_states)]   
        data_6b = data_6.groupby('LGA')['TX_NEW', 'TX_NEW month 1','TX_NEW month 2', 'TX_NEW month 3'].sum()   
        data_6b_new=data_6b.reset_index() 

        def get_map_tx_new(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_values = data_6b_new.groupby('LGA')['TX_NEW'].sum()
            return tx_new_values.get(lga_name, "N/A")
        
        def get_map_tx_new_month_1(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_month_1 = data_6b_new.groupby('LGA')['TX_NEW month 1'].sum()
            return tx_new_month_1.get(lga_name, "N/A")
        
        def get_map_tx_new_month_2(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_month_2 = data_6b_new.groupby('LGA')['TX_NEW month 2'].sum()
            return tx_new_month_2.get(lga_name, "N/A")
        
        def get_map_tx_new_month_3(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_month_3 = data_6b_new.groupby('LGA')['TX_NEW month 3'].sum()
            return tx_new_month_3.get(lga_name, "N/A")

        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)        
                    
        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Treatment New Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_new, columns=['LGA', 'TX_NEW'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_NEW', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_NEW: {}<br>
                Month 1: {}<br>
                Month 2: {}<br>
                Month 3: {}
            </div>
        '''

        # Define a function to get locations for the selected LGAs
        def get_locations_for_LGAs(selected_states):            
            locations = []
            for state in selected_states:
                lgas_in_state = tx_new_temp_tbl[tx_new_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations
        
        locations = get_locations_for_LGAs(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_new_value = get_map_tx_new(loc["popup"])
            tx_new_formatted = format_with_thousand_separator(tx_new_value)  
            tx_new_month_1 = get_map_tx_new_month_1(loc["popup"])
            tx_new_mth_1_formatted = format_with_thousand_separator(tx_new_month_1) 

            tx_new_month_2 = get_map_tx_new_month_2(loc["popup"])
            tx_new_mth_2_formatted = format_with_thousand_separator(tx_new_month_2) 

            tx_new_month_3 = get_map_tx_new_month_3(loc["popup"])
            tx_new_mth_3_formatted = format_with_thousand_separator(tx_new_month_3)             
            
            popup_content = popup_style.format(loc["popup"], tx_new_formatted, tx_new_mth_1_formatted,
                                               tx_new_mth_2_formatted, tx_new_mth_3_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_new)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_new_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()
        

        ####################### DATATABLE ######################################################################################
        plot19_html = data_1.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)
  
        data_response = {
            'fac_num': fac_num_tx_new_dict,
            'achieved': achieved_tx_new_dict,
            'achieved_pbs': achieved_pbs_tx_new_dict,
            'percent_pbs': percent_pbs_tx_new_dict,
            'achieved_recapture': achieved_pbs_rec_tx_new_dict,
            'percent_recaptured': percent_pbs_rec_tx_new_dict,
            'plot1': {'main': plot1_html, 'additional': button_json}, 
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plotnew_month_html,
            'plot6': plot6_html, 
            'plot9': plot9_html,  
            'plot10': plot10_html, 
            'plot11': plot11_html,        
            'plot12': plot12_html, 
            'plot13': plot13_html,    
            'plot17': {'main': plot17_html, 'additional': tx_new_button_json}, 
            'plot19': plot19_html
        }       


    elif (selected_indicator == 'TX_ML' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment ml indicator
        data_1 = tx_ml_df[tx_ml_df['State'].isin(selected_states)]
        # Number of facilities
        fac_num_tx_ml_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_ml_dict = int(data_1['TX_ML'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_ml_dict = int(data_1['TX_ML Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_ml_percent = (achieved_pbs_tx_ml_dict / achieved_tx_ml_dict) * 100
        percent_pbs_tx_ml_dict = f"{pbs_ml_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_ml_dict = int(data_1['TX_ML Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_ml_percent = (achieved_pbs_rec_tx_ml_dict / achieved_pbs_tx_ml_dict) * 100
        percent_pbs_rec_tx_ml_dict = f"{pbs_rec_tx_ml_percent:.1f}"     
        #################################################################################################
        # Treatment Mortality & Loss By Pediatric & Adult Clients & Sex
        data_4 = df_ml_list[df_ml_list['State'].isin(selected_states)]
        longfm1_state_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_ml_widefm2_state_age_sex = longfm1_state_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_ML')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Mortality & Loss By Pediatric & Adult Clients & Sex' 
        plot1ml=tx_ml_widefm2_state_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title=plot_title).opts(
                                        hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model
        bokeh_model = hv.render(plot1ml, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_ML', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_ml_widefm2_state_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)      
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment Mortality & Loss Outcomes
        data_5 = df_ml_2_list[df_ml_2_list['State'].isin(selected_states)]        
        data_5agg = data_5.TX_ML_Outcome_2.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome_2', 'TX_ML_Outcome_2':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)] 
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        # Format the 'value' column with thousand separators
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        # Pad the 'value' column with spaces to improve label alignment
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Treatment Mortality & Loss Outcomes' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,box_zoom,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome_2: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome_2', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-15, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-15, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml outcomes.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")        

        
        # Interrution in Treatment By Age Group & Sex 
        data_4b = df_ml_iit_list[df_ml_iit_list['State'].isin(selected_states)]
        age_group_iit = pd.crosstab(data_4b['AgeGroup'], data_4b['Sex']).reset_index()
        age_group_iit = age_group_iit.set_index('AgeGroup')
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} IIT By 5-Year Age Band & Sex' 
        plot4 = age_group_iit.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None  
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_iit)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT By 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")


        # Interrution in Treatment in Days 
        data_4c = df_ml_iit_days_list[df_ml_iit_days_list['State'].isin(selected_states)]
        data_4agg = data_4c.IIT_duration_days.value_counts().reset_index().rename(columns={'index':'IIT_duration_days', 'IIT_duration_days':'value'})
        data_4c_count = data_4agg.copy()
        # Define the custom order
        custom_order = ['IIT for â‰¤30 days', 'IIT for 31 to 60 days', 'IIT for 61 to 180 days', 'IIT for >180 days']
        # Convert the IIT_duration_days column to a categorical type with the custom order
        data_4c_count['IIT_duration_days'] = pd.Categorical(data_4c_count['IIT_duration_days'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order   
        data_4c_count = data_4c_count.sort_values('IIT_duration_days')         
        data_4c_count['formatted_value']=["{:,.0f}".format(val) for val in data_4c_count['value']]  
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} IIT Duration (Days)'       
        plot1iit_days=data_4c_count.hvplot.bar(x="IIT_duration_days", y='value', height=height, color='#6d99ff', grid=True, rot=30, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')                             
        
        labels = hv.Labels(data=data_4c_count, kdims=['IIT_duration_days', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_iit = plot1iit_days * labels
        bokeh_model = hv.render(plot_iit, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(data_4agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT duration in days.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotiit_days_html = file_html((bokeh_model, export_button), CDN, "plot4")

   
        # State level IIT Rate
        tx_ml_df_state = tx_ml_df[tx_ml_df['State'].isin(selected_states)]
        tx_ml_df_state = tx_ml_df_state.groupby('State', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_state['IIT Rate (%)'] = np.round((tx_ml_df_state['IIT'] / tx_ml_df_state['TX_CURR']) * 100, decimals=1)
        data_7 = tx_ml_df_state.copy()
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} IIT Rate'   
        # Create a new plot with a title and axis labels 700
        p = figure(x_range=FactorRange(*source.data['State']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="above")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('State', -0.3, range=p.x_range), top='TX_CURR', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('State', -0.1, range=p.x_range), top='IIT', width=0.18, source=source,
                                    color="#71aebf", legend_label="IIT")}        
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))
        # Add labels for bars
        p.text(x=dodge('State', -0.3, range=p.x_range), y='TX_CURR', text='TX_CURR',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('State', -0.1, range=p.x_range), y='IIT', text='IIT',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.2]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('State', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('State', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        # Format y-axis labels with thousands separators
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 
        # Hide the toolbar
        p.toolbar.autohide = True
        # Adjusting legend label size
        p.legend.label_text_font_size = '10pt'
        # Position the legend outside the plot area 
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        p.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'overall IIT rate.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((p, export_button), CDN, "plot5")


        data_8 = tx_ml_df_state_mmd[tx_ml_df_state_mmd['State'].isin(selected_states)]    
        # Define the data source
        source = ColumnDataSource(data_8)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} % IIT By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('mmd', -0.2, range=p.x_range), top='TX_CURR', width=0.2, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('mmd', 0.1, range=p.x_range), top='IIT', width=0.2, source=source,
                color="#71aebf", legend_label="IIT")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('mmd', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('mmd', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.legend.label_text_font_size = '10pt'
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        p.toolbar.logo = None
        p.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_8)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((p, export_button), CDN, "plot6")        


        # % IIT By Supported LGAs
        data_9 = tx_ml_df[tx_ml_df['State'].isin(selected_states)]  
        tx_ml_df_state = data_9.groupby('LGA', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_state['IIT Rate (%)'] = np.round((tx_ml_df_state['IIT'] / tx_ml_df_state['TX_CURR']) * 100, decimals=1)   
        # Define the data source
        source = ColumnDataSource(tx_ml_df_state)
        LGAs = source.data["LGA"]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} % IIT By Supported LGAs' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=LGAs, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('LGA', -0.2, range=p.x_range), top='TX_CURR', width=0.25, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('LGA', 0.1, range=p.x_range), top='IIT', width=0.25, source=source,
                color="#71aebf", legend_label="IIT")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@LGA'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('LGA', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('LGA', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '10pt'        
        p.add_layout(p.legend[0], 'right')
        p.legend.click_policy = "hide"
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(tx_ml_df_state)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by LGA.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((p, export_button), CDN, "plot9")


        data_10 = tx_ml_df[tx_ml_df['State'].isin(selected_states)]  
        tx_ml_df_state = data_10.groupby('SurgeCommand', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_state['IIT Rate (%)'] = np.round((tx_ml_df_state['IIT'] / tx_ml_df_state['TX_CURR']) * 100, decimals=1)   
        # Define the data source
        source = ColumnDataSource(tx_ml_df_state)
        SurgeCommands = source.data["SurgeCommand"]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} % IIT By Command' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=SurgeCommands, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('SurgeCommand', -0.2, range=p.x_range), top='TX_CURR', width=0.25, source=source,
                color="#6ED40E", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('SurgeCommand', 0.1, range=p.x_range), top='IIT', width=0.25, source=source,
                color="#409efc", legend_label="IIT")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@SurgeCommand'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('SurgeCommand', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('SurgeCommand', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.05]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '10pt'        
        p.add_layout(p.legend[0], 'right')
        p.legend.click_policy = "hide"
        # Create csv table for export
        source = ColumnDataSource(tx_ml_df_state)
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        # Interrution in Treatment Distribution
        data_7 = df_ml_iit_list[df_ml_iit_list['State'].isin(selected_states)]        
        data_7agg = data_7.TX_ML_Outcome.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome', 'TX_ML_Outcome':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.27
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.27
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]       
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(state_names, total_count)
        # Creating chart vertical
        chart = figure(height=height, width=620, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot11_html = file_html((chart, export_button), CDN, "plot11") 

        
        data_6 = tx_ml_df[tx_ml_df['State'].isin(selected_states)]    
        data_6b = data_6.groupby('LGA')['TX_ML','IIT', 'Stopped Treatment', 'Transferred Out', 'Dead'].sum() 
        data_6b_df = data_6b.reset_index()
        def get_map_tx_ml(lga_name):
            # Function to get the TX_ML value for a given LGA
            tx_ml_values = data_6b_df.groupby('LGA')['TX_ML'].sum()
            return tx_ml_values.get(lga_name, "N/A")
        
        def get_map_tx_ml_iit(lga_name):
            # Function to get the IIT value for a given LGA
            tx_ml_iit = data_6b_df.groupby('LGA')['IIT'].sum()
            return tx_ml_iit.get(lga_name, "N/A")
        
        def get_map_tx_ml_stopped(lga_name):
            # Function to get the Stopped value for a given LGA
            tx_ml_stopped = data_6b_df.groupby('LGA')['Stopped Treatment'].sum()
            return tx_ml_stopped.get(lga_name, "N/A")
        
        def get_map_tx_ml_to(lga_name):
            # Function to get the Transferred Out value for a given LGA
            tx_ml_to = data_6b_df.groupby('LGA')['Transferred Out'].sum()
            return tx_ml_to.get(lga_name, "N/A")
        
        def get_map_tx_ml_dead(lga_name):
            # Function to get the Dead value for a given LGA
            tx_ml_dead = data_6b_df.groupby('LGA')['Dead'].sum()
            return tx_ml_dead.get(lga_name, "N/A")
   
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)

        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Treatment Mortality & Loss Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['LGA', 'TX_ML'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_ML', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_ML: {}<br>
                IIT: {}<br>
                Stopped: {}<br>
                Transferred Out: {}<br>
                Dead: {}
            </div>
        '''

        # Define a function to get locations for the selected LGAs
        def get_locations_for_states(selected_states):
            locations = []
            for state in selected_states:
                lgas_in_state = tx_ml_df[tx_ml_df['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations
        
        locations = get_locations_for_states(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_ml_value = get_map_tx_ml(loc["popup"])
            tx_ml_formatted = format_with_thousand_separator(tx_ml_value)   

            tx_ml_iit = get_map_tx_ml_iit(loc["popup"])
            tx_ml_iit_formatted = format_with_thousand_separator(tx_ml_iit)  

            tx_ml_stopped = get_map_tx_ml_stopped(loc["popup"])
            tx_ml_stopped_formatted = format_with_thousand_separator(tx_ml_stopped) 

            tx_ml_to = get_map_tx_ml_to(loc["popup"])
            tx_ml_to_formatted = format_with_thousand_separator(tx_ml_to) 

            tx_ml_dead = get_map_tx_ml_dead(loc["popup"])
            tx_ml_dead_formatted = format_with_thousand_separator(tx_ml_dead) 

            popup_content = popup_style.format(loc["popup"], tx_ml_formatted, tx_ml_iit_formatted, tx_ml_stopped_formatted, 
                                               tx_ml_to_formatted, tx_ml_dead_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_ml_button_json = json_item(export_button)  
        plot17_html = ng_map.get_root().render()       
   
        
    ####################### DATATABLE ######################################################################################        
        plot19_html = data_6.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)
        
        data_response = {
            'fac_num': fac_num_tx_ml_dict,
            'achieved': achieved_tx_ml_dict,
            'achieved_pbs': achieved_pbs_tx_ml_dict,
            'percent_pbs': percent_pbs_tx_ml_dict,
            'achieved_recapture': achieved_pbs_rec_tx_ml_dict,
            'percent_recaptured': percent_pbs_rec_tx_ml_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot4_html,
            'plot4': plotiit_days_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot11': plot11_html,
            'plot17': {'main': plot17_html, 'additional': tx_ml_button_json}, 
            'plot19': plot19_html
        }               
    

    elif (selected_indicator == 'TX_RTT' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['State'].isin(selected_states)]
        # Number of facilities
        fac_num_tx_rtt_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_rtt_dict = int(data_1['TX_RTT'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_rtt_dict = int(data_1['TX_RTT Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_rtt_percent = (achieved_pbs_tx_rtt_dict / achieved_tx_rtt_dict) * 100
        percent_pbs_tx_rtt_dict = f"{pbs_rtt_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_rtt_dict = int(data_1['TX_RTT Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_rtt_percent = (achieved_pbs_rec_tx_rtt_dict / achieved_pbs_tx_rtt_dict) * 100
        percent_pbs_rec_tx_rtt_dict = f"{pbs_rec_tx_rtt_percent:.1f}"            
        ############################################################################################
        # Returned To Treatment Distribution By Sex 
        data_2 = df_rtt_list[df_rtt_list['State'].isin(selected_states)]        
        data_2agg = data_2.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_2b = data_2agg.copy()
        total_count = data_2b['value'].sum()
        data_2b['angle'] = data_2b['value'] / total_count * 2 * pi
        value = data_2b["value"].values
        data_2b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_2b['cos'] = np.cos(data_2b['cumulative_angle']) * 0.32
        data_2b['sin'] = np.sin(data_2b['cumulative_angle']) * 0.32
        data_2b['cos2'] = np.cos(data_2b['cumulative_angle']) * 0.41
        data_2b['sin2'] = np.sin(data_2b['cumulative_angle']) * 0.41
        data_2b['formatted_value']=["{:,.0f}".format(val) for val in data_2b['value']]
        data_2b['percentage'] = (data_2b['value'] / total_count) * 100
        data_2b['label']=["({:.1f}%)".format(val) for val in data_2b['percentage']]
        data_2b['color'] = ['#2b9eea', '#2beaea'] 
        # Pad the 'value' column with spaces to improve label alignment
        data_2b["value"] = data_2b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_2b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Returned To Treatment By Sex' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_2agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((chart, export_button), CDN, "plot3")


        # Returned To Treatment Distribution
        data_3 = df_rtt_list[df_rtt_list['State'].isin(selected_states)]        
        data_3agg = data_3.TX_RTT_Outcome.value_counts().reset_index().rename(columns={'index':'TX_RTT_Outcome', 'TX_RTT_Outcome':'value'})
        data_3b = data_3agg.copy()
        total_count = data_3b['value'].sum()
        value = data_3b["value"].values
        data_3b['angle'] = data_3b['value'] / total_count * 2 * pi
        data_3b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_3b['cos'] = np.cos(data_3b['cumulative_angle']) * 0.27
        data_3b['sin'] = np.sin(data_3b['cumulative_angle']) * 0.27
        data_3b['cos2'] = np.cos(data_3b['cumulative_angle']) * 0.35
        data_3b['sin2'] = np.sin(data_3b['cumulative_angle']) * 0.35
        data_3b['formatted_value']=["{:,.0f}".format(val) for val in data_3b['value']]
        data_3b['percentage'] = (data_3b['value'] / total_count) * 100
        data_3b['label']=["({:.1f}%)".format(val) for val in data_3b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_3b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_3b['color'] = color_palette[:len(data_3b)]              
        # Pad the 'value' column with spaces to improve label alignment
        data_3b["value"] = data_3b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Creating chart vertical
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = "{} Returned To Treatment (TX_RTT) Total = {:,.0f}".format(state_names, total_count)
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@TX_RTT_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_RTT_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_3agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot4_html = file_html((chart, export_button), CDN, "plot4")


        # Returned To Treatment By AgeGroup & Sex        
        age_group_tx_rtt = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_tx_rtt = age_group_tx_rtt.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_rtt)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Returned To Treatment By 5-Year Age Band & Sex' 
        plot5 = age_group_tx_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot5.plot.width = plot_width
        # Adjusting toolbar size
        plot5.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot5.x_range.start = 0
        plot5.toolbar.logo = None    
        plot5.toolbar.active_scroll = None
        plot5.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_rtt)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh plot to HTML
        plot5_html = file_html((plot5, export_button), CDN, "plot5")        


        # Returned To Treatment By Age Group & Sex (Biometrics)
        # Filter the data
        data_4 = rtt_pbs_list[rtt_pbs_list['State'].isin(selected_states)]
        # Create crosstab
        age_group_pbs_rtt = pd.crosstab(data_4['AgeGroup'], data_4['Sex']).reset_index()
        age_group_pbs_rtt = age_group_pbs_rtt.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_rtt)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} TX_RTT Biometrics Captured By 5-Year Age Band & Sex' 
        # Plot 
        plot4 = age_group_pbs_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0        
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_rtt 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot4, export_button), CDN, "plot6")


        # Returned To Treatment MMD Distribution
        data_5 = df_rtt_list[df_rtt_list['State'].isin(selected_states)]  
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        # Define the custom order
        custom_order = ['MMD <3', 'MMD 3', 'MMD 4-5', 'MMD 6']
        # Convert the mmd column to a categorical type with the custom order
        data_5agg['mmd'] = pd.Categorical(data_5agg['mmd'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order
        data_5agg = data_5agg.sort_values('mmd')
        data_5_count = data_5agg.copy()
        data_5_count['formatted_value'] = ["{:,.0f}".format(val) for val in data_5_count['value']]
        # Define colors for each bar
        colors = ['#ff6f61', '#6aff99', '#6d99ff', '#aa66cc']
        data_5_count['color'] = colors[:len(data_5_count)]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Returned To Treatment By MMD' 
        # Create the bar plot
        plot5new_days = data_5_count.hvplot.barh(
            x="mmd", y='value', height=height, color='color', grid=True, xlabel='', line_color=None, fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, 
            ylabel='', width=plot_width, title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')

        # Add labels
        labels = hv.Labels(data=data_5_count, kdims=['mmd', 'value'], vdims='formatted_value')
        # Overlay labels on the bar plot
        plot_new = plot5new_days * labels
        # Get the underlying Bokeh plot
        bokeh_plot = hv.render(plot_new)
        # Format the x-axis with a thousand separator
        bokeh_plot.xaxis[0].formatter = NumeralTickFormatter(format="0,0")         
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)

        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot7_html = file_html((bokeh_plot, export_button), CDN, "plot7")           

        
        # Returned To Treatment CD4 Distribution
        data_6 = rtt_cd4_list[rtt_cd4_list['State'].isin(selected_states)]
        data_6agg = data_6.TX_RTT_CD4.value_counts().reset_index().rename(columns={'index':'TX_RTT_CD4', 'TX_RTT_CD4':'value'})
        data_6_count = data_6agg.copy()
        data_6_count['formatted_value']=["{:,.0f}".format(val) for val in data_6_count['value']]    
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Returned To Treatment By CD4 Count'     
        plot5new_days=data_6_count.hvplot.bar(x="TX_RTT_CD4", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT_CD4")                                

        labels = hv.Labels(data=data_6_count, kdims=['TX_RTT_CD4', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_6agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot8_html = file_html((bokeh_model, export_button), CDN, "plot8")   


        # Returned To Treatment Distribution By LGA
        data_8 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['State'].isin(selected_states)] 
        data_8agg = data_8.groupby('LGA')[['TX_RTT']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_RTT']]   
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Returned To Treatment By LGA'     
        plot9=data_8_sum.hvplot.bar(x="LGA", y='TX_RTT', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT")                                

        labels = hv.Labels(data=data_8_sum, kdims=['LGA', 'TX_RTT'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("Local Government", "@LGA"), ("TX_RTT", "@TX_RTT{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by LGA.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((bokeh_model, export_button), CDN, "plot9")   


        # Returned To Treatment Distribution By SurgeCommand
        data_9 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['State'].isin(selected_states)] 
        data_9agg = data_9.groupby('SurgeCommand')[['TX_RTT']].sum().reset_index()    
        data_9_sum = data_9agg.copy()
        data_9_sum['formatted_value']=data_9_sum['TX_RTT'].apply(lambda x: "{:,.0f}".format(x))  
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Returned To Treatment By Command'      
        plot10=data_9_sum.hvplot.bar(x="SurgeCommand", y='TX_RTT', height=height, color='#6ED40E', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT")                                

        labels = hv.Labels(data=data_9_sum, kdims=['SurgeCommand', 'TX_RTT'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot10 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add HoverTool with formatted tooltips
        hover = HoverTool()
        hover.tooltips = [("Command", "@SurgeCommand"), ("TX_RTT", "@TX_RTT{0,0}")]
        bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_9agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tr_rtt by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((bokeh_model, export_button), CDN, "plot10")      


        data_7 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['State'].isin(selected_states)]  
        data_7b_rtt = data_7.groupby('LGA', as_index=True)[['TX_RTT','TX_RTT Captured', 'TX_RTT Recaptured']].sum()   
        data_7b_rtt=data_7b_rtt.reset_index()  

        def get_map_tx_rtt(lga_name):
            # Function to get the TX_RTT value for a given LGA
            tx_rtt_values = data_7b_rtt.groupby('LGA')['TX_RTT'].sum()            
            return tx_rtt_values.get(lga_name, "N/A")
        
        def get_map_tx_rtt2(lga_name):
            # Convert list to dictionary
            tx_rtt_cap_dict = dict(zip(data_7b_rtt['LGA'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Captured'] / data_7b_rtt['TX_RTT']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_rtt_cap_dict.get(lga_name, "N/A")

        def get_map_tx_rtt3(lga_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_rtt_recap_dict = dict(zip(data_7b_rtt['LGA'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Recaptured'] / data_7b_rtt['TX_RTT Captured']) * 100, decimals=1))))
            return tx_rtt_recap_dict.get(lga_name, "N/A")
        
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)
            
        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Returned To Treatment Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_7b_rtt, columns=['LGA', 'TX_RTT'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_RTT', highlight=True).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_RTT: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''

        # Define a function to get locations for the selected LGAs
        def get_locations_for_states(selected_states):
            locations = []
            for state in selected_states:
                lgas_in_state = tx_rtt_temp_tbl[tx_rtt_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations    
        
        locations = get_locations_for_states(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_rtt_value = get_map_tx_rtt(loc["popup"])
            tx_rtt_formatted = format_with_thousand_separator(tx_rtt_value)            
            tx_rtt_cap_dict = get_map_tx_rtt2(loc["popup"])
            tx_rtt_recap_dict = get_map_tx_rtt3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_rtt_formatted, 
                                                tx_rtt_cap_dict, 
                                                tx_rtt_recap_dict) 
            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Create ColumnDataSource from the DataFrame
        source = ColumnDataSource(data_7b_rtt)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_rtt_button_json = json_item(export_button)
        plot17_html = ng_map.get_root().render() 

        ####################### DATATABLE ######################################################################################        
        plot19_html = data_1.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_rtt_dict,
            'achieved': achieved_tx_rtt_dict,
            'achieved_pbs': achieved_pbs_tx_rtt_dict,
            'percent_pbs': percent_pbs_tx_rtt_dict,
            'achieved_recapture': achieved_pbs_rec_tx_rtt_dict,
            'percent_recaptured': percent_pbs_rec_tx_rtt_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot7': plot7_html,
            'plot8': plot8_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': tx_rtt_button_json}, 
            'plot19': plot19_html

        }  


    elif (selected_indicator == 'TX_PVLS' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['State'].isin(selected_states)]    
        # Number of facilities
        fac_num_tx_pvls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_pvls_dict = int(data_1['TX_PVLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_pvls_dict = int(data_1['TX_PVLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_tx_pvls_percent = (achieved_pbs_tx_pvls_dict / achieved_tx_pvls_dict) * 100
        percent_pbs_tx_pvls_dict = f"{pbs_tx_pvls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_pvls_dict = int(data_1['TX_PVLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_pvls_percent = (achieved_pbs_rec_tx_pvls_dict / achieved_pbs_tx_pvls_dict) * 100
        percent_pbs_rec_tx_pvls_dict = f"{pbs_rec_tx_pvls_percent:.1f}"     
        ############################################################################################################
        data_1b = tx_pvls_state[tx_pvls_state['State'].isin(selected_states)] 
        source = ColumnDataSource(data_1b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Viral Load Suppression Performance' 
        # Create a new plot with a title and axis labels 
        plot1 = figure(x_range=FactorRange(*source.data['State']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="right")
        # Render bars
        bars = {
            'Eligible for VL': plot1.vbar(x=dodge('State', -0.3, range=plot1.x_range), top='Eligible for VL', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': plot1.vbar(x=dodge('State', -0.1, range=plot1.x_range), top='TX_PVLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': plot1.vbar(x=dodge('State', 0.1, range=plot1.x_range), top='TX_PVLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N)"),
            'Undetected VL <50': plot1.vbar(x=dodge('State', 0.3, range=plot1.x_range), top='Undetected VL <50', width=0.18, source=source,
                                            color="#A8B9E2", legend_label="Undetected VL <50")
        }

        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('State', -0.3, range=plot1.x_range), y='Eligible for VL', text='Eligible for VL',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', -0.1, range=plot1.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', 0.1, range=plot1.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', 0.3, range=plot1.x_range), y='Undetected VL <50', text='Undetected VL <50',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression', '% Undetected']
        colors = ["Magenta", "green", "blue"]
        dodge_values = [-0.2, 0, 0.2]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '4.5pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below')   #Valid place values are: above, below, left, right or center
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        data_2 = grouped_pvls_state[grouped_pvls_state['State'].isin(selected_states)] 
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Viral Load Coverage & Suppression By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")
             
        
        ############################################################################################
        # Clients' Viral Load Suppression By Age Band
        data_3 = pvls_temp_tbl_all_age_state[pvls_temp_tbl_all_age_state['State'].isin(selected_states)]   
        data_3b = data_3.groupby('AgeGroup')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()    
        data_3b.loc[:, '% Coverage'] = np.round((data_3b['TX_PVLS (D)'] / data_3b['Eligible for VL']) * 100, decimals=1)
        data_3b.loc[:, '% Suppression'] = np.round((data_3b['TX_PVLS (N)'] / data_3b['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Ensure AgeGroup values are unique
        age_groups = data_3['AgeGroup'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f"{state_names} Clients' Viral Load Suppression By Age Band"
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")

        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible for VL', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             

        source = ColumnDataSource(data_3b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        # Female Clients' Viral Load Suppression By Age Band
        data_4 = pvls_temp_tbl_age_state_female[pvls_temp_tbl_age_state_female['State'].isin(selected_states)]    
        # Define the data source
        source = ColumnDataSource(data_4)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f"{state_names} Female Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Female)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Female)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Female)"),
            'TX_PVLS (D, Female)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Female)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Female)"),
            'TX_PVLS (N, Female)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Female)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Female)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis        
        # Add value labels  
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Female)', text='Eligible (Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Female)', text='TX_PVLS (D, Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Female)', text='TX_PVLS (N, Female)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Female)', '% Suppression (Female)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_4)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'female tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsf_html = file_html((p, export_button), CDN, "plot10")


        # Male Clients' Viral Load Suppression By Age Band
        data_5 = pvls_temp_tbl_age_state_male[pvls_temp_tbl_age_state_male['State'].isin(selected_states)]    
        # Define the data source
        source = ColumnDataSource(data_5)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f"{state_names} Male Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Male)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Male)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Male)"),
            'TX_PVLS (D, Male)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Male)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Male)"),
            'TX_PVLS (N, Male)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Male)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Male)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Male)', text='Eligible (Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Male)', text='TX_PVLS (D, Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Male)', text='TX_PVLS (N, Male)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Male)', '% Suppression (Male)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_5)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'male tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsm_html = file_html((p, export_button), CDN, "plot11")


        data_7 = pvls_temp_tbl_all_age_state[pvls_temp_tbl_all_age_state['State'].isin(selected_states)] 
        data_7b = data_7.groupby('LGA')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['TX_PVLS (D)'] / data_7b['Eligible for VL']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['TX_PVLS (N)'] / data_7b['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        lga_categories = data_7['LGA'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Viral Load Coverage & Suppression By LGA' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('LGA', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('LGA', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('LGA', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@LGA'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('LGA', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by LGA.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html = file_html((p, export_button), CDN, "plot12")


        data_8 = pvls_temp_tbl_all_age_state[pvls_temp_tbl_all_age_state['State'].isin(selected_states)] 
        data_8b = data_8.groupby('SurgeCommand')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()  
        data_8b.loc[:, '% Coverage'] = np.round((data_8b['TX_PVLS (D)'] / data_8b['Eligible for VL']) * 100, decimals=1)
        data_8b.loc[:, '% Suppression'] = np.round((data_8b['TX_PVLS (N)'] / data_8b['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        Command_categories = data_8['SurgeCommand'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_8b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Viral Load Coverage & Suppression By Commands' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=Command_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('SurgeCommand', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('SurgeCommand', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('SurgeCommand', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@SurgeCommand'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('SurgeCommand', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_8b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot13_html = file_html((p, export_button), CDN, "plot13")


        data_6 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['State'].isin(selected_states)]  
        data_6b = data_6.groupby('LGA')[['Eligible for VL', 'VL sample taken in 1 year', 'TX_PVLS (D)', 'TX_PVLS (N)']].sum() 
        data_6b_df=data_6b.reset_index()   

        def get_map_tx_pvls(lga_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_pvls_values = data_6b_df.groupby('LGA')['Eligible for VL'].sum()
            return tx_pvls_values.get(lga_name, "N/A")
        
        def get_map_tx_pvls2(lga_name):
            # Convert list to dictionary
            tx_pvls_cov_dict = dict(zip(data_6b_df['LGA'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (D)'] / data_6b_df['Eligible for VL']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_pvls_cov_dict.get(lga_name, "N/A")

        def get_map_tx_pvls3(lga_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_pvls_sup_dict = dict(zip(data_6b_df['LGA'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (N)'] / data_6b_df['TX_PVLS (D)']) * 100, decimals=1))))
            return tx_pvls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)
                   
        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['LGA', 'Eligible for VL'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name="Patients' Viral Load Suppression (PVLS)", nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_states(selected_states):
            locations = []
            for state in selected_states:
                lgas_in_state = tx_pvls_temp_tbl[tx_pvls_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations             
        
        locations = get_locations_for_states(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_pvls_values = get_map_tx_pvls(loc["popup"])
            tx_pvls_formatted = format_with_thousand_separator(tx_pvls_values)     
            tx_pvls_cov_dict = get_map_tx_pvls2(loc["popup"])
            tx_pvls_sup_dict = get_map_tx_pvls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_pvls_formatted, 
                                                tx_pvls_cov_dict, 
                                                tx_pvls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        tx_pvls_button_json = json_item(export_button)    
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################             
        tx_pvls_state3 = tx_pvls_state2[tx_pvls_state2['State'].isin(selected_states)] 
        plot18_html = tx_pvls_state3.to_html(index=False, classes=['cascade', 'table table-bordered',"display"], escape=False)
       
        plot19_html = data_1.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_pvls_dict,
            'achieved': achieved_tx_pvls_dict,
            'achieved_pbs': achieved_pbs_tx_pvls_dict,
            'percent_pbs': percent_pbs_tx_pvls_dict,
            'achieved_recapture': achieved_pbs_rec_tx_pvls_dict,
            'percent_recaptured': percent_pbs_rec_tx_pvls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plotvlsf_html,
            'plot11': plotvlsm_html,
            'plot12': plot12_html,
            'plot13': plot13_html,
            'plot17': {'main': plot17_html, 'additional': tx_pvls_button_json}, 
            'plot18': plot18_html,
            'plot19': plot19_html
        }      


    elif (selected_indicator == 'PBFW VLS' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['State'].isin(selected_states)]  
        # Number of facilities
        fac_num_pbfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pbfw_vls_dict = int(data_1['PBFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pbfw_vls_dict = int(data_1['PBFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pbfw_vls_percent = (achieved_pbs_pbfw_vls_dict / achieved_pbfw_vls_dict) * 100
        percent_pbs_pbfw_vls_dict = f"{pbs_pbfw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pbfw_vls_dict = int(data_1['PBFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pbfw_vls_percent = (achieved_pbs_rec_pbfw_vls_dict / achieved_pbs_pbfw_vls_dict) * 100
        percent_pbs_rec_pbfw_vls_dict = f"{pbs_rec_pbfw_vls_percent:.1f}"       
        ############################################################################################
        # Create IP Summary Table
        data_1b = data_1.groupby('State', as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PBFW VLS (D)'] / data_1b['PBFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PBFW VLS (N)'] / data_1b['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant & Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['State']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PBFW VL Eligible': plot1.vbar(x=dodge('State', -0.3, range=plot1.x_range), top='PBFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': plot1.vbar(x=dodge('State', -0.1, range=plot1.x_range), top='PBFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': plot1.vbar(x=dodge('State', 0.1, range=plot1.x_range), top='PBFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('State', -0.3, range=plot1.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', -0.1, range=plot1.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', 0.1, range=plot1.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'State' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['State'].isin(selected_states)] 
        data_2 = data_2.groupby(['State', 'mmd'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PBFW VLS (D)'] / data_2['PBFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PBFW VLS (N)'] / data_2['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant & Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PBFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pbfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['State'].isin(selected_states)] 
        pbfw_vls_temp_tbl_age = pbfw_vls_temp_tbl_age.groupby(['State', 'AgeGroup'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        pbfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (D)'] / pbfw_vls_temp_tbl_age['PBFW VL Eligible']) * 100, decimals=1)
        pbfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (N)'] / pbfw_vls_temp_tbl_age['PBFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pbfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant & Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PBFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PBFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PBFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['State'].isin(selected_states)] 
        data_7b = data_7.groupby('LGA')[['PBFW VL Eligible','PBFW VLS (D)', 'PBFW VLS (N)']].sum()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PBFW VLS (D)'] / data_7b['PBFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PBFW VLS (N)'] / data_7b['PBFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        lga_categories = data_7['LGA'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant & Breastfeeding Women VLS By LGA' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('LGA', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('LGA', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('LGA', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@LGA'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('LGA', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by LGA.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_8 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['State'].isin(selected_states)] 
        data_8b = data_8.groupby('SurgeCommand')[['PBFW VL Eligible','PBFW VLS (D)', 'PBFW VLS (N)']].sum()  
        data_8b.loc[:, '% Coverage'] = np.round((data_8b['PBFW VLS (D)'] / data_8b['PBFW VL Eligible']) * 100, decimals=1)
        data_8b.loc[:, '% Suppression'] = np.round((data_8b['PBFW VLS (N)'] / data_8b['PBFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        Command_categories = data_8['SurgeCommand'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_8b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant & Breastfeeding Women VLS By Commands' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=Command_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('SurgeCommand', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('SurgeCommand', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('SurgeCommand', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@SurgeCommand'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('SurgeCommand', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_8b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot11_html = file_html((p, export_button), CDN, "plot11")   


        data_6 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['State'].isin(selected_states)]  
        data_6b = data_6.groupby('LGA')[['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pbfw_vls(lga_name):
            # Function to get the pbfw_vls value for a given LGA
            pbfw_vls_values = data_6b.groupby('LGA')['PBFW VL Eligible'].sum()
            return pbfw_vls_values.get(lga_name, "N/A")
        
        def get_map_pbfw_vls2(lga_name):
            # Convert list to dictionary
            pbfw_vls_cov_dict = dict(zip(data_6b['LGA'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (D)'] / data_6b['PBFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pbfw_vls_cov_dict.get(lga_name, "N/A")

        def get_map_pbfw_vls3(lga_name):
            # Function to get the pbfw_vls value for a given LGA
            pbfw_vls_sup_dict = dict(zip(data_6b['LGA'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (N)'] / data_6b['PBFW VLS (D)']) * 100, decimals=1))))
            return pbfw_vls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)
        
        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Pregnant & Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['LGA', 'PBFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant & Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_states(selected_states):
            locations = []
            for state in selected_states:
                lgas_in_state = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations   
        
        locations = get_locations_for_states(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            pbfw_vls_values = get_map_pbfw_vls(loc["popup"])
            pbfw_vls_formatted = format_with_thousand_separator(pbfw_vls_values)     
            pbfw_vls_cov_dict = get_map_pbfw_vls2(loc["popup"])
            pbfw_vls_sup_dict = get_map_pbfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pbfw_vls_formatted, 
                                                pbfw_vls_cov_dict, 
                                                pbfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pbfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        pbfw_pvls_temp_tbl_state = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['State'].isin(selected_states)] 
        plot19_html = pbfw_pvls_temp_tbl_state.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pbfw_vls_dict,
            'achieved': achieved_pbfw_vls_dict,
            'achieved_pbs': achieved_pbs_pbfw_vls_dict,
            'percent_pbs': percent_pbs_pbfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pbfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pbfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot11': plot11_html,
            'plot17': {'main': plot17_html, 'additional': pbfw_vls_button_json}, 
            'plot19': plot19_html
        } 


    elif (selected_indicator == 'PW VLS' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['State'].isin(selected_states)]  
        # Number of facilities
        fac_num_pw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pw_vls_dict = int(data_1['PW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pw_vls_dict = int(data_1['PW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pw_vls_percent = (achieved_pbs_pw_vls_dict / achieved_pw_vls_dict) * 100
        percent_pbs_pw_vls_dict = f"{pbs_pw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pw_vls_dict = int(data_1['PW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pw_vls_percent = (achieved_pbs_rec_pw_vls_dict / achieved_pbs_pw_vls_dict) * 100
        percent_pbs_rec_pw_vls_dict = f"{pbs_rec_pw_vls_percent:.1f}"     
        ############################################################################################ 
        # Create IP Summary Table
        data_1b = data_1.groupby('State', as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PW VLS (D)'] / data_1b['PW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PW VLS (N)'] / data_1b['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['State']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PW VL Eligible': plot1.vbar(x=dodge('State', -0.3, range=plot1.x_range), top='PW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': plot1.vbar(x=dodge('State', -0.1, range=plot1.x_range), top='PW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': plot1.vbar(x=dodge('State', 0.1, range=plot1.x_range), top='PW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('State', -0.3, range=plot1.x_range), y='PW VL Eligible', text='PW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', -0.1, range=plot1.x_range), y='PW VLS (D)', text='PW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', 0.1, range=plot1.x_range), y='PW VLS (N)', text='PW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'State' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['State'].isin(selected_states)] 
        data_2 = data_2.groupby(['State', 'mmd'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PW VLS (D)'] / data_2['PW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PW VLS (N)'] / data_2['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['State'].isin(selected_states)] 
        pw_vls_temp_tbl_age = pw_vls_temp_tbl_age.groupby(['State', 'AgeGroup'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        pw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pw_vls_temp_tbl_age['PW VLS (D)'] / pw_vls_temp_tbl_age['PW VL Eligible']) * 100, decimals=1)
        pw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pw_vls_temp_tbl_age['PW VLS (N)'] / pw_vls_temp_tbl_age['PW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['State'].isin(selected_states)] 
        data_7b = data_7.groupby('LGA')[['PW VL Eligible','PW VLS (D)', 'PW VLS (N)']].sum()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PW VLS (D)'] / data_7b['PW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PW VLS (N)'] / data_7b['PW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        lga_categories = data_7['LGA'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant Women VLS By LGA' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('LGA', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('LGA', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('LGA', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@LGA'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('LGA', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by LGA.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_8 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['State'].isin(selected_states)] 
        data_8b = data_8.groupby('SurgeCommand')[['PW VL Eligible','PW VLS (D)', 'PW VLS (N)']].sum()  
        data_8b.loc[:, '% Coverage'] = np.round((data_8b['PW VLS (D)'] / data_8b['PW VL Eligible']) * 100, decimals=1)
        data_8b.loc[:, '% Suppression'] = np.round((data_8b['PW VLS (N)'] / data_8b['PW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        Command_categories = data_8['SurgeCommand'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_8b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Pregnant Women VLS By Commands' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=Command_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('SurgeCommand', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('SurgeCommand', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('SurgeCommand', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@SurgeCommand'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('SurgeCommand', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_8b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot11_html = file_html((p, export_button), CDN, "plot11")   


        data_6 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['State'].isin(selected_states)]  
        data_6b = data_6.groupby('LGA')[['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pw_vls(lga_name):
            # Function to get the pw_vls value for a given LGA
            pw_vls_values = data_6b.groupby('LGA')['PW VL Eligible'].sum()
            return pw_vls_values.get(lga_name, "N/A")
        
        def get_map_pw_vls2(lga_name):
            # Convert list to dictionary
            pw_vls_cov_dict = dict(zip(data_6b['LGA'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (D)'] / data_6b['PW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pw_vls_cov_dict.get(lga_name, "N/A")

        def get_map_pw_vls3(lga_name):
            # Function to get the pw_vls value for a given LGA
            pw_vls_sup_dict = dict(zip(data_6b['LGA'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (N)'] / data_6b['PW VLS (D)']) * 100, decimals=1))))
            return pw_vls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)
               
        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Pregnant Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['LGA', 'PW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_states(selected_states):
            locations = []
            for state in selected_states:
                lgas_in_state = pw_pvls_temp_tbl[pw_pvls_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations   
        
        locations = get_locations_for_states(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            pw_vls_values = get_map_pw_vls(loc["popup"])
            pw_vls_formatted = format_with_thousand_separator(pw_vls_values)     
            pw_vls_cov_dict = get_map_pw_vls2(loc["popup"])
            pw_vls_sup_dict = get_map_pw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pw_vls_formatted, 
                                                pw_vls_cov_dict, 
                                                pw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        pw_pvls_temp_tbl_state = pw_pvls_temp_tbl[pw_pvls_temp_tbl['State'].isin(selected_states)] 
        plot19_html = pw_pvls_temp_tbl_state.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pw_vls_dict,
            'achieved': achieved_pw_vls_dict,
            'achieved_pbs': achieved_pbs_pw_vls_dict,
            'percent_pbs': percent_pbs_pw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot11': plot11_html,
            'plot17': {'main': plot17_html, 'additional': pw_vls_button_json}, 
            'plot19': plot19_html

        } 


    elif (selected_indicator == 'BFW VLS' and selected_states):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['State'].isin(selected_states)]   
        # Number of facilities
        fac_num_bfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_bfw_vls_dict = int(data_1['BFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_bfw_vls_dict = int(data_1['BFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_bfw_vls_percent = (achieved_pbs_bfw_vls_dict / achieved_bfw_vls_dict) * 100
        percent_pbs_bfw_vls_dict = f"{pbs_bfw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_bfw_vls_dict = int(data_1['BFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_bfw_vls_percent = (achieved_pbs_rec_bfw_vls_dict / achieved_pbs_bfw_vls_dict) * 100
        percent_pbs_rec_bfw_vls_dict = f"{pbs_rec_bfw_vls_percent:.1f}"     
        ############################################################################################            
        # Create IP Summary Table
        data_1b = data_1.groupby('State', as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['BFW VLS (D)'] / data_1b['BFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['BFW VLS (N)'] / data_1b['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['State']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'BFW VL Eligible': plot1.vbar(x=dodge('State', -0.3, range=plot1.x_range), top='BFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': plot1.vbar(x=dodge('State', -0.1, range=plot1.x_range), top='BFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': plot1.vbar(x=dodge('State', 0.1, range=plot1.x_range), top='BFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('State', -0.3, range=plot1.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', -0.1, range=plot1.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('State', 0.1, range=plot1.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('State', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'State' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['State'].isin(selected_states)] 
        data_2 = data_2.groupby(['State', 'mmd'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['BFW VLS (D)'] / data_2['BFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['BFW VLS (N)'] / data_2['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # BFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        bfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['State'].isin(selected_states)] 
        bfw_vls_temp_tbl_age = bfw_vls_temp_tbl_age.groupby(['State', 'AgeGroup'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        bfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (D)'] / bfw_vls_temp_tbl_age['BFW VL Eligible']) * 100, decimals=1)
        bfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (N)'] / bfw_vls_temp_tbl_age['BFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = bfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='BFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='BFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='BFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['State'].isin(selected_states)] 
        data_7b = data_7.groupby('LGA')[['BFW VL Eligible','BFW VLS (D)', 'BFW VLS (N)']].sum()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['BFW VLS (D)'] / data_7b['BFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['BFW VLS (N)'] / data_7b['BFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        lga_categories = data_7['LGA'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Breastfeeding Women VLS By LGA' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('LGA', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('LGA', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('LGA', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@LGA'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('LGA', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by LGA.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_8 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['State'].isin(selected_states)] 
        data_8b = data_8.groupby('SurgeCommand')[['BFW VL Eligible','BFW VLS (D)', 'BFW VLS (N)']].sum()  
        data_8b.loc[:, '% Coverage'] = np.round((data_8b['BFW VLS (D)'] / data_8b['BFW VL Eligible']) * 100, decimals=1)
        data_8b.loc[:, '% Suppression'] = np.round((data_8b['BFW VLS (N)'] / data_8b['BFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        Command_categories = data_8['SurgeCommand'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_8b)
        # Create a title string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        plot_title = f'{state_names} Breastfeeding Women VLS By Commands' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=Command_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('SurgeCommand', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('SurgeCommand', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('SurgeCommand', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Local Government', '@SurgeCommand'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('SurgeCommand', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_8b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by SurgeCommand.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot11_html = file_html((p, export_button), CDN, "plot11")   


        data_6 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['State'].isin(selected_states)]  
        data_6b = data_6.groupby('LGA')[['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_bfw_vls(lga_name):
            # Function to get the bfw_vls value for a given LGA
            bfw_vls_values = data_6b.groupby('LGA')['BFW VL Eligible'].sum()
            return bfw_vls_values.get(lga_name, "N/A")
        
        def get_map_bfw_vls2(lga_name):
            # Convert list to dictionary
            bfw_vls_cov_dict = dict(zip(data_6b['LGA'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (D)'] / data_6b['BFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return bfw_vls_cov_dict.get(lga_name, "N/A")

        def get_map_bfw_vls3(lga_name):
            # Function to get the bfw_vls value for a given LGA
            bfw_vls_sup_dict = dict(zip(data_6b['LGA'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (N)'] / data_6b['BFW VLS (D)']) * 100, decimals=1))))
            return bfw_vls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_states):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_states]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_states)
                  
        # Get the coordinates for the first selected LGA
        state_center = state_coordinates.get(selected_states[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=state_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected state(s)
        state_names = ', '.join(selected_states)
        # Update the HTML title to include the state names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{state_names} Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['LGA', 'BFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_states(selected_states):
            locations = []
            for state in selected_states:
                lgas_in_state = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['State'] == state]['LGA'].unique()
                for lga in lgas_in_state:
                    coordinates = lga_coordinates.get(lga, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": lga})
            return locations   
        
        locations = get_locations_for_states(selected_states)
        # Add popup and tooltip for each LGA
        for loc in locations:
            bfw_vls_values = get_map_bfw_vls(loc["popup"])
            bfw_vls_formatted = format_with_thousand_separator(bfw_vls_values)     
            bfw_vls_cov_dict = get_map_bfw_vls2(loc["popup"])
            bfw_vls_sup_dict = get_map_bfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                bfw_vls_formatted, 
                                                bfw_vls_cov_dict, 
                                                bfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        bfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        bfw_pvls_temp_tbl_state = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['State'].isin(selected_states)] 
        plot19_html = bfw_pvls_temp_tbl_state.to_html(index=False, classes=['tbl_ip', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_bfw_vls_dict,
            'achieved': achieved_bfw_vls_dict,
            'achieved_pbs': achieved_pbs_bfw_vls_dict,
            'percent_pbs': percent_pbs_bfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_bfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_bfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot11': plot11_html,
            'plot17': {'main': plot17_html, 'additional': bfw_vls_button_json}, 
            'plot19': plot19_html

        } 


    ########################## LGAs ###################### LGAs ###################### LGAs ########################
    ########################## LGAs ###################### LGAs ###################### LGAs ########################and selected_states
    elif selected_indicator == 'TX_CURR' and selected_lgas:        
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment current indicator for selected LGAs         
        data_1 = tx_curr_temp_tbl[tx_curr_temp_tbl['LGA'].isin(selected_lgas)]  
        # print(data_1, end='\n')
        # Number of facilities
        fac_num_lga_curr_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_curr_dict_lga = int(data_1['TX_CURR'].sum())        
        # Biometrics Captured
        achieved_pbs_curr_dict_lga = int(data_1['Biometrics Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_curr_dict_lga > 0:
            pbs_curr_percent = (achieved_pbs_curr_dict_lga / achieved_tx_curr_dict_lga) * 100
            percent_pbs_curr_dict_lga = f"{pbs_curr_percent:.1f}"        
        else:
            percent_pbs_curr_dict_lga = None 
        # Biometrics Recaptured
        achieved_pbs_rec_tx_curr_dict_lga = int(data_1['Biometrics Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_curr_dict_lga > 0:
            pbs_rec_tx_curr_percent = (achieved_pbs_rec_tx_curr_dict_lga / achieved_pbs_curr_dict_lga) * 100
            percent_pbs_rec_tx_curr_dict_lga = f"{pbs_rec_tx_curr_percent:.1f}"    
        else:
            percent_pbs_rec_tx_curr_dict_lga = None           
        ############################################################################################
        # Handle data elements from the line list table        
        # Treatment Current By Pediatric & Adult Clients & Sex above 
        data_4 = df_curr_list[df_curr_list['LGA'].isin(selected_lgas)]
        longfm1_lga_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_curr_widefm2_lga_age_sex = longfm1_lga_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='CurrentARTStatus_28Days')

        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current By Pediatric & Adult Clients & Sex'

        plot1=tx_curr_widefm2_lga_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                            fontsize={'xticks': 10, 'yticks': 10, 'title': 10},  width=plot_width, height=height, 
                                            title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_CURR', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the current document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_curr_widefm2_lga_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr peed&adult age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html_lga = json_item(bokeh_model)
        button_json_lga = json_item(export_button)
        
                                       
        # Treatment Current Distribution By Sex 
        data_5 = df_curr_list[df_curr_list['LGA'].isin(selected_lgas)]        
        data_5agg = data_5.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b['color'] = ["#2b9eb0", "#9ecae1"]         
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current By Sex'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html_lga = file_html((chart, export_button), CDN, "plot2")

       
        # Treatment Current By AgeGroup & Sex   
        data_2 = df_curr_list[df_curr_list['LGA'].isin(selected_lgas)]     
        age_group_tx_curr = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_curr = age_group_tx_curr.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_curr)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current By 5-Year Age Band & Sex'
        plot3 = age_group_tx_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.toolbar.logo = None
        plot3.x_range.start = 0        
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_curr)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html_lga = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment Current By Age Group & Sex
        # Filter the data
        data_3 = df_pbs_list[df_pbs_list['LGA'].isin(selected_lgas)]
        # Create crosstab
        age_group_pbs_curr = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_curr = age_group_pbs_curr.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_curr)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current Biometrics By 5-Year Age Band & Sex'
        # Plot 
        plot4 = age_group_pbs_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0       
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_curr 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html_lga = file_html((plot4, export_button), CDN, "plot4")
             

        # Treatment Current MMD Distribution
        data_5 = df_curr_list[df_curr_list['LGA'].isin(selected_lgas)]        
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()        
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b["value"] = data_5b['value'].astype(str)
        data_5b["value"] = data_5b["value"].str.pad(35, side="left")
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current By Multi-Month Dispensing (MMD)'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@mmd: @formatted_value, Percentage: @percentage{0.0}%",x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, inner_radius=0.20, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='mmd', source=source)
      
        # Callouts for labels
        callouts = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-25, source=source, render_mode='canvas',
                            text_align="center", angle=0, text_font_size='10pt', text_color='#000000')
        chart.add_layout(callouts)
        percentage_callouts = LabelSet(x="cos2", y="sin2", y_offset=-25, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')
        chart.add_layout(percentage_callouts)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None   
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html_lga = file_html((chart, export_button), CDN, "plot5")


        # Treatment Current By MMD & 5-Year Age Band
        data_7 = df_curr_list[df_curr_list['LGA'].isin(selected_lgas)]     
        # Perform crosstab to get counts by AgeGroup and MMD
        tx_curr_age_mmd = pd.crosstab(data_7['AgeGroup'], data_7['mmd']).reset_index()
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(tx_curr_age_mmd)
        # List of MMD factors
        # mmd_factors = tx_curr_age_mmd.columns[1:]
        mmd_factors = list(tx_curr_age_mmd.columns[1:])
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current By MMD & 5-Year Age Band'
        # Create the Bokeh figure for stacked column chart
        plot = figure(x_range=tx_curr_age_mmd['AgeGroup'], 
                    title=plot_title, x_axis_label="", y_axis_label="Number of clients", 
                    height=height, plot_width=plot_width, toolbar_location='right', 
                    tools=[CrosshairTool(), PanTool(), BoxZoomTool(), SaveTool(), ResetTool()])

        # Add a HoverTool to display details on hover
        hover = HoverTool(tooltips=[("Age Band", "@AgeGroup"), ("MMD", "$name"), ("TX_CURR", "@$name{0,0}")])
        plot.add_tools(hover)
        # Add stacked columns to the figure
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))       
        # Get the closest supported size for the Spectral palette
        num_colors = len(mmd_factors)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        colors = color_palette[:num_colors]  
        # colors = ["#2b9eb0", '#2beaea', '#2b9eea', "#9ecae1"]
        plot.vbar_stack(stackers=mmd_factors, x='AgeGroup', width=0.8, color=colors, 
                        source=source, legend_label=[str(mmd) for mmd in mmd_factors])
        # Customize plot
        plot.xaxis.major_label_orientation = 1.2
        plot.toolbar.logo = None
        plot.y_range.start = 0 
        # Format y-axis with thousand separators
        plot.yaxis.formatter = NumeralTickFormatter(format="0,0")
        # Add legend click policy
        plot.legend.click_policy = "hide"
        plot.toolbar.autohide = True
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD & 5yr age.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label="Export CSV", button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html_lga = file_html((plot, export_button), CDN, "plot6")


        # Treatment Current Distribution By Facility
        data_8 = tx_curr_temp_tbl[tx_curr_temp_tbl['LGA'].isin(selected_lgas)] 
        data_8agg = data_8.groupby('Facility Name')[['TX_CURR']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_CURR']]   
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Current By Facility'     
        plot9=data_8_sum.hvplot.bar(x="Facility Name", y='TX_CURR', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_CURR")                                

        labels = hv.Labels(data=data_8_sum, kdims=['Facility Name', 'TX_CURR'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # # Add HoverTool with formatted tooltips
        # hover = HoverTool()
        # hover.tooltips = [("Facility", "@Facility Name"), ("TX_CURR", "@TX_CURR{0,0}")]
        # bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html_lga = file_html((bokeh_model, export_button), CDN, "plot9")           


        # Treatment Current Map
        data_6 = tx_curr_temp_tbl[tx_curr_temp_tbl['LGA'].isin(selected_lgas)]  
        data_6b = data_6.groupby('Facility Name')[['TX_CURR','Biometrics Captured', 'Biometrics Recaptured']].sum()   
        data_6b_curr=data_6b.reset_index()  

        def get_map_tx_curr(fac_name_name):
            # Function to get the TX_CURR value for a given LGA
            tx_curr_values = tx_curr_temp_tbl.groupby('Facility Name')['TX_CURR'].sum()
            return tx_curr_values.get(fac_name_name, "N/A")
                    
        def get_map_tx_curr2(fac_name_name):
            # Convert list to dictionary
            tx_curr_cap_dict = dict(zip(data_6b_curr['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Captured'] / data_6b_curr['TX_CURR']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_curr_cap_dict.get(fac_name_name, "N/A")

        def get_map_tx_curr3(fac_name_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_curr_recap_dict = dict(zip(data_6b_curr['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Recaptured'] / data_6b_curr['Biometrics Captured']) * 100, decimals=1))))
            return tx_curr_recap_dict.get(fac_name_name, "N/A")
        
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Treatment Current Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))

        folium.Choropleth(
            geo_data=filtered_geo_data, name='choropleth', data=data_6b_curr, columns=['Facility Name', 'TX_CURR'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_CURR', highlight=True).add_to(ng_map)

        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_CURR: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''        
        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = tx_curr_temp_tbl[tx_curr_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_lgas(selected_lgas)
        
        for loc in locations:
            tx_curr_value = get_map_tx_curr(loc["popup"])
            tx_curr_formatted = format_with_thousand_separator(tx_curr_value)            
            tx_curr_cap_dict = get_map_tx_curr2(loc["popup"])
            tx_curr_recap_dict = get_map_tx_curr3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_curr_formatted, 
                                                tx_curr_cap_dict, 
                                                tx_curr_recap_dict) 
            
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_curr)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_curr_button_json_lga = json_item(export_button)
        # Convert map to HTML
        plot17_html_lga = ng_map.get_root().render()      

        ####################### DATATABLE ######################################################################################
        plot19_html_lga = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_lga_curr_dict,
            'achieved': achieved_tx_curr_dict_lga,
            'achieved_pbs': achieved_pbs_curr_dict_lga,
            'percent_pbs': percent_pbs_curr_dict_lga,
            'achieved_recapture': achieved_pbs_rec_tx_curr_dict_lga,
            'percent_recaptured': percent_pbs_rec_tx_curr_dict_lga,
            'plot1': {'main': plot1_html_lga, 'additional': button_json_lga},
            'plot2': plot2_html_lga,
            'plot3': plot3_html_lga,
            'plot4': plot4_html_lga,
            'plot5': plot5_html_lga,
            'plot6': plot6_html_lga,
            'plot9': plot9_html_lga,
            'plot17': {'main': plot17_html_lga, 'additional': tx_curr_button_json_lga}, 
            'plot19': plot19_html_lga
        }   


    elif (selected_indicator == 'TX_NEW' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_new_temp_tbl[tx_new_temp_tbl['LGA'].isin(selected_lgas)]
        # Number of facilities
        fac_num_tx_new_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_new_dict = int(data_1['TX_NEW'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_new_dict = int(data_1['TX_NEW Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_new_dict > 0:
            pbs_new_percent = (achieved_pbs_tx_new_dict / achieved_tx_new_dict) * 100
            percent_pbs_tx_new_dict = f"{pbs_new_percent:.1f}"        
        else:
            percent_pbs_tx_new_dict = None   
        # Biometrics Recaptured
        achieved_pbs_rec_tx_new_dict = int(data_1['TX_NEW Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_new_dict > 0:
            pbs_rec_tx_new_percent = (achieved_pbs_rec_tx_new_dict / achieved_pbs_tx_new_dict) * 100
            percent_pbs_rec_tx_new_dict = f"{pbs_rec_tx_new_percent:.1f}"       
        else:
            percent_pbs_rec_tx_new_dict = None      
        ############################################################################################
        # Handle data elements from the line list table
        data_2 = df_new_list[df_new_list['LGA'].isin(selected_lgas)]        
        # Treatment New By Pediatric & Adult Clients & Sex
        data_4 = df_new_list[df_new_list['LGA'].isin(selected_lgas)]
        longfm1_lga_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_new_widefm2_lga_age_sex = longfm1_lga_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_NEW')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New By Pediatric & Adult Clients & Sex' 
        plot1=tx_new_widefm2_lga_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_NEW', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the New document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_new_widefm2_lga_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment New CD4 Distribution
        data_5 = df_cd4_new_list[df_cd4_new_list['LGA'].isin(selected_lgas)]        
        data_5agg = data_5.TX_NEW_CD4.value_counts().reset_index().rename(columns={'index':'TX_NEW_CD4', 'TX_NEW_CD4':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        value = data_5b["value"].values
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]        
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b) 
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New By CD4 Count' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW_CD4: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW_CD4', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
                        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")

        
        # Treatment New By AgeGroup & Sex
        age_group_tx_new = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_new = age_group_tx_new.set_index('AgeGroup')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New By 5-Year Age Band & Sex' 
        plot3 = age_group_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.x_range.start = 0
        plot3.toolbar.logo = None   
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment New By Age Group & Sex
        data_3 = df_pbs_new_list[df_pbs_new_list['LGA'].isin(selected_lgas)]
        age_group_pbs_tx_new = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_tx_new = age_group_pbs_tx_new.set_index('AgeGroup')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New Biometrics By 5-Year Age Band & Sex' 
        plot4 = age_group_pbs_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None   
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_pbs_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new pbs by age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")               


        # TX_NEW By Month 
        data_8 = df_new_list[df_new_list['LGA'].isin(selected_lgas)]
        data_8agg = data_8.TX_NEW_month.value_counts().reset_index().rename(columns={'index':'TX_NEW_month', 'TX_NEW_month':'value'})
        data_8_count = data_8agg.copy()
        data_8_count['formatted_value']=["{:,.0f}".format(val) for val in data_8_count['value']]    
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} TX_NEW By Month'     
        plot5new_days=data_8_count.hvplot.bar(x="TX_NEW_month", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='',  width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW_month")                                

        labels = hv.Labels(data=data_8_count, kdims=['TX_NEW_month', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by month.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotnew_month_html = file_html((bokeh_model, export_button), CDN, "plot5")


        # Treatment New in Month 1 By AgeGroup & Sex
        data_9 = df_new_listmth1[df_new_listmth1['LGA'].isin(selected_lgas)]
        age_sex_tx_new_month1 = pd.crosstab(data_9['AgeGroup'], data_9['Sex']).reset_index()
        age_sex_tx_new_month1 = age_sex_tx_new_month1.set_index('AgeGroup')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New In Month 1 By 5-Year Age Band & Sex'           
        if not age_sex_tx_new_month1.empty:
            plot6 = age_sex_tx_new_month1.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
            # Set the width and height of the plot
            plot6.plot.width = plot_width
            # Adjusting toolbar size
            plot6.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot6.x_range.start = 0
            plot6.toolbar.logo = None    
            plot6.toolbar.active_scroll = None
            plot6.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month1)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 1 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot6_html = file_html((plot6, export_button), CDN, "plot6")
        else:
            # Handle the empty data case
            plot6_html = "No data available to plot."     
        

        # Treatment New in Month 2 By AgeGroup & Sex
        data_10 = df_new_listmth2[df_new_listmth2['LGA'].isin(selected_lgas)]
        age_sex_tx_new_month2 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month2 = age_sex_tx_new_month2.set_index('AgeGroup')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New In Month 2 By 5-Year Age Band & Sex'           
        if not age_sex_tx_new_month2.empty:
            plot9 = age_sex_tx_new_month2.plot_bokeh.bar(title=plot_title, legend = "top_right",line_width=8.0, show_figure=False) 
            # Set the width and height of the plot
            plot9.plot.width = 800
            # Adjusting toolbar size
            plot9.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot9.y_range.start = 0
            plot9.toolbar.logo = None    
            plot9.toolbar.active_scroll = None
            plot9.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month2)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 2 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot9_html = file_html((plot9, export_button), CDN, "plot9")
        else:
            # Handle the empty data case
            plot9_html = "No data available to plot."    
        

        # Treatment New in Month 3 By AgeGroup & Sex
        data_10 = df_new_listmth3[df_new_listmth3['LGA'].isin(selected_lgas)]
        age_sex_tx_new_month3 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month3 = age_sex_tx_new_month3.set_index('AgeGroup')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New In Month 3 By 5-Year Age Band & Sex'    
        if not age_sex_tx_new_month3.empty:
            plot10 = age_sex_tx_new_month3.plot_bokeh.bar(title=plot_title, legend="top_right", line_width=8.0, show_figure=False)
            # Set the width and height of the plot
            plot10.plot.width = 800
            # Adjusting toolbar size
            plot10.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot10.y_range.start = 0
            plot10.toolbar.logo = None   
            plot10.toolbar.active_scroll = None
            plot10.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month3)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 3 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot10_html = file_html((plot10, export_button), CDN, "plot10")
        else:
            # Handle the empty data case
            plot10_html = "No data available to plot."     
        
                                       
        # Treatment New ML Distribution
        data_7 = df_ml_new_list[df_ml_new_list['LGA'].isin(selected_lgas)]        
        data_7agg = data_7['TX_NEW ML'].value_counts().reset_index().rename(columns={'index':'TX_NEW ML', 'TX_NEW ML':'value'})
        data_7b = data_7agg.copy()
        if not data_7b.empty:
            total_count = data_7b['value'].sum()
            value = data_7b["value"].values
            data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
            data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
            data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.28
            data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.28
            data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
            data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
            data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
            data_7b['percentage'] = (data_7b['value'] / total_count) * 100
            data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
            # Define the Spectral color palette with supported sizes
            supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
            # Function to get the closest supported size for the Spectral palette
            def get_closest_palette_size(num_colors):
                return min(supported_sizes, key=lambda x: abs(x - num_colors))        
            # Get the closest supported size for the Spectral palette
            num_colors = len(data_7b)
            closest_size = get_closest_palette_size(num_colors)
            color_palette = Spectral[closest_size]
            # Repeat colors if there are more items than colors in the palette
            if num_colors > closest_size:
                color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

            data_7b['color'] = color_palette[:len(data_7b)]    
            # Pad the 'value' column with spaces to improve label alignment
            data_7b["value"] = data_7b['value'].astype(str)
            # Convert DataFrame to ColumnDataSource
            source = ColumnDataSource(data_7b)
            # Create a title string that includes the selected LGA(s)
            lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
            plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(lga_name, total_count)
            # Creating chart vertical
            chart = figure(height=height, width=620, title=plot_title, 
                            toolbar_location="above",  # Show toolbar above the plot
                            tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                            tooltips="@TX_NEW ML: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
            # Creating sectors
            chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                                start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                                line_color="white", fill_color='color', legend_field='TX_NEW ML', source=source)
            # Adding labels
            labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-9, source=source, render_mode='canvas',text_align="center", angle=0,
                    text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
            percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-9, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')

            chart.add_layout(labels)
            chart.add_layout(percentage_labels)
            # Clearing interface
            chart.axis.axis_label=None
            chart.axis.visible=False
            chart.grid.grid_line_color = None
            # Remove Bokeh logo from the toolbar
            chart.toolbar.logo = None
            # Adjusting toolbar size
            chart.toolbar.autohide = True
            # Adjusting legend label size
            chart.legend.label_text_font_size = '9pt'
            chart.outline_line_color = None        
            # Create csv table for export
            source = ColumnDataSource(data_7agg)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'tx_new ml.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot11_html = file_html((chart, export_button), CDN, "plot11")     
        else:
            # Handle the empty data case
            plot11_html = "No Treatment New Mortality & Loss (TX_NEW ML) data available to plot."   


        # Treatment New Distribution By Facility
        data_11 = tx_new_temp_tbl[tx_new_temp_tbl['LGA'].isin(selected_lgas)] 
        data_11agg = data_11.groupby('Facility Name')[['TX_NEW']].sum().reset_index()    
        data_11_sum = data_11agg.copy()
        data_11_sum['formatted_value']=["{:,.0f}".format(val) for val in data_11_sum['TX_NEW']]   
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment New By Facility'     
        plot9=data_11_sum.hvplot.bar(x="Facility Name", y='TX_NEW', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW")                                

        labels = hv.Labels(data=data_11_sum, kdims=['Facility Name', 'TX_NEW'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_11agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'TX_NEW by facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html_lga = file_html((bokeh_model, export_button), CDN, "plot12")    


        data_6 = tx_new_temp_tbl[tx_new_temp_tbl['LGA'].isin(selected_lgas)]   
        data_6b = data_6.groupby('Facility Name')['TX_NEW', 'TX_NEW month 1','TX_NEW month 2', 'TX_NEW month 3'].sum()   
        data_6b_new=data_6b.reset_index() 

        def get_map_tx_new(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_values = data_6b_new.groupby('Facility Name')['TX_NEW'].sum()
            return tx_new_values.get(lga_name, "N/A")
        
        def get_map_tx_new_month_1(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_month_1 = data_6b_new.groupby('Facility Name')['TX_NEW month 1'].sum()
            return tx_new_month_1.get(lga_name, "N/A")
        
        def get_map_tx_new_month_2(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_month_2 = data_6b_new.groupby('Facility Name')['TX_NEW month 2'].sum()
            return tx_new_month_2.get(lga_name, "N/A")
        
        def get_map_tx_new_month_3(lga_name):
            # Function to get the TX_NEW value for a given LGA
            tx_new_month_3 = data_6b_new.groupby('Facility Name')['TX_NEW month 3'].sum()
            return tx_new_month_3.get(lga_name, "N/A")

        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Treatment New Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_new, columns=['Facility Name', 'TX_NEW'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_NEW', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_NEW: {}<br>
                Month 1: {}<br>
                Month 2: {}<br>
                Month 3: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = tx_new_temp_tbl[tx_new_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_new_value = get_map_tx_new(loc["popup"])
            tx_new_formatted = format_with_thousand_separator(tx_new_value)  
            tx_new_month_1 = get_map_tx_new_month_1(loc["popup"])
            tx_new_mth_1_formatted = format_with_thousand_separator(tx_new_month_1) 

            tx_new_month_2 = get_map_tx_new_month_2(loc["popup"])
            tx_new_mth_2_formatted = format_with_thousand_separator(tx_new_month_2) 

            tx_new_month_3 = get_map_tx_new_month_3(loc["popup"])
            tx_new_mth_3_formatted = format_with_thousand_separator(tx_new_month_3)             
            
            popup_content = popup_style.format(loc["popup"], tx_new_formatted, tx_new_mth_1_formatted,
                                               tx_new_mth_2_formatted, tx_new_mth_3_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_new)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_new_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()
        

        ####################### DATATABLE ######################################################################################
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)          

        data_response = {
            'fac_num': fac_num_tx_new_dict,
            'achieved': achieved_tx_new_dict,
            'achieved_pbs': achieved_pbs_tx_new_dict,
            'percent_pbs': percent_pbs_tx_new_dict,
            'achieved_recapture': achieved_pbs_rec_tx_new_dict,
            'percent_recaptured': percent_pbs_rec_tx_new_dict,
            'plot1': {'main': plot1_html, 'additional': button_json}, 
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plotnew_month_html,
            'plot6': plot6_html, 
            'plot9': plot9_html,  
            'plot10': plot10_html, 
            'plot11': plot11_html,        
            'plot12': plot12_html_lga,   
            'plot17': {'main': plot17_html, 'additional': tx_new_button_json}, 
            'plot19': plot19_html
        }       


    elif (selected_indicator == 'TX_ML' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment ml indicator
        data_1 = tx_ml_df[tx_ml_df['LGA'].isin(selected_lgas)]
        # Number of facilities
        fac_num_tx_ml_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_ml_dict = int(data_1['TX_ML'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_ml_dict = int(data_1['TX_ML Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_ml_dict > 0:
            pbs_ml_percent = (achieved_pbs_tx_ml_dict / achieved_tx_ml_dict) * 100
            percent_pbs_tx_ml_dict = f"{pbs_ml_percent:.1f}"        
        else:
            percent_pbs_tx_ml_dict = None   
        # Biometrics Recaptured
        achieved_pbs_rec_tx_ml_dict = int(data_1['TX_ML Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_ml_dict > 0:
            pbs_rec_tx_ml_percent = (achieved_pbs_rec_tx_ml_dict / achieved_pbs_tx_ml_dict) * 100
            percent_pbs_rec_tx_ml_dict = f"{pbs_rec_tx_ml_percent:.1f}"     
        else:
            percent_pbs_rec_tx_ml_dict = None      
        #################################################################################################
        # Treatment Mortality & Loss By Pediatric & Adult Clients & Sex
        data_4 = df_ml_list[df_ml_list['LGA'].isin(selected_lgas)]
        longfm1_lga_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_ml_widefm2_lga_age_sex = longfm1_lga_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_ML')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Mortality & Loss By Pediatric & Adult Clients & Sex' 
        plot1ml=tx_ml_widefm2_lga_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title=plot_title).opts(
                                        hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model
        bokeh_model = hv.render(plot1ml, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_ML', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_ml_widefm2_lga_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)      
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment Mortality & Loss Outcomes
        data_5 = df_ml_2_list[df_ml_2_list['LGA'].isin(selected_lgas)]        
        data_5agg = data_5.TX_ML_Outcome_2.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome_2', 'TX_ML_Outcome_2':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)] 
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        # Format the 'value' column with thousand separators
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        # Pad the 'value' column with spaces to improve label alignment
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Treatment Mortality & Loss Outcomes' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,box_zoom,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome_2: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome_2', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-15, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-15, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml outcomes.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")        

        
        # Interrution in Treatment By Age Group & Sex 
        data_4b = df_ml_iit_list[df_ml_iit_list['LGA'].isin(selected_lgas)]
        age_group_iit = pd.crosstab(data_4b['AgeGroup'], data_4b['Sex']).reset_index()
        age_group_iit = age_group_iit.set_index('AgeGroup')
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} IIT By 5-Year Age Band & Sex' 
        plot4 = age_group_iit.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None  
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_iit)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT By 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")


        # Interrution in Treatment in Days 
        data_4c = df_ml_iit_days_list[df_ml_iit_days_list['LGA'].isin(selected_lgas)]
        data_4agg = data_4c.IIT_duration_days.value_counts().reset_index().rename(columns={'index':'IIT_duration_days', 'IIT_duration_days':'value'})
        data_4c_count = data_4agg.copy()
        # Define the custom order
        custom_order = ['IIT for â‰¤30 days', 'IIT for 31 to 60 days', 'IIT for 61 to 180 days', 'IIT for >180 days']
        # Convert the IIT_duration_days column to a categorical type with the custom order
        data_4c_count['IIT_duration_days'] = pd.Categorical(data_4c_count['IIT_duration_days'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order   
        data_4c_count = data_4c_count.sort_values('IIT_duration_days')         
        data_4c_count['formatted_value']=["{:,.0f}".format(val) for val in data_4c_count['value']]  
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} IIT Duration (Days)'       
        plot1iit_days=data_4c_count.hvplot.bar(x="IIT_duration_days", y='value', height=height, color='#6d99ff', grid=True, rot=30, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')                             
        
        labels = hv.Labels(data=data_4c_count, kdims=['IIT_duration_days', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_iit = plot1iit_days * labels
        bokeh_model = hv.render(plot_iit, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(data_4agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT duration in days.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotiit_days_html = file_html((bokeh_model, export_button), CDN, "plot4")

   
        # LGA level IIT Rate
        tx_ml_df_lga = tx_ml_df[tx_ml_df['LGA'].isin(selected_lgas)]
        tx_ml_df_lga = tx_ml_df_lga.groupby('LGA', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_lga['IIT Rate (%)'] = np.round((tx_ml_df_lga['IIT'] / tx_ml_df_lga['TX_CURR']) * 100, decimals=1)
        data_7 = tx_ml_df_lga.copy()
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} IIT Rate'   
        # Create a new plot with a title and axis labels 700
        p = figure(x_range=FactorRange(*source.data['LGA']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="above")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('LGA', -0.3, range=p.x_range), top='TX_CURR', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('LGA', -0.1, range=p.x_range), top='IIT', width=0.18, source=source,
                                    color="#71aebf", legend_label="IIT")}        
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))
        # Add labels for bars
        p.text(x=dodge('LGA', -0.3, range=p.x_range), y='TX_CURR', text='TX_CURR',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('LGA', -0.1, range=p.x_range), y='IIT', text='IIT',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.2]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('LGA', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        # Format y-axis labels with thousands separators
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 
        # Hide the toolbar
        p.toolbar.autohide = True
        # Adjusting legend label size
        p.legend.label_text_font_size = '10pt'
        # Position the legend outside the plot area 
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        p.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'overall LGA IIT rate.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((p, export_button), CDN, "plot5")


        data_8 = tx_ml_df_lga_mmd[tx_ml_df_lga_mmd['LGA'].isin(selected_lgas)]    
        # Define the data source
        source = ColumnDataSource(data_8)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} % IIT By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('mmd', -0.2, range=p.x_range), top='TX_CURR', width=0.2, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('mmd', 0.1, range=p.x_range), top='IIT', width=0.2, source=source,
                color="#71aebf", legend_label="IIT")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('mmd', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('mmd', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.legend.label_text_font_size = '10pt'
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        p.toolbar.logo = None
        p.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_8)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((p, export_button), CDN, "plot6")        


        # % IIT By Supported Facilities
        data_9 = tx_ml_df[tx_ml_df['LGA'].isin(selected_lgas)]  
        tx_ml_df_lga = data_9.groupby('Facility Name', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_lga['IIT Rate (%)'] = np.round((tx_ml_df_lga['IIT'] / tx_ml_df_lga['TX_CURR']) * 100, decimals=1)   
        # Define the data source
        source = ColumnDataSource(tx_ml_df_lga)
        LGAs = source.data["Facility Name"]
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} % IIT By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=LGAs, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('Facility Name', -0.2, range=p.x_range), top='TX_CURR', width=0.25, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('Facility Name', 0.1, range=p.x_range), top='IIT', width=0.25, source=source,
                color="#71aebf", legend_label="IIT")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', "@{Facility Name}"), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('Facility Name', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('Facility Name', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.05]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '10pt'        
        p.add_layout(p.legend[0], 'right')
        p.legend.click_policy = "hide"
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(tx_ml_df_lga)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((p, export_button), CDN, "plot9")


        # Interrution in Treatment Distribution
        data_7 = df_ml_iit_list[df_ml_iit_list['LGA'].isin(selected_lgas)]        
        data_7agg = data_7.TX_ML_Outcome.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome', 'TX_ML_Outcome':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.27
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.27
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]       
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(lga_name, total_count)
        # Creating chart vertical
        chart = figure(height=height, width=620, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot10_html = file_html((chart, export_button), CDN, "plot10") 

        
        data_6 = tx_ml_df[tx_ml_df['LGA'].isin(selected_lgas)]    
        data_6b = data_6.groupby('Facility Name')['TX_ML','IIT', 'Stopped Treatment', 'Transferred Out', 'Dead'].sum() 
        data_6b_df = data_6b.reset_index()
        def get_map_tx_ml(lga_name):
            # Function to get the TX_ML value for facilities in a given LGA
            tx_ml_values = data_6b_df.groupby('Facility Name')['TX_ML'].sum()
            return tx_ml_values.get(lga_name, "N/A")
        
        def get_map_tx_ml_iit(lga_name):
            # Function to get the IIT value for a given LGA
            tx_ml_iit = data_6b_df.groupby('Facility Name')['IIT'].sum()
            return tx_ml_iit.get(lga_name, "N/A")
        
        def get_map_tx_ml_stopped(lga_name):
            # Function to get the Stopped value for a given LGA
            tx_ml_stopped = data_6b_df.groupby('Facility Name')['Stopped Treatment'].sum()
            return tx_ml_stopped.get(lga_name, "N/A")
        
        def get_map_tx_ml_to(lga_name):
            # Function to get the Transferred Out value for a given LGA
            tx_ml_to = data_6b_df.groupby('Facility Name')['Transferred Out'].sum()
            return tx_ml_to.get(lga_name, "N/A")
        
        def get_map_tx_ml_dead(lga_name):
            # Function to get the Dead value for a given LGA
            tx_ml_dead = data_6b_df.groupby('Facility Name')['Dead'].sum()
            return tx_ml_dead.get(lga_name, "N/A")
   
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)     

        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Treatment Mortality & Loss Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['Facility Name', 'TX_ML'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_ML', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_ML: {}<br>
                IIT: {}<br>
                Stopped: {}<br>
                Transferred Out: {}<br>
                Dead: {}
            </div>
        '''

        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):            
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = tx_ml_df_sorted[tx_ml_df_sorted['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations        
        
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_ml_value = get_map_tx_ml(loc["popup"])
            tx_ml_formatted = format_with_thousand_separator(tx_ml_value)   
            tx_ml_iit = get_map_tx_ml_iit(loc["popup"])
            tx_ml_iit_formatted = format_with_thousand_separator(tx_ml_iit)  

            tx_ml_stopped = get_map_tx_ml_stopped(loc["popup"])
            tx_ml_stopped_formatted = format_with_thousand_separator(tx_ml_stopped) 

            tx_ml_to = get_map_tx_ml_to(loc["popup"])
            tx_ml_to_formatted = format_with_thousand_separator(tx_ml_to) 

            tx_ml_dead = get_map_tx_ml_dead(loc["popup"])
            tx_ml_dead_formatted = format_with_thousand_separator(tx_ml_dead) 

            popup_content = popup_style.format(loc["popup"], tx_ml_formatted, tx_ml_iit_formatted, tx_ml_stopped_formatted, 
                                               tx_ml_to_formatted, tx_ml_dead_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_ml_button_json = json_item(export_button)  
        plot17_html = ng_map.get_root().render()       
   
        
    ####################### DATATABLE ######################################################################################
        plot19_html = data_6.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)
        
        data_response = {
            'fac_num': fac_num_tx_ml_dict,
            'achieved': achieved_tx_ml_dict,
            'achieved_pbs': achieved_pbs_tx_ml_dict,
            'percent_pbs': percent_pbs_tx_ml_dict,
            'achieved_recapture': achieved_pbs_rec_tx_ml_dict,
            'percent_recaptured': percent_pbs_rec_tx_ml_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot4_html,
            'plot4': plotiit_days_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': tx_ml_button_json}, 
            'plot19': plot19_html
        }               
    

    elif (selected_indicator == 'TX_RTT' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['LGA'].isin(selected_lgas)]
        # Number of facilities
        fac_num_tx_rtt_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_rtt_dict = int(data_1['TX_RTT'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_rtt_dict = int(data_1['TX_RTT Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_rtt_dict > 0:
            pbs_rtt_percent = (achieved_pbs_tx_rtt_dict / achieved_tx_rtt_dict) * 100
            percent_pbs_tx_rtt_dict = f"{pbs_rtt_percent:.1f}"  
        else:
            percent_pbs_tx_rtt_dict = None       
        # Biometrics Recaptured
        achieved_pbs_rec_tx_rtt_dict = int(data_1['TX_RTT Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_rtt_dict > 0:
            pbs_rec_tx_rtt_percent = (achieved_pbs_rec_tx_rtt_dict / achieved_pbs_tx_rtt_dict) * 100
            percent_pbs_rec_tx_rtt_dict = f"{pbs_rec_tx_rtt_percent:.1f}"    
        else:
            percent_pbs_rec_tx_rtt_dict = None             
        ############################################################################################
        # Returned To Treatment Distribution By Sex 
        data_2 = df_rtt_list[df_rtt_list['LGA'].isin(selected_lgas)]        
        data_2agg = data_2.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_2b = data_2agg.copy()
        total_count = data_2b['value'].sum()
        data_2b['angle'] = data_2b['value'] / total_count * 2 * pi
        value = data_2b["value"].values
        data_2b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_2b['cos'] = np.cos(data_2b['cumulative_angle']) * 0.32
        data_2b['sin'] = np.sin(data_2b['cumulative_angle']) * 0.32
        data_2b['cos2'] = np.cos(data_2b['cumulative_angle']) * 0.41
        data_2b['sin2'] = np.sin(data_2b['cumulative_angle']) * 0.41
        data_2b['formatted_value']=["{:,.0f}".format(val) for val in data_2b['value']]
        data_2b['percentage'] = (data_2b['value'] / total_count) * 100
        data_2b['label']=["({:.1f}%)".format(val) for val in data_2b['percentage']]
        data_2b['color'] = ['#2b9eea', '#2beaea'] 
        # Pad the 'value' column with spaces to improve label alignment
        data_2b["value"] = data_2b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_2b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Returned To Treatment By Sex' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_2agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((chart, export_button), CDN, "plot3")


        # Returned To Treatment Distribution
        data_3 = df_rtt_list[df_rtt_list['LGA'].isin(selected_lgas)]        
        data_3agg = data_3.TX_RTT_Outcome.value_counts().reset_index().rename(columns={'index':'TX_RTT_Outcome', 'TX_RTT_Outcome':'value'})
        data_3b = data_3agg.copy()
        total_count = data_3b['value'].sum()
        value = data_3b["value"].values
        data_3b['angle'] = data_3b['value'] / total_count * 2 * pi
        data_3b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_3b['cos'] = np.cos(data_3b['cumulative_angle']) * 0.27
        data_3b['sin'] = np.sin(data_3b['cumulative_angle']) * 0.27
        data_3b['cos2'] = np.cos(data_3b['cumulative_angle']) * 0.35
        data_3b['sin2'] = np.sin(data_3b['cumulative_angle']) * 0.35
        data_3b['formatted_value']=["{:,.0f}".format(val) for val in data_3b['value']]
        data_3b['percentage'] = (data_3b['value'] / total_count) * 100
        data_3b['label']=["({:.1f}%)".format(val) for val in data_3b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_3b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_3b['color'] = color_palette[:len(data_3b)]              
        # Pad the 'value' column with spaces to improve label alignment
        data_3b["value"] = data_3b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Creating chart vertical
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = "{} Returned To Treatment (TX_RTT) Total = {:,.0f}".format(lga_name, total_count)
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@TX_RTT_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_RTT_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_3agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot4_html = file_html((chart, export_button), CDN, "plot4")


        # Returned To Treatment By AgeGroup & Sex        
        age_group_tx_rtt = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_tx_rtt = age_group_tx_rtt.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_rtt)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Returned To Treatment By 5-Year Age Band & Sex' 
        plot5 = age_group_tx_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot5.plot.width = plot_width
        # Adjusting toolbar size
        plot5.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot5.x_range.start = 0
        plot5.toolbar.logo = None    
        plot5.toolbar.active_scroll = None
        plot5.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_rtt)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh plot to HTML
        plot5_html = file_html((plot5, export_button), CDN, "plot5")        


        # Returned To Treatment By Age Group & Sex (Biometrics)
        # Filter the data
        data_4 = rtt_pbs_list[rtt_pbs_list['LGA'].isin(selected_lgas)]
        # Create crosstab
        age_group_pbs_rtt = pd.crosstab(data_4['AgeGroup'], data_4['Sex']).reset_index()
        age_group_pbs_rtt = age_group_pbs_rtt.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_rtt)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} TX_RTT Biometrics Captured By 5-Year Age Band & Sex' 
        # Plot 
        plot4 = age_group_pbs_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0        
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_rtt 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot4, export_button), CDN, "plot6")


        # Returned To Treatment MMD Distribution
        data_5 = df_rtt_list[df_rtt_list['LGA'].isin(selected_lgas)]  
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        # Define the custom order
        custom_order = ['MMD <3', 'MMD 3', 'MMD 4-5', 'MMD 6']
        # Convert the mmd column to a categorical type with the custom order
        data_5agg['mmd'] = pd.Categorical(data_5agg['mmd'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order
        data_5agg = data_5agg.sort_values('mmd')
        data_5_count = data_5agg.copy()
        data_5_count['formatted_value'] = ["{:,.0f}".format(val) for val in data_5_count['value']]
        # Define colors for each bar
        colors = ['#ff6f61', '#6aff99', '#6d99ff', '#aa66cc']
        data_5_count['color'] = colors[:len(data_5_count)]
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Returned To Treatment By MMD' 
        # Create the bar plot
        plot5new_days = data_5_count.hvplot.barh(
            x="mmd", y='value', height=height, color='color', grid=True, xlabel='', line_color=None, fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, 
            ylabel='', width=plot_width, title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')

        # Add labels
        labels = hv.Labels(data=data_5_count, kdims=['mmd', 'value'], vdims='formatted_value')
        # Overlay labels on the bar plot
        plot_new = plot5new_days * labels
        # Get the underlying Bokeh plot
        bokeh_plot = hv.render(plot_new)
        # Format the x-axis with a thousand separator
        bokeh_plot.xaxis[0].formatter = NumeralTickFormatter(format="0,0")         
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)

        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot7_html = file_html((bokeh_plot, export_button), CDN, "plot7")           

        
        # Returned To Treatment CD4 Distribution
        data_6 = rtt_cd4_list[rtt_cd4_list['LGA'].isin(selected_lgas)]
        data_6agg = data_6.TX_RTT_CD4.value_counts().reset_index().rename(columns={'index':'TX_RTT_CD4', 'TX_RTT_CD4':'value'})
        data_6_count = data_6agg.copy()
        data_6_count['formatted_value']=["{:,.0f}".format(val) for val in data_6_count['value']]    
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Returned To Treatment By CD4 Count'     
        plot5new_days=data_6_count.hvplot.bar(x="TX_RTT_CD4", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT_CD4")                                

        labels = hv.Labels(data=data_6_count, kdims=['TX_RTT_CD4', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_6agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot8_html = file_html((bokeh_model, export_button), CDN, "plot8")   


        # Returned To Treatment Distribution By LGA
        data_8 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['LGA'].isin(selected_lgas)] 
        data_8agg = data_8.groupby('Facility Name')[['TX_RTT']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_RTT']]   
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Returned To Treatment By Facility'     
        plot9=data_8_sum.hvplot.bar(x="Facility Name", y='TX_RTT', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT")                                

        labels = hv.Labels(data=data_8_sum, kdims=['Facility Name', 'TX_RTT'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # # Add HoverTool with formatted tooltips
        # hover = HoverTool()
        # hover.tooltips = [("Facility", "@{Facility Name}"), ("TX_RTT", "@TX_RTT{0,0}")]
        # bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((bokeh_model, export_button), CDN, "plot9")          


        data_7 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['LGA'].isin(selected_lgas)]  
        data_7b_rtt = data_7.groupby('Facility Name', as_index=True)[['TX_RTT','TX_RTT Captured', 'TX_RTT Recaptured']].sum()   
        data_7b_rtt=data_7b_rtt.reset_index()  

        def get_map_tx_rtt(lga_name):
            # Function to get the TX_RTT value for Facilities in a given LGA
            tx_rtt_values = data_7b_rtt.groupby('Facility Name')['TX_RTT'].sum()            
            return tx_rtt_values.get(lga_name, "N/A")
        
        def get_map_tx_rtt2(lga_name):
            # Convert list to dictionary
            tx_rtt_cap_dict = dict(zip(data_7b_rtt['Facility Name'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Captured'] / data_7b_rtt['TX_RTT']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_rtt_cap_dict.get(lga_name, "N/A")

        def get_map_tx_rtt3(lga_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_rtt_recap_dict = dict(zip(data_7b_rtt['Facility Name'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Recaptured'] / data_7b_rtt['TX_RTT Captured']) * 100, decimals=1))))
            return tx_rtt_recap_dict.get(lga_name, "N/A")
        
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Returned To Treatment Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_7b_rtt, columns=['Facility Name', 'TX_RTT'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_RTT', highlight=True).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_RTT: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''

        # Define a function to get locations for Facilities in the selected LGAs
        def get_locations_for_lgas(selected_lgas):
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = tx_rtt_temp_tbl[tx_rtt_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_rtt_value = get_map_tx_rtt(loc["popup"])
            tx_rtt_formatted = format_with_thousand_separator(tx_rtt_value)            
            tx_rtt_cap_dict = get_map_tx_rtt2(loc["popup"])
            tx_rtt_recap_dict = get_map_tx_rtt3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_rtt_formatted, 
                                                tx_rtt_cap_dict, 
                                                tx_rtt_recap_dict) 
            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Create ColumnDataSource from the DataFrame
        source = ColumnDataSource(data_7b_rtt)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_rtt_button_json = json_item(export_button)
        plot17_html = ng_map.get_root().render() 

        ####################### DATATABLE ######################################################################################
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_rtt_dict,
            'achieved': achieved_tx_rtt_dict,
            'achieved_pbs': achieved_pbs_tx_rtt_dict,
            'percent_pbs': percent_pbs_tx_rtt_dict,
            'achieved_recapture': achieved_pbs_rec_tx_rtt_dict,
            'percent_recaptured': percent_pbs_rec_tx_rtt_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot7': plot7_html,
            'plot8': plot8_html,
            'plot9': plot9_html,
            'plot17': {'main': plot17_html, 'additional': tx_rtt_button_json}, 
            'plot19': plot19_html

        }  


    elif (selected_indicator == 'TX_PVLS' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['LGA'].isin(selected_lgas)]    
        # Number of facilities
        fac_num_tx_pvls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_pvls_dict = int(data_1['TX_PVLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_pvls_dict = int(data_1['TX_PVLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_pvls_dict > 0:
            pbs_tx_pvls_percent = (achieved_pbs_tx_pvls_dict / achieved_tx_pvls_dict) * 100
            percent_pbs_tx_pvls_dict = f"{pbs_tx_pvls_percent:.1f}"        
        else:
            percent_pbs_tx_pvls_dict = None  
        # Biometrics Recaptured
        achieved_pbs_rec_tx_pvls_dict = int(data_1['TX_PVLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_pvls_dict > 0:
            pbs_rec_tx_pvls_percent = (achieved_pbs_rec_tx_pvls_dict / achieved_pbs_tx_pvls_dict) * 100
            percent_pbs_rec_tx_pvls_dict = f"{pbs_rec_tx_pvls_percent:.1f}"     
        else:
            percent_pbs_rec_tx_pvls_dict = None      
        ############################################################################################################
        data_1b = tx_pvls_lga[tx_pvls_lga['LGA'].isin(selected_lgas)] 
        source = ColumnDataSource(data_1b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Viral Load Suppression Performance' 
        # Create a new plot with a title and axis labels 
        plot1 = figure(x_range=FactorRange(*source.data['LGA']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="right")
        # Render bars
        bars = {
            'Eligible for VL': plot1.vbar(x=dodge('LGA', -0.3, range=plot1.x_range), top='Eligible for VL', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': plot1.vbar(x=dodge('LGA', -0.1, range=plot1.x_range), top='TX_PVLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': plot1.vbar(x=dodge('LGA', 0.1, range=plot1.x_range), top='TX_PVLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N)"),
            'Undetected VL <50': plot1.vbar(x=dodge('LGA', 0.3, range=plot1.x_range), top='Undetected VL <50', width=0.18, source=source,
                                            color="#A8B9E2", legend_label="Undetected VL <50")
        }

        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('LGA', -0.3, range=plot1.x_range), y='Eligible for VL', text='Eligible for VL',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', -0.1, range=plot1.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', 0.1, range=plot1.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', 0.3, range=plot1.x_range), y='Undetected VL <50', text='Undetected VL <50',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression', '% Undetected']
        colors = ["Magenta", "green", "blue"]
        dodge_values = [-0.2, 0, 0.2]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '4.5pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below')   #Valid place values are: above, below, left, right or center
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        data_2 = grouped_pvls_lga[grouped_pvls_lga['LGA'].isin(selected_lgas)] 
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Viral Load Coverage & Suppression By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")
             
        
        ############################################################################################
        # Clients' Viral Load Suppression By Age Band
        data_3 = pvls_temp_tbl_all_age_lga[pvls_temp_tbl_all_age_lga['LGA'].isin(selected_lgas)]   
        data_3b = data_3.groupby('AgeGroup')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()    
        data_3b.loc[:, '% Coverage'] = np.round((data_3b['TX_PVLS (D)'] / data_3b['Eligible for VL']) * 100, decimals=1)
        data_3b.loc[:, '% Suppression'] = np.round((data_3b['TX_PVLS (N)'] / data_3b['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Ensure AgeGroup values are unique
        age_groups = data_3['AgeGroup'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f"{lga_name} Clients' Viral Load Suppression By Age Band"
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")

        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible for VL', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             

        source = ColumnDataSource(data_3b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        # Female Clients' Viral Load Suppression By Age Band
        data_4 = pvls_temp_tbl_age_lga_female[pvls_temp_tbl_age_lga_female['LGA'].isin(selected_lgas)]    
        # Define the data source
        source = ColumnDataSource(data_4)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f"{lga_name} Female Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Female)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Female)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Female)"),
            'TX_PVLS (D, Female)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Female)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Female)"),
            'TX_PVLS (N, Female)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Female)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Female)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis        
        # Add value labels  
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Female)', text='Eligible (Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Female)', text='TX_PVLS (D, Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Female)', text='TX_PVLS (N, Female)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Female)', '% Suppression (Female)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_4)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'female tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsf_html = file_html((p, export_button), CDN, "plot10")


        # Male Clients' Viral Load Suppression By Age Band
        data_5 = pvls_temp_tbl_age_lga_male[pvls_temp_tbl_age_lga_male['LGA'].isin(selected_lgas)]    
        # Define the data source
        source = ColumnDataSource(data_5)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f"{lga_name} Male Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Male)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Male)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Male)"),
            'TX_PVLS (D, Male)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Male)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Male)"),
            'TX_PVLS (N, Male)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Male)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Male)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Male)', text='Eligible (Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Male)', text='TX_PVLS (D, Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Male)', text='TX_PVLS (N, Male)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Male)', '% Suppression (Male)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_5)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'male tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsm_html = file_html((p, export_button), CDN, "plot11")


        data_7 = pvls_temp_tbl_all_age_lga[pvls_temp_tbl_all_age_lga['LGA'].isin(selected_lgas)]   
        lga_categories = data_7['FacilityName'].unique()      
        data_7 = data_7.groupby('FacilityName')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()  
        data_7.loc[:, '% Coverage'] = np.round((data_7['TX_PVLS (D)'] / data_7['Eligible for VL']) * 100, decimals=1)
        data_7.loc[:, '% Suppression'] = np.round((data_7['TX_PVLS (N)'] / data_7['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Create a ColumnDataSource
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Viral Load Coverage & Suppression By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html = file_html((p, export_button), CDN, "plot12")


        data_6 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['LGA'].isin(selected_lgas)]  
        data_6b = data_6.groupby('Facility Name')[['Eligible for VL', 'VL sample taken in 1 year', 'TX_PVLS (D)', 'TX_PVLS (N)']].sum() 
        data_6b_df=data_6b.reset_index()   

        def get_map_tx_pvls(lga_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_pvls_values = data_6b_df.groupby('Facility Name')['Eligible for VL'].sum()
            return tx_pvls_values.get(lga_name, "N/A")
        
        def get_map_tx_pvls2(lga_name):
            # Convert list to dictionary
            tx_pvls_cov_dict = dict(zip(data_6b_df['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (D)'] / data_6b_df['Eligible for VL']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_pvls_cov_dict.get(lga_name, "N/A")

        def get_map_tx_pvls3(lga_name):
            # Function to get the TX_PVLS value for a given LGA
            tx_pvls_sup_dict = dict(zip(data_6b_df['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (N)'] / data_6b_df['TX_PVLS (D)']) * 100, decimals=1))))
            return tx_pvls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)        
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['Facility Name', 'Eligible for VL'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name="Patients' Viral Load Suppression (PVLS)", nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):            
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = tx_pvls_temp_tbl[tx_pvls_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations            
        
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            tx_pvls_values = get_map_tx_pvls(loc["popup"])
            tx_pvls_formatted = format_with_thousand_separator(tx_pvls_values)     
            tx_pvls_cov_dict = get_map_tx_pvls2(loc["popup"])
            tx_pvls_sup_dict = get_map_tx_pvls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_pvls_formatted, 
                                                tx_pvls_cov_dict, 
                                                tx_pvls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        tx_pvls_button_json = json_item(export_button)    
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        tx_pvls_lga3b = tx_pvls_lga3[tx_pvls_lga3['LGA'].isin(selected_lgas)] 

        plot18_html = tx_pvls_lga3b.to_html(index=False, classes=['cascade', 'table table-bordered',"display"], escape=False)
        
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_pvls_dict,
            'achieved': achieved_tx_pvls_dict,
            'achieved_pbs': achieved_pbs_tx_pvls_dict,
            'percent_pbs': percent_pbs_tx_pvls_dict,
            'achieved_recapture': achieved_pbs_rec_tx_pvls_dict,
            'percent_recaptured': percent_pbs_rec_tx_pvls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plotvlsf_html,
            'plot11': plotvlsm_html,
            'plot12': plot12_html,
            'plot17': {'main': plot17_html, 'additional': tx_pvls_button_json}, 
            'plot18': plot18_html,
            'plot19': plot19_html
        }      


    elif (selected_indicator == 'PBFW VLS' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['LGA'].isin(selected_lgas)]  
        # Number of facilities
        fac_num_pbfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pbfw_vls_dict = int(data_1['PBFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pbfw_vls_dict = int(data_1['PBFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_pbfw_vls_dict > 0:
            pbs_pbfw_vls_percent = (achieved_pbs_pbfw_vls_dict / achieved_pbfw_vls_dict) * 100
            percent_pbs_pbfw_vls_dict = f"{pbs_pbfw_vls_percent:.1f}"        
        else:
            percent_pbs_pbfw_vls_dict = None  
        # Biometrics Recaptured
        achieved_pbs_rec_pbfw_vls_dict = int(data_1['PBFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_pbfw_vls_dict > 0:
            pbs_rec_pbfw_vls_percent = (achieved_pbs_rec_pbfw_vls_dict / achieved_pbs_pbfw_vls_dict) * 100
            percent_pbs_rec_pbfw_vls_dict = f"{pbs_rec_pbfw_vls_percent:.1f}"  
        else:
            percent_pbs_rec_pbfw_vls_dict = None        
        ############################################################################################
        # Create IP Summary Table
        data_1b = data_1.groupby('LGA', as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PBFW VLS (D)'] / data_1b['PBFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PBFW VLS (N)'] / data_1b['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant & Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['LGA']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PBFW VL Eligible': plot1.vbar(x=dodge('LGA', -0.3, range=plot1.x_range), top='PBFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': plot1.vbar(x=dodge('LGA', -0.1, range=plot1.x_range), top='PBFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': plot1.vbar(x=dodge('LGA', 0.1, range=plot1.x_range), top='PBFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('LGA', -0.3, range=plot1.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', -0.1, range=plot1.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', 0.1, range=plot1.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'LGA' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        data_2 = data_2.groupby(['LGA', 'mmd'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PBFW VLS (D)'] / data_2['PBFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PBFW VLS (N)'] / data_2['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant & Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PBFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pbfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        pbfw_vls_temp_tbl_age = pbfw_vls_temp_tbl_age.groupby(['LGA', 'AgeGroup'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        pbfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (D)'] / pbfw_vls_temp_tbl_age['PBFW VL Eligible']) * 100, decimals=1)
        pbfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (N)'] / pbfw_vls_temp_tbl_age['PBFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pbfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant & Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PBFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PBFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PBFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        # Ensure Facility values are unique
        lga_categories = data_7['FacilityName'].unique()   
        data_7b = data_7.groupby('FacilityName')[['PBFW VL Eligible','PBFW VLS (D)', 'PBFW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PBFW VLS (D)'] / data_7b['PBFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PBFW VLS (N)'] / data_7b['PBFW VLS (D)']) * 100, decimals=1)
        # Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant & Breastfeeding Women VLS By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['LGA'].isin(selected_lgas)]  
        data_6b = data_6.groupby('Facility Name')[['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pbfw_vls(lga_name):
            # Function to get the pbfw_vls value for a given LGA
            pbfw_vls_values = data_6b.groupby('Facility Name')['PBFW VL Eligible'].sum()
            return pbfw_vls_values.get(lga_name, "N/A")
        
        def get_map_pbfw_vls2(lga_name):
            # Convert list to dictionary
            pbfw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (D)'] / data_6b['PBFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pbfw_vls_cov_dict.get(lga_name, "N/A")

        def get_map_pbfw_vls3(lga_name):
            # Function to get the pbfw_vls value for a given LGA
            pbfw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (N)'] / data_6b['PBFW VLS (D)']) * 100, decimals=1))))
            return pbfw_vls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Pregnant & Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'PBFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant & Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations 
        
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            pbfw_vls_values = get_map_pbfw_vls(loc["popup"])
            pbfw_vls_formatted = format_with_thousand_separator(pbfw_vls_values)     
            pbfw_vls_cov_dict = get_map_pbfw_vls2(loc["popup"])
            pbfw_vls_sup_dict = get_map_pbfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pbfw_vls_formatted, 
                                                pbfw_vls_cov_dict, 
                                                pbfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pbfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        pbfw_pvls_temp_tbl_lga = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['LGA'].isin(selected_lgas)] 
        plot19_html = pbfw_pvls_temp_tbl_lga.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pbfw_vls_dict,
            'achieved': achieved_pbfw_vls_dict,
            'achieved_pbs': achieved_pbs_pbfw_vls_dict,
            'percent_pbs': percent_pbs_pbfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pbfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pbfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': pbfw_vls_button_json}, 
            'plot19': plot19_html
        } 


    elif (selected_indicator == 'PW VLS' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['LGA'].isin(selected_lgas)]  
        # Number of facilities
        fac_num_pw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pw_vls_dict = int(data_1['PW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pw_vls_dict = int(data_1['PW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pw_vls_percent = (achieved_pbs_pw_vls_dict / achieved_pw_vls_dict) * 100
        percent_pbs_pw_vls_dict = f"{pbs_pw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pw_vls_dict = int(data_1['PW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pw_vls_percent = (achieved_pbs_rec_pw_vls_dict / achieved_pbs_pw_vls_dict) * 100
        percent_pbs_rec_pw_vls_dict = f"{pbs_rec_pw_vls_percent:.1f}"     
        ############################################################################################ 
        # Create IP Summary Table
        data_1b = data_1.groupby('LGA', as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PW VLS (D)'] / data_1b['PW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PW VLS (N)'] / data_1b['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['LGA']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PW VL Eligible': plot1.vbar(x=dodge('LGA', -0.3, range=plot1.x_range), top='PW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': plot1.vbar(x=dodge('LGA', -0.1, range=plot1.x_range), top='PW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': plot1.vbar(x=dodge('LGA', 0.1, range=plot1.x_range), top='PW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('LGA', -0.3, range=plot1.x_range), y='PW VL Eligible', text='PW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', -0.1, range=plot1.x_range), y='PW VLS (D)', text='PW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', 0.1, range=plot1.x_range), y='PW VLS (N)', text='PW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'LGA' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        data_2 = data_2.groupby(['LGA', 'mmd'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PW VLS (D)'] / data_2['PW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PW VLS (N)'] / data_2['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        pw_vls_temp_tbl_age = pw_vls_temp_tbl_age.groupby(['LGA', 'AgeGroup'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        pw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pw_vls_temp_tbl_age['PW VLS (D)'] / pw_vls_temp_tbl_age['PW VL Eligible']) * 100, decimals=1)
        pw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pw_vls_temp_tbl_age['PW VLS (N)'] / pw_vls_temp_tbl_age['PW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        lga_categories = data_7['FacilityName'].unique() 
        data_7b = data_7.groupby('FacilityName')[['PW VL Eligible','PW VLS (D)', 'PW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PW VLS (D)'] / data_7b['PW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PW VLS (N)'] / data_7b['PW VLS (D)']) * 100, decimals=1)
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Pregnant Women VLS By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['LGA'].isin(selected_lgas)]  
        data_6b = data_6.groupby('Facility Name')[['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pw_vls(lga_name):
            # Function to get the pw_vls value for a given LGA
            pw_vls_values = data_6b.groupby('Facility Name')['PW VL Eligible'].sum()
            return pw_vls_values.get(lga_name, "N/A")
        
        def get_map_pw_vls2(lga_name):
            # Convert list to dictionary
            pw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (D)'] / data_6b['PW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pw_vls_cov_dict.get(lga_name, "N/A")

        def get_map_pw_vls3(lga_name):
            # Function to get the pw_vls value for a given LGA
            pw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (N)'] / data_6b['PW VLS (D)']) * 100, decimals=1))))
            return pw_vls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Pregnant Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'PW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):            
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = pw_pvls_temp_tbl[pw_pvls_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            pw_vls_values = get_map_pw_vls(loc["popup"])
            pw_vls_formatted = format_with_thousand_separator(pw_vls_values)     
            pw_vls_cov_dict = get_map_pw_vls2(loc["popup"])
            pw_vls_sup_dict = get_map_pw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pw_vls_formatted, 
                                                pw_vls_cov_dict, 
                                                pw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        pw_pvls_temp_tbl_lga = pw_pvls_temp_tbl[pw_pvls_temp_tbl['LGA'].isin(selected_lgas)] 
        plot19_html = pw_pvls_temp_tbl_lga.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pw_vls_dict,
            'achieved': achieved_pw_vls_dict,
            'achieved_pbs': achieved_pbs_pw_vls_dict,
            'percent_pbs': percent_pbs_pw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': pw_vls_button_json}, 
            'plot19': plot19_html

        } 


    elif (selected_indicator == 'BFW VLS' and selected_lgas):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['LGA'].isin(selected_lgas)]   
        # Number of facilities
        fac_num_bfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_bfw_vls_dict = int(data_1['BFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_bfw_vls_dict = int(data_1['BFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_bfw_vls_dict > 0:
            pbs_bfw_vls_percent = (achieved_pbs_bfw_vls_dict / achieved_bfw_vls_dict) * 100
            percent_pbs_bfw_vls_dict = f"{pbs_bfw_vls_percent:.1f}"     
        else:
            percent_pbs_bfw_vls_dict = None     
        # Biometrics Recaptured
        achieved_pbs_rec_bfw_vls_dict = int(data_1['BFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_bfw_vls_dict > 0:
            pbs_rec_bfw_vls_percent = (achieved_pbs_rec_bfw_vls_dict / achieved_pbs_bfw_vls_dict) * 100
            percent_pbs_rec_bfw_vls_dict = f"{pbs_rec_bfw_vls_percent:.1f}"     
        else:
            percent_pbs_rec_bfw_vls_dict = None          
        ############################################################################################            
        # Create IP Summary Table
        data_1b = data_1.groupby('LGA', as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['BFW VLS (D)'] / data_1b['BFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['BFW VLS (N)'] / data_1b['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['LGA']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'BFW VL Eligible': plot1.vbar(x=dodge('LGA', -0.3, range=plot1.x_range), top='BFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': plot1.vbar(x=dodge('LGA', -0.1, range=plot1.x_range), top='BFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': plot1.vbar(x=dodge('LGA', 0.1, range=plot1.x_range), top='BFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('LGA', -0.3, range=plot1.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', -0.1, range=plot1.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('LGA', 0.1, range=plot1.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('LGA', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'LGA' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        data_2 = data_2.groupby(['LGA', 'mmd'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['BFW VLS (D)'] / data_2['BFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['BFW VLS (N)'] / data_2['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # BFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        bfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        bfw_vls_temp_tbl_age = bfw_vls_temp_tbl_age.groupby(['LGA', 'AgeGroup'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        bfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (D)'] / bfw_vls_temp_tbl_age['BFW VL Eligible']) * 100, decimals=1)
        bfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (N)'] / bfw_vls_temp_tbl_age['BFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = bfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='BFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='BFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='BFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['LGA'].isin(selected_lgas)] 
        data_7b = data_7.groupby('FacilityName')[['BFW VL Eligible','BFW VLS (D)', 'BFW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['BFW VLS (D)'] / data_7b['BFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['BFW VLS (N)'] / data_7b['BFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        lga_categories = data_7['FacilityName'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        plot_title = f'{lga_name} Breastfeeding Women VLS By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=lga_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['LGA'].isin(selected_lgas)]  
        data_6b = data_6.groupby('Facility Name')[['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_bfw_vls(lga_name):
            # Function to get the bfw_vls value for a given LGA
            bfw_vls_values = data_6b.groupby('Facility Name')['BFW VL Eligible'].sum()
            return bfw_vls_values.get(lga_name, "N/A")
        
        def get_map_bfw_vls2(lga_name):
            # Convert list to dictionary
            bfw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (D)'] / data_6b['BFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return bfw_vls_cov_dict.get(lga_name, "N/A")

        def get_map_bfw_vls3(lga_name):
            # Function to get the bfw_vls value for a given LGA
            bfw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (N)'] / data_6b['BFW VLS (D)']) * 100, decimals=1))))
            return bfw_vls_sup_dict.get(lga_name, "N/A")
        # Load GeoJSON file with Nigeria's LGA boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected LGAs
        def filter_geojson(geo_data, selected_lgas):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_lgas]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_lgas)
        
        # Define coordinates for the center of each LGA and Get the coordinates for the first selected LGA
        lga_center = lga_coordinates.get(selected_lgas[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=lga_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected LGA(s)
        lga_name = ', '.join([f'{lga} LGA' for lga in selected_lgas])
        # Update the HTML title to include the LGA names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{lga_name} Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'BFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected LGAs
        def get_locations_for_lgas(selected_lgas):
            locations = []
            for lga in selected_lgas:
                fac_names_in_lga = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['LGA'] == lga]['Facility Name'].unique()
                for fac_name in fac_names_in_lga:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations    
            
        locations = get_locations_for_lgas(selected_lgas)
        # Add popup and tooltip for each LGA
        for loc in locations:
            bfw_vls_values = get_map_bfw_vls(loc["popup"])
            bfw_vls_formatted = format_with_thousand_separator(bfw_vls_values)     
            bfw_vls_cov_dict = get_map_bfw_vls2(loc["popup"])
            bfw_vls_sup_dict = get_map_bfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                bfw_vls_formatted, 
                                                bfw_vls_cov_dict, 
                                                bfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        bfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        bfw_pvls_temp_tbl_lga = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['LGA'].isin(selected_lgas)] 
        plot19_html = bfw_pvls_temp_tbl_lga.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_bfw_vls_dict,
            'achieved': achieved_bfw_vls_dict,
            'achieved_pbs': achieved_pbs_bfw_vls_dict,
            'percent_pbs': percent_pbs_bfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_bfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_bfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': bfw_vls_button_json}, 
            'plot19': plot19_html

        } 


    ########################## SurgeCommands ###################### SurgeCommands ###################### SurgeCommands ########################
    ########################## SurgeCommands ###################### SurgeCommands ###################### SurgeCommands ########################and selected_states
    elif selected_indicator == 'TX_CURR' and selected_commands:        
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment current indicator for selected SurgeCommands         
        data_1 = tx_curr_temp_tbl[tx_curr_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        # print(data_1, end='\n')
        # Number of facilities
        fac_num_comd_curr_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_curr_dict_comd = int(data_1['TX_CURR'].sum())        
        # Biometrics Captured
        achieved_pbs_curr_dict_comd = int(data_1['Biometrics Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_curr_percent = (achieved_pbs_curr_dict_comd / achieved_tx_curr_dict_comd) * 100
        percent_pbs_curr_dict_comd = f"{pbs_curr_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_curr_dict_comd = int(data_1['Biometrics Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_curr_percent = (achieved_pbs_rec_tx_curr_dict_comd / achieved_pbs_curr_dict_comd) * 100
        percent_pbs_rec_tx_curr_dict_comd = f"{pbs_rec_tx_curr_percent:.1f}"               
        ############################################################################################
        # Handle data elements from the line list table        
        # Treatment Current By Pediatric & Adult Clients & Sex above 
        data_4 = df_curr_list[df_curr_list['SurgeCommand'].isin(selected_commands)]
        longfm1_comd_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_curr_widefm2_comd_age_sex = longfm1_comd_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='CurrentARTStatus_28Days')

        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current By Pediatric & Adult Clients & Sex'

        plot1=tx_curr_widefm2_comd_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                            fontsize={'xticks': 10, 'yticks': 10, 'title': 10},  width=plot_width, height=height, 
                                            title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_CURR', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the current document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_curr_widefm2_comd_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr peed&adult age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html_comd = json_item(bokeh_model)
        button_json_comd = json_item(export_button)
        
                                       
        # Treatment Current Distribution By Sex 
        data_5 = df_curr_list[df_curr_list['SurgeCommand'].isin(selected_commands)]        
        data_5agg = data_5.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b['color'] = ["#2b9eb0", "#9ecae1"]         
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current By Sex'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html_comd = file_html((chart, export_button), CDN, "plot2")

       
        # Treatment Current By AgeGroup & Sex   
        data_2 = df_curr_list[df_curr_list['SurgeCommand'].isin(selected_commands)]     
        age_group_tx_curr = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_curr = age_group_tx_curr.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_curr)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current By 5-Year Age Band & Sex'
        plot3 = age_group_tx_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.toolbar.logo = None
        plot3.x_range.start = 0        
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_curr)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html_comd = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment Current By Age Group & Sex
        # Filter the data
        data_3 = df_pbs_list[df_pbs_list['SurgeCommand'].isin(selected_commands)]
        # Create crosstab
        age_group_pbs_curr = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_curr = age_group_pbs_curr.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_curr)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current Biometrics By 5-Year Age Band & Sex'
        # Plot 
        plot4 = age_group_pbs_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0       
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_curr 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html_comd = file_html((plot4, export_button), CDN, "plot4")
             

        # Treatment Current MMD Distribution
        data_5 = df_curr_list[df_curr_list['SurgeCommand'].isin(selected_commands)]        
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()        
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b["value"] = data_5b['value'].astype(str)
        data_5b["value"] = data_5b["value"].str.pad(35, side="left")
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current By Multi-Month Dispensing (MMD)'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@mmd: @formatted_value, Percentage: @percentage{0.0}%",x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, inner_radius=0.20, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='mmd', source=source)
      
        # Callouts for labels
        callouts = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-25, source=source, render_mode='canvas',
                            text_align="center", angle=0, text_font_size='10pt', text_color='#000000')
        chart.add_layout(callouts)
        percentage_callouts = LabelSet(x="cos2", y="sin2", y_offset=-25, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')
        chart.add_layout(percentage_callouts)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None   
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html_comd = file_html((chart, export_button), CDN, "plot5")


        # Treatment Current By MMD & 5-Year Age Band
        data_7 = df_curr_list[df_curr_list['SurgeCommand'].isin(selected_commands)]     
        # Perform crosstab to get counts by AgeGroup and MMD
        tx_curr_age_mmd = pd.crosstab(data_7['AgeGroup'], data_7['mmd']).reset_index()
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(tx_curr_age_mmd)
        # List of MMD factors
        # mmd_factors = tx_curr_age_mmd.columns[1:]
        mmd_factors = list(tx_curr_age_mmd.columns[1:])
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current By MMD & 5-Year Age Band'
        # Create the Bokeh figure for stacked column chart
        plot = figure(x_range=tx_curr_age_mmd['AgeGroup'], 
                    title=plot_title, x_axis_label="", y_axis_label="Number of clients", 
                    height=height, plot_width=plot_width, toolbar_location='right', 
                    tools=[CrosshairTool(), PanTool(), BoxZoomTool(), SaveTool(), ResetTool()])

        # Add a HoverTool to display details on hover
        hover = HoverTool(tooltips=[("Age Band", "@AgeGroup"), ("MMD", "$name"), ("TX_CURR", "@$name{0,0}")])
        plot.add_tools(hover)
        # Add stacked columns to the figure
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))       
        # Get the closest supported size for the Spectral palette
        num_colors = len(mmd_factors)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        colors = color_palette[:num_colors]  
        # colors = ["#2b9eb0", '#2beaea', '#2b9eea', "#9ecae1"]
        plot.vbar_stack(stackers=mmd_factors, x='AgeGroup', width=0.8, color=colors, 
                        source=source, legend_label=[str(mmd) for mmd in mmd_factors])
        # Customize plot
        plot.xaxis.major_label_orientation = 1.2
        plot.toolbar.logo = None
        plot.y_range.start = 0 
        # Format y-axis with thousand separators
        plot.yaxis.formatter = NumeralTickFormatter(format="0,0")
        # Add legend click policy
        plot.legend.click_policy = "hide"
        plot.toolbar.autohide = True
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD & 5yr age.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label="Export CSV", button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html_comd = file_html((plot, export_button), CDN, "plot6")


        # Treatment Current Distribution By Facility
        data_8 = tx_curr_temp_tbl[tx_curr_temp_tbl['SurgeCommand'].isin(selected_commands)] 
        data_8agg = data_8.groupby('Facility Name')[['TX_CURR']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_CURR']]   
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Current By Facility'     
        plot9=data_8_sum.hvplot.bar(x="Facility Name", y='TX_CURR', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_CURR")                                

        labels = hv.Labels(data=data_8_sum, kdims=['Facility Name', 'TX_CURR'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # # Add HoverTool with formatted tooltips
        # hover = HoverTool()
        # hover.tooltips = [("Facility", "@Facility Name"), ("TX_CURR", "@TX_CURR{0,0}")]
        # bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html_comd = file_html((bokeh_model, export_button), CDN, "plot9")           


        data_6 = tx_curr_temp_tbl[tx_curr_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        data_6b = data_6.groupby('Facility Name')[['TX_CURR','Biometrics Captured', 'Biometrics Recaptured']].sum()   
        data_6b_curr=data_6b.reset_index()  

        def get_map_tx_curr(fac_name_name):
            # Function to get the TX_CURR value for a given SurgeCommand
            tx_curr_values = tx_curr_temp_tbl.groupby('Facility Name')['TX_CURR'].sum()
            return tx_curr_values.get(fac_name_name, "N/A")
                    
        def get_map_tx_curr2(fac_name_name):
            # Convert list to dictionary
            tx_curr_cap_dict = dict(zip(data_6b_curr['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Captured'] / data_6b_curr['TX_CURR']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_curr_cap_dict.get(fac_name_name, "N/A")

        def get_map_tx_curr3(fac_name_name):
            # Function to get the TX_PVLS value for a given SurgeCommand
            tx_curr_recap_dict = dict(zip(data_6b_curr['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Recaptured'] / data_6b_curr['Biometrics Captured']) * 100, decimals=1))))
            return tx_curr_recap_dict.get(fac_name_name, "N/A")
        
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                       
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Treatment Current Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))

        folium.Choropleth(
            geo_data=filtered_geo_data, name='choropleth', data=data_6b_curr, columns=['Facility Name', 'TX_CURR'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_CURR', highlight=True).add_to(ng_map)

        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_CURR: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''        
        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):       
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = tx_curr_temp_tbl[tx_curr_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_comds(selected_commands)
        
        for loc in locations:
            tx_curr_value = get_map_tx_curr(loc["popup"])
            tx_curr_formatted = format_with_thousand_separator(tx_curr_value)            
            tx_curr_cap_dict = get_map_tx_curr2(loc["popup"])
            tx_curr_recap_dict = get_map_tx_curr3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_curr_formatted, 
                                                tx_curr_cap_dict, 
                                                tx_curr_recap_dict) 
            
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_curr)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_curr_button_json_comd = json_item(export_button)
        # Convert map to HTML
        plot17_html_comd = ng_map.get_root().render()      

        ####################### DATATABLE ######################################################################################        
        plot19_html_comd = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_comd_curr_dict,
            'achieved': achieved_tx_curr_dict_comd,
            'achieved_pbs': achieved_pbs_curr_dict_comd,
            'percent_pbs': percent_pbs_curr_dict_comd,
            'achieved_recapture': achieved_pbs_rec_tx_curr_dict_comd,
            'percent_recaptured': percent_pbs_rec_tx_curr_dict_comd,
            'plot1': {'main': plot1_html_comd, 'additional': button_json_comd},
            'plot2': plot2_html_comd,
            'plot3': plot3_html_comd,
            'plot4': plot4_html_comd,
            'plot5': plot5_html_comd,
            'plot6': plot6_html_comd,
            'plot9': plot9_html_comd,
            'plot17': {'main': plot17_html_comd, 'additional': tx_curr_button_json_comd}, 
            'plot19': plot19_html_comd
        }   


    elif (selected_indicator == 'TX_NEW' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_new_temp_tbl[tx_new_temp_tbl['SurgeCommand'].isin(selected_commands)]
        # Number of facilities
        fac_num_tx_new_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_new_dict = int(data_1['TX_NEW'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_new_dict = int(data_1['TX_NEW Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_new_percent = (achieved_pbs_tx_new_dict / achieved_tx_new_dict) * 100
        percent_pbs_tx_new_dict = f"{pbs_new_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_new_dict = int(data_1['TX_NEW Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_new_percent = (achieved_pbs_rec_tx_new_dict / achieved_pbs_tx_new_dict) * 100
        percent_pbs_rec_tx_new_dict = f"{pbs_rec_tx_new_percent:.1f}"            
        ############################################################################################
        # Handle data elements from the line list table
        data_2 = df_new_list[df_new_list['SurgeCommand'].isin(selected_commands)]        
        # Treatment New By Pediatric & Adult Clients & Sex
        data_4 = df_new_list[df_new_list['SurgeCommand'].isin(selected_commands)]
        longfm1_comd_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_new_widefm2_comd_age_sex = longfm1_comd_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_NEW')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New By Pediatric & Adult Clients & Sex' 
        plot1=tx_new_widefm2_comd_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model'%.0f'
        bokeh_model = hv.render(plot1, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_NEW', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the New document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_new_widefm2_comd_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment New CD4 Distribution
        data_5 = df_cd4_new_list[df_cd4_new_list['SurgeCommand'].isin(selected_commands)]        
        data_5agg = data_5.TX_NEW_CD4.value_counts().reset_index().rename(columns={'index':'TX_NEW_CD4', 'TX_NEW_CD4':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        value = data_5b["value"].values
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]        
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b) 
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New By CD4 Count' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW_CD4: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW_CD4', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
                        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")

        
        # Treatment New By AgeGroup & Sex
        age_group_tx_new = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_new = age_group_tx_new.set_index('AgeGroup')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New By 5-Year Age Band & Sex'          
        if not age_group_tx_new.empty:
            plot3 = age_group_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False) 
            # Set the width and height of the plot
            plot3.plot.width = plot_width
            # Adjusting toolbar size
            plot3.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot3.x_range.start = 0
            plot3.toolbar.logo = None   
            plot3.toolbar.active_scroll = None
            plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_group_tx_new)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot3_html = file_html((plot3, export_button), CDN, "plot3")
        else:
            # Handle the empty data case
            plot3_html = "No data available to plot."  
    
        


        # Biometrics Treatment New By Age Group & Sex
        data_3 = df_pbs_new_list[df_pbs_new_list['SurgeCommand'].isin(selected_commands)]
        age_group_pbs_tx_new = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_tx_new = age_group_pbs_tx_new.set_index('AgeGroup')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New Biometrics By 5-Year Age Band & Sex' 
        if not age_group_pbs_tx_new.empty:
            plot4 = age_group_pbs_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
            plot4.plot.width = plot_width
            # Adjusting toolbar size
            plot4.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot4.x_range.start = 0
            plot4.toolbar.logo = None   
            plot4.toolbar.active_scroll = None
            plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_group_pbs_tx_new)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'tx_new pbs by age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot4_html = file_html((plot4, export_button), CDN, "plot4") 
        else:
            # Handle the empty data case
            plot4_html = "No data available to plot."  


        # TX_NEW By Month 
        data_8 = df_new_list[df_new_list['SurgeCommand'].isin(selected_commands)]
        data_8agg = data_8.TX_NEW_month.value_counts().reset_index().rename(columns={'index':'TX_NEW_month', 'TX_NEW_month':'value'})
        data_8_count = data_8agg.copy()
        data_8_count['formatted_value']=["{:,.0f}".format(val) for val in data_8_count['value']]    
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} TX_NEW By Month'     
        plot5new_days=data_8_count.hvplot.bar(x="TX_NEW_month", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='',  width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW_month")                                

        labels = hv.Labels(data=data_8_count, kdims=['TX_NEW_month', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by month.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotnew_month_html = file_html((bokeh_model, export_button), CDN, "plot5")


        # Treatment New in Month 1 By AgeGroup & Sex
        data_9 = df_new_listmth1[df_new_listmth1['SurgeCommand'].isin(selected_commands)]
        age_sex_tx_new_month1 = pd.crosstab(data_9['AgeGroup'], data_9['Sex']).reset_index()
        age_sex_tx_new_month1 = age_sex_tx_new_month1.set_index('AgeGroup')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New In Month 1 By 5-Year Age Band & Sex'  
        if not age_sex_tx_new_month1.empty:
            plot6 = age_sex_tx_new_month1.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False) 
            # Set the width and height of the plot
            plot6.plot.width = plot_width
            # Adjusting toolbar size
            plot6.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot6.x_range.start = 0
            plot6.toolbar.logo = None    
            plot6.toolbar.active_scroll = None
            plot6.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month1)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 1 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot6_html = file_html((plot6, export_button), CDN, "plot6")
        else:
            # Handle the empty data case
            plot6_html = "No data available to plot."                       


        # Treatment New in Month 2 By AgeGroup & Sex
        data_10 = df_new_listmth2[df_new_listmth2['SurgeCommand'].isin(selected_commands)]
        age_sex_tx_new_month2 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month2 = age_sex_tx_new_month2.set_index('AgeGroup')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New In Month 2 By 5-Year Age Band & Sex'              
        if not age_sex_tx_new_month2.empty:
            plot9 = age_sex_tx_new_month2.plot_bokeh.bar(title=plot_title, legend = "top_right",line_width=8.0, show_figure=False) 
            # Set the width and height of the plot
            plot9.plot.width = 800
            # Adjusting toolbar size
            plot9.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot9.y_range.start = 0
            plot9.toolbar.logo = None    
            plot9.toolbar.active_scroll = None
            plot9.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month2)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 2 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot9_html = file_html((plot9, export_button), CDN, "plot9")
        else:
            # Handle the empty data case
            plot9_html = "No data available to plot."        


        # Treatment New in Month 3 By AgeGroup & Sex
        data_10 = df_new_listmth3[df_new_listmth3['SurgeCommand'].isin(selected_commands)]
        age_sex_tx_new_month3 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
        age_sex_tx_new_month3 = age_sex_tx_new_month3.set_index('AgeGroup')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New In Month 3 By 5-Year Age Band & Sex'    
        if not age_sex_tx_new_month3.empty:
            plot10 = age_sex_tx_new_month3.plot_bokeh.bar(title=plot_title, legend="top_right", line_width=8.0, show_figure=False)
            # Set the width and height of the plot
            plot10.plot.width = 800
            # Adjusting toolbar size
            plot10.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot10.y_range.start = 0
            plot10.toolbar.logo = None   
            plot10.toolbar.active_scroll = None
            plot10.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
            # Create csv table for export
            source = ColumnDataSource(age_sex_tx_new_month3)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'month 3 tx_new 5yr age_sex.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot10_html = file_html((plot10, export_button), CDN, "plot10")
        else:
            # Handle the empty data case
            plot10_html = "No data available to plot."          
        
                                       
        # Treatment New ML Distribution
        data_7 = df_ml_new_list[df_ml_new_list['SurgeCommand'].isin(selected_commands)]        
        data_7agg = data_7['TX_NEW ML'].value_counts().reset_index().rename(columns={'index':'TX_NEW ML', 'TX_NEW ML':'value'})
        data_7b = data_7agg.copy()
        if not data_7b.empty:
            total_count = data_7b['value'].sum()
            value = data_7b["value"].values
            data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
            data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
            data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.28
            data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.28
            data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
            data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
            data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
            data_7b['percentage'] = (data_7b['value'] / total_count) * 100
            data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
            # Define the Spectral color palette with supported sizes
            supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
            # Function to get the closest supported size for the Spectral palette
            def get_closest_palette_size(num_colors):
                return min(supported_sizes, key=lambda x: abs(x - num_colors))        
            # Get the closest supported size for the Spectral palette
            num_colors = len(data_7b)
            closest_size = get_closest_palette_size(num_colors)
            color_palette = Spectral[closest_size]
            # Repeat colors if there are more items than colors in the palette
            if num_colors > closest_size:
                color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

            data_7b['color'] = color_palette[:len(data_7b)]    
            # Pad the 'value' column with spaces to improve label alignment
            data_7b["value"] = data_7b['value'].astype(str)
            # Convert DataFrame to ColumnDataSource
            source = ColumnDataSource(data_7b)
            # Create a title string that includes the selected SurgeCommand(s)
            comd_name = ', '.join([f'{command} Command' for command in selected_commands])
            plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(comd_name, total_count)
            # Creating chart vertical
            chart = figure(height=height, width=620, title=plot_title, 
                            toolbar_location="above",  # Show toolbar above the plot
                            tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                            tooltips="@TX_NEW ML: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
            # Creating sectors
            chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                                start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                                line_color="white", fill_color='color', legend_field='TX_NEW ML', source=source)
            # Adding labels
            labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-9, source=source, render_mode='canvas',text_align="center", angle=0,
                    text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
            percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-9, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')

            chart.add_layout(labels)
            chart.add_layout(percentage_labels)
            # Clearing interface
            chart.axis.axis_label=None
            chart.axis.visible=False
            chart.grid.grid_line_color = None
            # Remove Bokeh logo from the toolbar
            chart.toolbar.logo = None
            # Adjusting toolbar size
            chart.toolbar.autohide = True
            # Adjusting legend label size
            chart.legend.label_text_font_size = '9pt'
            chart.outline_line_color = None        
            # Create csv table for export
            source = ColumnDataSource(data_7agg)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'tx_new ml.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot11_html = file_html((chart, export_button), CDN, "plot11")    
        else:
            # Handle the empty data case
            plot11_html = "No Treatment New Mortality & Loss (TX_NEW ML) data available to plot."  


        # Treatment New Distribution By Facility
        data_11 = tx_new_temp_tbl[tx_new_temp_tbl['SurgeCommand'].isin(selected_commands)] 
        data_11agg = data_11.groupby('Facility Name')[['TX_NEW']].sum().reset_index()    
        data_11_sum = data_11agg.copy()
        data_11_sum['formatted_value']=["{:,.0f}".format(val) for val in data_11_sum['TX_NEW']]   
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment New By Facility'     
        plot9=data_11_sum.hvplot.bar(x="Facility Name", y='TX_NEW', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW")                                

        labels = hv.Labels(data=data_11_sum, kdims=['Facility Name', 'TX_NEW'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_11agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'TX_NEW by facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html_comd = file_html((bokeh_model, export_button), CDN, "plot12")    


        data_6 = tx_new_temp_tbl[tx_new_temp_tbl['SurgeCommand'].isin(selected_commands)]   
        data_6b = data_6.groupby('Facility Name')['TX_NEW', 'TX_NEW month 1','TX_NEW month 2', 'TX_NEW month 3'].sum()   
        data_6b_new=data_6b.reset_index() 

        def get_map_tx_new(comd_name):
            # Function to get the TX_NEW value for a given SurgeCommand
            tx_new_values = data_6b_new.groupby('Facility Name')['TX_NEW'].sum()
            return tx_new_values.get(comd_name, "N/A")
        
        def get_map_tx_new_month_1(comd_name):
            # Function to get the TX_NEW value for a given SurgeCommand
            tx_new_month_1 = data_6b_new.groupby('Facility Name')['TX_NEW month 1'].sum()
            return tx_new_month_1.get(comd_name, "N/A")
        
        def get_map_tx_new_month_2(comd_name):
            # Function to get the TX_NEW value for a given SurgeCommand
            tx_new_month_2 = data_6b_new.groupby('Facility Name')['TX_NEW month 2'].sum()
            return tx_new_month_2.get(comd_name, "N/A")
        
        def get_map_tx_new_month_3(comd_name):
            # Function to get the TX_NEW value for a given SurgeCommand
            tx_new_month_3 = data_6b_new.groupby('Facility Name')['TX_NEW month 3'].sum()
            return tx_new_month_3.get(comd_name, "N/A")

        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                    
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Treatment New Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_new, columns=['Facility Name', 'TX_NEW'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_NEW', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_NEW: {}<br>
                Month 1: {}<br>
                Month 2: {}<br>
                Month 3: {}
            </div>
        '''
        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = tx_new_temp_tbl[tx_new_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            tx_new_value = get_map_tx_new(loc["popup"])
            tx_new_formatted = format_with_thousand_separator(tx_new_value)  
            tx_new_month_1 = get_map_tx_new_month_1(loc["popup"])
            tx_new_mth_1_formatted = format_with_thousand_separator(tx_new_month_1) 

            tx_new_month_2 = get_map_tx_new_month_2(loc["popup"])
            tx_new_mth_2_formatted = format_with_thousand_separator(tx_new_month_2) 

            tx_new_month_3 = get_map_tx_new_month_3(loc["popup"])
            tx_new_mth_3_formatted = format_with_thousand_separator(tx_new_month_3)             
            
            popup_content = popup_style.format(loc["popup"], tx_new_formatted, tx_new_mth_1_formatted,
                                               tx_new_mth_2_formatted, tx_new_mth_3_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_new)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_new_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()
        

        ####################### DATATABLE ######################################################################################        
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)
  
        data_response = {
            'fac_num': fac_num_tx_new_dict,
            'achieved': achieved_tx_new_dict,
            'achieved_pbs': achieved_pbs_tx_new_dict,
            'percent_pbs': percent_pbs_tx_new_dict,
            'achieved_recapture': achieved_pbs_rec_tx_new_dict,
            'percent_recaptured': percent_pbs_rec_tx_new_dict,
            'plot1': {'main': plot1_html, 'additional': button_json}, 
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plotnew_month_html,
            'plot6': plot6_html, 
            'plot9': plot9_html,  
            'plot10': plot10_html, 
            'plot11': plot11_html,        
            'plot12': plot12_html_comd,   
            'plot17': {'main': plot17_html, 'additional': tx_new_button_json}, 
            'plot19': plot19_html
        }       


    elif (selected_indicator == 'TX_ML' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment ml indicator
        data_1 = tx_ml_df[tx_ml_df['SurgeCommand'].isin(selected_commands)]
        # Number of facilities
        fac_num_tx_ml_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_ml_dict = int(data_1['TX_ML'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_ml_dict = int(data_1['TX_ML Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_ml_percent = (achieved_pbs_tx_ml_dict / achieved_tx_ml_dict) * 100
        percent_pbs_tx_ml_dict = f"{pbs_ml_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_ml_dict = int(data_1['TX_ML Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_ml_percent = (achieved_pbs_rec_tx_ml_dict / achieved_pbs_tx_ml_dict) * 100
        percent_pbs_rec_tx_ml_dict = f"{pbs_rec_tx_ml_percent:.1f}"     
        #################################################################################################
        # Treatment Mortality & Loss By Pediatric & Adult Clients & Sex
        data_4 = df_ml_list[df_ml_list['SurgeCommand'].isin(selected_commands)]
        longfm1_comd_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_ml_widefm2_comd_age_sex = longfm1_comd_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_ML')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Mortality & Loss By Pediatric & Adult Clients & Sex' 
        plot1ml=tx_ml_widefm2_comd_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                        title=plot_title).opts(
                                        hooks=[remove_bokeh_logo], toolbar="right")
      
        # Convert HoloViews object to Bokeh model
        bokeh_model = hv.render(plot1ml, backend='bokeh')
        # Adjust y-axis tick formatter to disable scientific notation and set to integer format
        bokeh_model.yaxis.formatter.use_scientific = False
        bokeh_model.yaxis.formatter.precision = 0
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Define hover tool with custom formatters
        hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_ML', '@value{0,0}')])
        # Add hover tool to the plot
        bokeh_model.add_tools(hover)
        # Adjusting toolbar size
        bokeh_model.toolbar.autohide = True
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(tx_ml_widefm2_comd_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)      
        plot1_html = json_item(bokeh_model)
        button_json = json_item(export_button)


        # Treatment Mortality & Loss Outcomes
        data_5 = df_ml_2_list[df_ml_2_list['SurgeCommand'].isin(selected_commands)]        
        data_5agg = data_5.TX_ML_Outcome_2.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome_2', 'TX_ML_Outcome_2':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)] 
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        # Format the 'value' column with thousand separators
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        # Pad the 'value' column with spaces to improve label alignment
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Treatment Mortality & Loss Outcomes' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,box_zoom,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome_2: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome_2', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-15, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-15, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml outcomes.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")        

        
        # Interrution in Treatment By Age Group & Sex 
        data_4b = df_ml_iit_list[df_ml_iit_list['SurgeCommand'].isin(selected_commands)]
        age_group_iit = pd.crosstab(data_4b['AgeGroup'], data_4b['Sex']).reset_index()
        age_group_iit = age_group_iit.set_index('AgeGroup')
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} IIT By 5-Year Age Band & Sex' 
        plot4 = age_group_iit.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0
        plot4.toolbar.logo = None  
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_iit)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT By 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((plot4, export_button), CDN, "plot4")


        # Interrution in Treatment in Days 
        data_4c = df_ml_iit_days_list[df_ml_iit_days_list['SurgeCommand'].isin(selected_commands)]
        data_4agg = data_4c.IIT_duration_days.value_counts().reset_index().rename(columns={'index':'IIT_duration_days', 'IIT_duration_days':'value'})
        data_4c_count = data_4agg.copy()
        # Define the custom order
        custom_order = ['IIT for â‰¤30 days', 'IIT for 31 to 60 days', 'IIT for 61 to 180 days', 'IIT for >180 days']
        # Convert the IIT_duration_days column to a categorical type with the custom order
        data_4c_count['IIT_duration_days'] = pd.Categorical(data_4c_count['IIT_duration_days'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order   
        data_4c_count = data_4c_count.sort_values('IIT_duration_days')         
        data_4c_count['formatted_value']=["{:,.0f}".format(val) for val in data_4c_count['value']]  
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} IIT Duration (Days)'       
        plot1iit_days=data_4c_count.hvplot.bar(x="IIT_duration_days", y='value', height=height, color='#6d99ff', grid=True, rot=30, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')                             
        
        labels = hv.Labels(data=data_4c_count, kdims=['IIT_duration_days', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_iit = plot1iit_days * labels
        bokeh_model = hv.render(plot_iit, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(data_4agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT duration in days.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotiit_days_html = file_html((bokeh_model, export_button), CDN, "plot4")

   
        # SurgeCommand level IIT Rate
        tx_ml_df_comd = tx_ml_df[tx_ml_df['SurgeCommand'].isin(selected_commands)]
        tx_ml_df_comd = tx_ml_df_comd.groupby('SurgeCommand', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_comd['IIT Rate (%)'] = np.round((tx_ml_df_comd['IIT'] / tx_ml_df_comd['TX_CURR']) * 100, decimals=1)
        data_7 = tx_ml_df_comd.copy()
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} IIT Rate'   
        # Create a new plot with a title and axis labels 700
        p = figure(x_range=FactorRange(*source.data['SurgeCommand']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="above")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('SurgeCommand', -0.3, range=p.x_range), top='TX_CURR', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('SurgeCommand', -0.1, range=p.x_range), top='IIT', width=0.18, source=source,
                                    color="#71aebf", legend_label="IIT")}        
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))
        # Add labels for bars
        p.text(x=dodge('SurgeCommand', -0.3, range=p.x_range), y='TX_CURR', text='TX_CURR',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('SurgeCommand', -0.1, range=p.x_range), y='IIT', text='IIT',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.2]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('SurgeCommand', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        # Format y-axis labels with thousands separators
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 
        # Hide the toolbar
        p.toolbar.autohide = True
        # Adjusting legend label size
        p.legend.label_text_font_size = '10pt'
        # Position the legend outside the plot area 
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        p.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'overall SurgeCommand IIT rate.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((p, export_button), CDN, "plot5")


        data_8 = tx_ml_df_comd_mmd[tx_ml_df_comd_mmd['SurgeCommand'].isin(selected_commands)]    
        # Define the data source
        source = ColumnDataSource(data_8)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} % IIT By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('mmd', -0.2, range=p.x_range), top='TX_CURR', width=0.2, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('mmd', 0.1, range=p.x_range), top='IIT', width=0.2, source=source,
                color="#71aebf", legend_label="IIT")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('mmd', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('mmd', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.legend.label_text_font_size = '10pt'
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        p.toolbar.logo = None
        p.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_8)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((p, export_button), CDN, "plot6")        


        # % IIT By Supported Facilities
        data_9 = tx_ml_df[tx_ml_df['SurgeCommand'].isin(selected_commands)]  
        tx_ml_df_comd = data_9.groupby('Facility Name', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_comd['IIT Rate (%)'] = np.round((tx_ml_df_comd['IIT'] / tx_ml_df_comd['TX_CURR']) * 100, decimals=1)   
        # Define the data source
        source = ColumnDataSource(tx_ml_df_comd)
        SurgeCommands = source.data["Facility Name"]
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} % IIT By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=SurgeCommands, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('Facility Name', -0.2, range=p.x_range), top='TX_CURR', width=0.25, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('Facility Name', 0.1, range=p.x_range), top='IIT', width=0.25, source=source,
                color="#71aebf", legend_label="IIT")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', "@{Facility Name}"), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('Facility Name', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('Facility Name', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.05]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '10pt'        
        p.add_layout(p.legend[0], 'right')
        p.legend.click_policy = "hide"
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(tx_ml_df_comd)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((p, export_button), CDN, "plot9")


        # Interrution in Treatment Distribution
        data_7 = df_ml_iit_list[df_ml_iit_list['SurgeCommand'].isin(selected_commands)]        
        data_7agg = data_7.TX_ML_Outcome.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome', 'TX_ML_Outcome':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.27
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.27
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]       
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(comd_name, total_count)
        # Creating chart vertical
        chart = figure(height=height, width=620, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot10_html = file_html((chart, export_button), CDN, "plot10") 

        
        data_6 = tx_ml_df[tx_ml_df['SurgeCommand'].isin(selected_commands)]    
        data_6b = data_6.groupby('Facility Name')['TX_ML','IIT', 'Stopped Treatment', 'Transferred Out', 'Dead'].sum() 
        data_6b_df = data_6b.reset_index()
        def get_map_tx_ml(comd_name):
            # Function to get the TX_ML value for facilities in a given SurgeCommand
            tx_ml_values = data_6b_df.groupby('Facility Name')['TX_ML'].sum()
            return tx_ml_values.get(comd_name, "N/A")
        
        def get_map_tx_ml_iit(comd_name):
            # Function to get the IIT value for a given SurgeCommand
            tx_ml_iit = data_6b_df.groupby('Facility Name')['IIT'].sum()
            return tx_ml_iit.get(comd_name, "N/A")
        
        def get_map_tx_ml_stopped(comd_name):
            # Function to get the Stopped value for a given SurgeCommand
            tx_ml_stopped = data_6b_df.groupby('Facility Name')['Stopped Treatment'].sum()
            return tx_ml_stopped.get(comd_name, "N/A")
        
        def get_map_tx_ml_to(comd_name):
            # Function to get the Transferred Out value for a given SurgeCommand
            tx_ml_to = data_6b_df.groupby('Facility Name')['Transferred Out'].sum()
            return tx_ml_to.get(comd_name, "N/A")
        
        def get_map_tx_ml_dead(comd_name):
            # Function to get the Dead value for a given SurgeCommand
            tx_ml_dead = data_6b_df.groupby('Facility Name')['Dead'].sum()
            return tx_ml_dead.get(comd_name, "N/A")
   
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                       
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Treatment Mortality & Loss Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['Facility Name', 'TX_ML'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_ML', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_ML: {}<br>
                IIT: {}<br>
                Stopped: {}<br>
                Transferred Out: {}<br>
                Dead: {}
            </div>
        '''

        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):            
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = tx_ml_df_sorted[tx_ml_df_sorted['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations        
        
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            tx_ml_value = get_map_tx_ml(loc["popup"])
            tx_ml_formatted = format_with_thousand_separator(tx_ml_value)   
            tx_ml_iit = get_map_tx_ml_iit(loc["popup"])
            tx_ml_iit_formatted = format_with_thousand_separator(tx_ml_iit)  

            tx_ml_stopped = get_map_tx_ml_stopped(loc["popup"])
            tx_ml_stopped_formatted = format_with_thousand_separator(tx_ml_stopped) 

            tx_ml_to = get_map_tx_ml_to(loc["popup"])
            tx_ml_to_formatted = format_with_thousand_separator(tx_ml_to) 

            tx_ml_dead = get_map_tx_ml_dead(loc["popup"])
            tx_ml_dead_formatted = format_with_thousand_separator(tx_ml_dead) 

            popup_content = popup_style.format(loc["popup"], tx_ml_formatted, tx_ml_iit_formatted, tx_ml_stopped_formatted, 
                                               tx_ml_to_formatted, tx_ml_dead_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_ml_button_json = json_item(export_button)  
        plot17_html = ng_map.get_root().render()       
   
        
    ####################### DATATABLE ######################################################################################        
        plot19_html = data_6.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)
        
        data_response = {
            'fac_num': fac_num_tx_ml_dict,
            'achieved': achieved_tx_ml_dict,
            'achieved_pbs': achieved_pbs_tx_ml_dict,
            'percent_pbs': percent_pbs_tx_ml_dict,
            'achieved_recapture': achieved_pbs_rec_tx_ml_dict,
            'percent_recaptured': percent_pbs_rec_tx_ml_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot4_html,
            'plot4': plotiit_days_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': tx_ml_button_json}, 
            'plot19': plot19_html
        }               
    

    elif (selected_indicator == 'TX_RTT' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['SurgeCommand'].isin(selected_commands)]
        # Number of facilities
        fac_num_tx_rtt_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_rtt_dict = int(data_1['TX_RTT'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_rtt_dict = int(data_1['TX_RTT Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_rtt_percent = (achieved_pbs_tx_rtt_dict / achieved_tx_rtt_dict) * 100
        percent_pbs_tx_rtt_dict = f"{pbs_rtt_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_rtt_dict = int(data_1['TX_RTT Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_rtt_percent = (achieved_pbs_rec_tx_rtt_dict / achieved_pbs_tx_rtt_dict) * 100
        percent_pbs_rec_tx_rtt_dict = f"{pbs_rec_tx_rtt_percent:.1f}"            
        ############################################################################################
        # Returned To Treatment Distribution By Sex 
        data_2 = df_rtt_list[df_rtt_list['SurgeCommand'].isin(selected_commands)]        
        data_2agg = data_2.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_2b = data_2agg.copy()
        total_count = data_2b['value'].sum()
        data_2b['angle'] = data_2b['value'] / total_count * 2 * pi
        value = data_2b["value"].values
        data_2b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_2b['cos'] = np.cos(data_2b['cumulative_angle']) * 0.32
        data_2b['sin'] = np.sin(data_2b['cumulative_angle']) * 0.32
        data_2b['cos2'] = np.cos(data_2b['cumulative_angle']) * 0.41
        data_2b['sin2'] = np.sin(data_2b['cumulative_angle']) * 0.41
        data_2b['formatted_value']=["{:,.0f}".format(val) for val in data_2b['value']]
        data_2b['percentage'] = (data_2b['value'] / total_count) * 100
        data_2b['label']=["({:.1f}%)".format(val) for val in data_2b['percentage']]
        data_2b['color'] = ['#2b9eea', '#2beaea'] 
        # Pad the 'value' column with spaces to improve label alignment
        data_2b["value"] = data_2b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_2b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Returned To Treatment By Sex' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_2agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((chart, export_button), CDN, "plot3")


        # Returned To Treatment Distribution
        data_3 = df_rtt_list[df_rtt_list['SurgeCommand'].isin(selected_commands)]        
        data_3agg = data_3.TX_RTT_Outcome.value_counts().reset_index().rename(columns={'index':'TX_RTT_Outcome', 'TX_RTT_Outcome':'value'})
        data_3b = data_3agg.copy()
        total_count = data_3b['value'].sum()
        value = data_3b["value"].values
        data_3b['angle'] = data_3b['value'] / total_count * 2 * pi
        data_3b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_3b['cos'] = np.cos(data_3b['cumulative_angle']) * 0.27
        data_3b['sin'] = np.sin(data_3b['cumulative_angle']) * 0.27
        data_3b['cos2'] = np.cos(data_3b['cumulative_angle']) * 0.35
        data_3b['sin2'] = np.sin(data_3b['cumulative_angle']) * 0.35
        data_3b['formatted_value']=["{:,.0f}".format(val) for val in data_3b['value']]
        data_3b['percentage'] = (data_3b['value'] / total_count) * 100
        data_3b['label']=["({:.1f}%)".format(val) for val in data_3b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_3b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_3b['color'] = color_palette[:len(data_3b)]              
        # Pad the 'value' column with spaces to improve label alignment
        data_3b["value"] = data_3b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Creating chart vertical
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = "{} Returned To Treatment (TX_RTT) Total = {:,.0f}".format(comd_name, total_count)
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@TX_RTT_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_RTT_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_3agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot4_html = file_html((chart, export_button), CDN, "plot4")


        # Returned To Treatment By AgeGroup & Sex        
        age_group_tx_rtt = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_tx_rtt = age_group_tx_rtt.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_rtt)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Returned To Treatment By 5-Year Age Band & Sex' 
        plot5 = age_group_tx_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot5.plot.width = plot_width
        # Adjusting toolbar size
        plot5.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot5.x_range.start = 0
        plot5.toolbar.logo = None    
        plot5.toolbar.active_scroll = None
        plot5.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_rtt)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh plot to HTML
        plot5_html = file_html((plot5, export_button), CDN, "plot5")        


        # Returned To Treatment By Age Group & Sex (Biometrics)
        # Filter the data
        data_4 = rtt_pbs_list[rtt_pbs_list['SurgeCommand'].isin(selected_commands)]
        # Create crosstab
        age_group_pbs_rtt = pd.crosstab(data_4['AgeGroup'], data_4['Sex']).reset_index()
        age_group_pbs_rtt = age_group_pbs_rtt.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_rtt)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} TX_RTT Biometrics Captured By 5-Year Age Band & Sex' 
        # Plot 
        plot4 = age_group_pbs_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0        
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_rtt 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot4, export_button), CDN, "plot6")


        # Returned To Treatment MMD Distribution
        data_5 = df_rtt_list[df_rtt_list['SurgeCommand'].isin(selected_commands)]  
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        # Define the custom order
        custom_order = ['MMD <3', 'MMD 3', 'MMD 4-5', 'MMD 6']
        # Convert the mmd column to a categorical type with the custom order
        data_5agg['mmd'] = pd.Categorical(data_5agg['mmd'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order
        data_5agg = data_5agg.sort_values('mmd')
        data_5_count = data_5agg.copy()
        data_5_count['formatted_value'] = ["{:,.0f}".format(val) for val in data_5_count['value']]
        # Define colors for each bar
        colors = ['#ff6f61', '#6aff99', '#6d99ff', '#aa66cc']
        data_5_count['color'] = colors[:len(data_5_count)]
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Returned To Treatment By MMD' 
        # Create the bar plot
        plot5new_days = data_5_count.hvplot.barh(
            x="mmd", y='value', height=height, color='color', grid=True, xlabel='', line_color=None, fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, 
            ylabel='', width=plot_width, title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')

        # Add labels
        labels = hv.Labels(data=data_5_count, kdims=['mmd', 'value'], vdims='formatted_value')
        # Overlay labels on the bar plot
        plot_new = plot5new_days * labels
        # Get the underlying Bokeh plot
        bokeh_plot = hv.render(plot_new)
        # Format the x-axis with a thousand separator
        bokeh_plot.xaxis[0].formatter = NumeralTickFormatter(format="0,0")         
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)

        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot7_html = file_html((bokeh_plot, export_button), CDN, "plot7")           

        
        # Returned To Treatment CD4 Distribution
        data_6 = rtt_cd4_list[rtt_cd4_list['SurgeCommand'].isin(selected_commands)]
        data_6agg = data_6.TX_RTT_CD4.value_counts().reset_index().rename(columns={'index':'TX_RTT_CD4', 'TX_RTT_CD4':'value'})
        data_6_count = data_6agg.copy()
        data_6_count['formatted_value']=["{:,.0f}".format(val) for val in data_6_count['value']]    
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Returned To Treatment By CD4 Count'     
        plot5new_days=data_6_count.hvplot.bar(x="TX_RTT_CD4", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT_CD4")                                

        labels = hv.Labels(data=data_6_count, kdims=['TX_RTT_CD4', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_6agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot8_html = file_html((bokeh_model, export_button), CDN, "plot8")   


        # Returned To Treatment Distribution By SurgeCommand
        data_8 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['SurgeCommand'].isin(selected_commands)] 
        data_8agg = data_8.groupby('Facility Name')[['TX_RTT']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_RTT']]   
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Returned To Treatment By Facility'     
        plot9=data_8_sum.hvplot.bar(x="Facility Name", y='TX_RTT', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT")                                

        labels = hv.Labels(data=data_8_sum, kdims=['Facility Name', 'TX_RTT'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # # Add HoverTool with formatted tooltips
        # hover = HoverTool()
        # hover.tooltips = [("Facility", "@{Facility Name}"), ("TX_RTT", "@TX_RTT{0,0}")]
        # bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((bokeh_model, export_button), CDN, "plot9")          


        data_7 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        data_7b_rtt = data_7.groupby('Facility Name', as_index=True)[['TX_RTT','TX_RTT Captured', 'TX_RTT Recaptured']].sum()   
        data_7b_rtt=data_7b_rtt.reset_index()  

        def get_map_tx_rtt(comd_name):
            # Function to get the TX_RTT value for Facilities in a given SurgeCommand
            tx_rtt_values = data_7b_rtt.groupby('Facility Name')['TX_RTT'].sum()            
            return tx_rtt_values.get(comd_name, "N/A")
        
        def get_map_tx_rtt2(comd_name):
            # Convert list to dictionary
            tx_rtt_cap_dict = dict(zip(data_7b_rtt['Facility Name'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Captured'] / data_7b_rtt['TX_RTT']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_rtt_cap_dict.get(comd_name, "N/A")

        def get_map_tx_rtt3(comd_name):
            # Function to get the TX_PVLS value for a given SurgeCommand
            tx_rtt_recap_dict = dict(zip(data_7b_rtt['Facility Name'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Recaptured'] / data_7b_rtt['TX_RTT Captured']) * 100, decimals=1))))
            return tx_rtt_recap_dict.get(comd_name, "N/A")
        
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                    
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Returned To Treatment Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_7b_rtt, columns=['Facility Name', 'TX_RTT'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_RTT', highlight=True).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_RTT: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''

        # Define a function to get locations for Facilities in the selected SurgeCommands
        def get_locations_for_comds(selected_commands):
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = tx_rtt_temp_tbl[tx_rtt_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            tx_rtt_value = get_map_tx_rtt(loc["popup"])
            tx_rtt_formatted = format_with_thousand_separator(tx_rtt_value)            
            tx_rtt_cap_dict = get_map_tx_rtt2(loc["popup"])
            tx_rtt_recap_dict = get_map_tx_rtt3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_rtt_formatted, 
                                                tx_rtt_cap_dict, 
                                                tx_rtt_recap_dict) 
            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Create ColumnDataSource from the DataFrame
        source = ColumnDataSource(data_7b_rtt)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_rtt_button_json = json_item(export_button)
        plot17_html = ng_map.get_root().render() 

        ####################### DATATABLE ######################################################################################        
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_rtt_dict,
            'achieved': achieved_tx_rtt_dict,
            'achieved_pbs': achieved_pbs_tx_rtt_dict,
            'percent_pbs': percent_pbs_tx_rtt_dict,
            'achieved_recapture': achieved_pbs_rec_tx_rtt_dict,
            'percent_recaptured': percent_pbs_rec_tx_rtt_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot7': plot7_html,
            'plot8': plot8_html,
            'plot9': plot9_html,
            'plot17': {'main': plot17_html, 'additional': tx_rtt_button_json}, 
            'plot19': plot19_html

        }  


    elif (selected_indicator == 'TX_PVLS' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]    
        # Number of facilities
        fac_num_tx_pvls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_pvls_dict = int(data_1['TX_PVLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_pvls_dict = int(data_1['TX_PVLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_tx_pvls_percent = (achieved_pbs_tx_pvls_dict / achieved_tx_pvls_dict) * 100
        percent_pbs_tx_pvls_dict = f"{pbs_tx_pvls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_pvls_dict = int(data_1['TX_PVLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_tx_pvls_percent = (achieved_pbs_rec_tx_pvls_dict / achieved_pbs_tx_pvls_dict) * 100
        percent_pbs_rec_tx_pvls_dict = f"{pbs_rec_tx_pvls_percent:.1f}"     
        ############################################################################################################
        data_1b = tx_pvls_comd[tx_pvls_comd['SurgeCommand'].isin(selected_commands)] 
        source = ColumnDataSource(data_1b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Viral Load Suppression Performance' 
        # Create a new plot with a title and axis labels 
        plot1 = figure(x_range=FactorRange(*source.data['SurgeCommand']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="right")
        # Render bars
        bars = {
            'Eligible for VL': plot1.vbar(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), top='Eligible for VL', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': plot1.vbar(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), top='TX_PVLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': plot1.vbar(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), top='TX_PVLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N)"),
            'Undetected VL <50': plot1.vbar(x=dodge('SurgeCommand', 0.3, range=plot1.x_range), top='Undetected VL <50', width=0.18, source=source,
                                            color="#A8B9E2", legend_label="Undetected VL <50")
        }

        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), y='Eligible for VL', text='Eligible for VL',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', 0.3, range=plot1.x_range), y='Undetected VL <50', text='Undetected VL <50',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression', '% Undetected']
        colors = ["Magenta", "green", "blue"]
        dodge_values = [-0.2, 0, 0.2]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '4.5pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below')   #Valid place values are: above, below, left, right or center
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        data_2 = grouped_pvls_comd[grouped_pvls_comd['SurgeCommand'].isin(selected_commands)] 
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Viral Load Coverage & Suppression By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")
             
        
        ############################################################################################
        # Clients' Viral Load Suppression By Age Band
        data_3 = pvls_temp_tbl_all_age_comd[pvls_temp_tbl_all_age_comd['SurgeCommand'].isin(selected_commands)]   
        data_3b = data_3.groupby('AgeGroup')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()    
        data_3b.loc[:, '% Coverage'] = np.round((data_3b['TX_PVLS (D)'] / data_3b['Eligible for VL']) * 100, decimals=1)
        data_3b.loc[:, '% Suppression'] = np.round((data_3b['TX_PVLS (N)'] / data_3b['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Ensure AgeGroup values are unique
        age_groups = data_3['AgeGroup'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f"{comd_name} Clients' Viral Load Suppression By Age Band"
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")

        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible for VL', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             

        source = ColumnDataSource(data_3b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        # Female Clients' Viral Load Suppression By Age Band
        data_4 = pvls_temp_tbl_age_comd_female[pvls_temp_tbl_age_comd_female['SurgeCommand'].isin(selected_commands)]    
        # Define the data source
        source = ColumnDataSource(data_4)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f"{comd_name} Female Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Female)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Female)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Female)"),
            'TX_PVLS (D, Female)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Female)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Female)"),
            'TX_PVLS (N, Female)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Female)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Female)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis        
        # Add value labels  
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Female)', text='Eligible (Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Female)', text='TX_PVLS (D, Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Female)', text='TX_PVLS (N, Female)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Female)', '% Suppression (Female)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_4)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'female tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsf_html = file_html((p, export_button), CDN, "plot10")


        # Male Clients' Viral Load Suppression By Age Band
        data_5 = pvls_temp_tbl_age_comd_male[pvls_temp_tbl_age_comd_male['SurgeCommand'].isin(selected_commands)]    
        # Define the data source
        source = ColumnDataSource(data_5)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f"{comd_name} Male Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Male)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Male)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Male)"),
            'TX_PVLS (D, Male)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Male)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Male)"),
            'TX_PVLS (N, Male)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Male)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Male)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Male)', text='Eligible (Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Male)', text='TX_PVLS (D, Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Male)', text='TX_PVLS (N, Male)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Male)', '% Suppression (Male)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_5)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'male tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsm_html = file_html((p, export_button), CDN, "plot11")


        data_7 = pvls_temp_tbl_all_age_comd[pvls_temp_tbl_all_age_comd['SurgeCommand'].isin(selected_commands)]   
        comd_categories = data_7['FacilityName'].unique()      
        data_7 = data_7.groupby('FacilityName')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()  
        data_7.loc[:, '% Coverage'] = np.round((data_7['TX_PVLS (D)'] / data_7['Eligible for VL']) * 100, decimals=1)
        data_7.loc[:, '% Suppression'] = np.round((data_7['TX_PVLS (N)'] / data_7['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Create a ColumnDataSource
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Viral Load Coverage & Suppression By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=comd_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html = file_html((p, export_button), CDN, "plot12")


        data_6 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        data_6b = data_6.groupby('Facility Name')[['Eligible for VL', 'VL sample taken in 1 year', 'TX_PVLS (D)', 'TX_PVLS (N)']].sum() 
        data_6b_df=data_6b.reset_index()   

        def get_map_tx_pvls(comd_name):
            # Function to get the TX_PVLS value for a given SurgeCommand
            tx_pvls_values = data_6b_df.groupby('Facility Name')['Eligible for VL'].sum()
            return tx_pvls_values.get(comd_name, "N/A")
        
        def get_map_tx_pvls2(comd_name):
            # Convert list to dictionary
            tx_pvls_cov_dict = dict(zip(data_6b_df['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (D)'] / data_6b_df['Eligible for VL']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_pvls_cov_dict.get(comd_name, "N/A")

        def get_map_tx_pvls3(comd_name):
            # Function to get the TX_PVLS value for a given SurgeCommand
            tx_pvls_sup_dict = dict(zip(data_6b_df['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (N)'] / data_6b_df['TX_PVLS (D)']) * 100, decimals=1))))
            return tx_pvls_sup_dict.get(comd_name, "N/A")
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                     
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['Facility Name', 'Eligible for VL'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name="Patients' Viral Load Suppression (PVLS)", nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = tx_pvls_temp_tbl[tx_pvls_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations            
        
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            tx_pvls_values = get_map_tx_pvls(loc["popup"])
            tx_pvls_formatted = format_with_thousand_separator(tx_pvls_values)     
            tx_pvls_cov_dict = get_map_tx_pvls2(loc["popup"])
            tx_pvls_sup_dict = get_map_tx_pvls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_pvls_formatted, 
                                                tx_pvls_cov_dict, 
                                                tx_pvls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        tx_pvls_button_json = json_item(export_button)    
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################   
        tx_pvls_comd3b = tx_pvls_comd3[tx_pvls_comd3['SurgeCommand'].isin(selected_commands)]   
        plot18_html = tx_pvls_comd3b.to_html(index=False, classes=['cascade', 'table table-bordered',"display"], escape=False)        
        
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_pvls_dict,
            'achieved': achieved_tx_pvls_dict,
            'achieved_pbs': achieved_pbs_tx_pvls_dict,
            'percent_pbs': percent_pbs_tx_pvls_dict,
            'achieved_recapture': achieved_pbs_rec_tx_pvls_dict,
            'percent_recaptured': percent_pbs_rec_tx_pvls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plotvlsf_html,
            'plot11': plotvlsm_html,
            'plot12': plot12_html,
            'plot17': {'main': plot17_html, 'additional': tx_pvls_button_json}, 
            'plot18': plot18_html,
            'plot19': plot19_html
        }      


    elif (selected_indicator == 'PBFW VLS' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        # Number of facilities
        fac_num_pbfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pbfw_vls_dict = int(data_1['PBFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pbfw_vls_dict = int(data_1['PBFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pbfw_vls_percent = (achieved_pbs_pbfw_vls_dict / achieved_pbfw_vls_dict) * 100
        percent_pbs_pbfw_vls_dict = f"{pbs_pbfw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pbfw_vls_dict = int(data_1['PBFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pbfw_vls_percent = (achieved_pbs_rec_pbfw_vls_dict / achieved_pbs_pbfw_vls_dict) * 100
        percent_pbs_rec_pbfw_vls_dict = f"{pbs_rec_pbfw_vls_percent:.1f}"       
        ############################################################################################
        # Create IP Summary Table
        data_1b = data_1.groupby('SurgeCommand', as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PBFW VLS (D)'] / data_1b['PBFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PBFW VLS (N)'] / data_1b['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant & Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['SurgeCommand']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PBFW VL Eligible': plot1.vbar(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), top='PBFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': plot1.vbar(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), top='PBFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': plot1.vbar(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), top='PBFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'SurgeCommand' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        data_2 = data_2.groupby(['SurgeCommand', 'mmd'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PBFW VLS (D)'] / data_2['PBFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PBFW VLS (N)'] / data_2['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant & Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PBFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pbfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        pbfw_vls_temp_tbl_age = pbfw_vls_temp_tbl_age.groupby(['SurgeCommand', 'AgeGroup'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        pbfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (D)'] / pbfw_vls_temp_tbl_age['PBFW VL Eligible']) * 100, decimals=1)
        pbfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (N)'] / pbfw_vls_temp_tbl_age['PBFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pbfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant & Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PBFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PBFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PBFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        # Ensure Facility values are unique
        comd_categories = data_7['FacilityName'].unique()   
        data_7b = data_7.groupby('FacilityName')[['PBFW VL Eligible','PBFW VLS (D)', 'PBFW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PBFW VLS (D)'] / data_7b['PBFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PBFW VLS (N)'] / data_7b['PBFW VLS (D)']) * 100, decimals=1)
        # Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant & Breastfeeding Women VLS By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=comd_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_pvls by Facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        data_6b = data_6.groupby('Facility Name')[['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pbfw_vls(comd_name):
            # Function to get the pbfw_vls value for a given SurgeCommand
            pbfw_vls_values = data_6b.groupby('Facility Name')['PBFW VL Eligible'].sum()
            return pbfw_vls_values.get(comd_name, "N/A")
        
        def get_map_pbfw_vls2(comd_name):
            # Convert list to dictionary
            pbfw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (D)'] / data_6b['PBFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pbfw_vls_cov_dict.get(comd_name, "N/A")

        def get_map_pbfw_vls3(comd_name):
            # Function to get the pbfw_vls value for a given SurgeCommand
            pbfw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (N)'] / data_6b['PBFW VLS (D)']) * 100, decimals=1))))
            return pbfw_vls_sup_dict.get(comd_name, "N/A")
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                      
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Pregnant & Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'PBFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant & Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations 
        
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            pbfw_vls_values = get_map_pbfw_vls(loc["popup"])
            pbfw_vls_formatted = format_with_thousand_separator(pbfw_vls_values)     
            pbfw_vls_cov_dict = get_map_pbfw_vls2(loc["popup"])
            pbfw_vls_sup_dict = get_map_pbfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pbfw_vls_formatted, 
                                                pbfw_vls_cov_dict, 
                                                pbfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pbfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        pbfw_pvls_temp_tbl_comd = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)] 
        plot19_html = pbfw_pvls_temp_tbl_comd.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pbfw_vls_dict,
            'achieved': achieved_pbfw_vls_dict,
            'achieved_pbs': achieved_pbs_pbfw_vls_dict,
            'percent_pbs': percent_pbs_pbfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pbfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pbfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': pbfw_vls_button_json}, 
            'plot19': plot19_html
        } 


    elif (selected_indicator == 'PW VLS' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        # Number of facilities
        fac_num_pw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pw_vls_dict = int(data_1['PW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pw_vls_dict = int(data_1['PW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_pw_vls_percent = (achieved_pbs_pw_vls_dict / achieved_pw_vls_dict) * 100
        percent_pbs_pw_vls_dict = f"{pbs_pw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_pw_vls_dict = int(data_1['PW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_pw_vls_percent = (achieved_pbs_rec_pw_vls_dict / achieved_pbs_pw_vls_dict) * 100
        percent_pbs_rec_pw_vls_dict = f"{pbs_rec_pw_vls_percent:.1f}"     
        ############################################################################################ 
        # Create IP Summary Table
        data_1b = data_1.groupby('SurgeCommand', as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PW VLS (D)'] / data_1b['PW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PW VLS (N)'] / data_1b['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['SurgeCommand']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PW VL Eligible': plot1.vbar(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), top='PW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': plot1.vbar(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), top='PW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': plot1.vbar(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), top='PW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), y='PW VL Eligible', text='PW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), y='PW VLS (D)', text='PW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), y='PW VLS (N)', text='PW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'SurgeCommand' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        data_2 = data_2.groupby(['SurgeCommand', 'mmd'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PW VLS (D)'] / data_2['PW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PW VLS (N)'] / data_2['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        pw_vls_temp_tbl_age = pw_vls_temp_tbl_age.groupby(['SurgeCommand', 'AgeGroup'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        pw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pw_vls_temp_tbl_age['PW VLS (D)'] / pw_vls_temp_tbl_age['PW VL Eligible']) * 100, decimals=1)
        pw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pw_vls_temp_tbl_age['PW VLS (N)'] / pw_vls_temp_tbl_age['PW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        comd_categories = data_7['FacilityName'].unique() 
        data_7b = data_7.groupby('FacilityName')[['PW VL Eligible','PW VLS (D)', 'PW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PW VLS (D)'] / data_7b['PW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PW VLS (N)'] / data_7b['PW VLS (D)']) * 100, decimals=1)
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Pregnant Women VLS By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=comd_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_pvls by facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        data_6b = data_6.groupby('Facility Name')[['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pw_vls(comd_name):
            # Function to get the pw_vls value for a given SurgeCommand
            pw_vls_values = data_6b.groupby('Facility Name')['PW VL Eligible'].sum()
            return pw_vls_values.get(comd_name, "N/A")
        
        def get_map_pw_vls2(comd_name):
            # Convert list to dictionary
            pw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (D)'] / data_6b['PW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pw_vls_cov_dict.get(comd_name, "N/A")

        def get_map_pw_vls3(comd_name):
            # Function to get the pw_vls value for a given SurgeCommand
            pw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (N)'] / data_6b['PW VLS (D)']) * 100, decimals=1))))
            return pw_vls_sup_dict.get(comd_name, "N/A")
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                  
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Pregnant Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'PW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = pw_pvls_temp_tbl[pw_pvls_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            pw_vls_values = get_map_pw_vls(loc["popup"])
            pw_vls_formatted = format_with_thousand_separator(pw_vls_values)     
            pw_vls_cov_dict = get_map_pw_vls2(loc["popup"])
            pw_vls_sup_dict = get_map_pw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pw_vls_formatted, 
                                                pw_vls_cov_dict, 
                                                pw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        pw_pvls_temp_tbl_comd = pw_pvls_temp_tbl[pw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)] 
        plot19_html = pw_pvls_temp_tbl_comd.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pw_vls_dict,
            'achieved': achieved_pw_vls_dict,
            'achieved_pbs': achieved_pbs_pw_vls_dict,
            'percent_pbs': percent_pbs_pw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': pw_vls_button_json}, 
            'plot19': plot19_html

        } 


    elif (selected_indicator == 'BFW VLS' and selected_commands):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]   
        # Number of facilities
        fac_num_bfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_bfw_vls_dict = int(data_1['BFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_bfw_vls_dict = int(data_1['BFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        pbs_bfw_vls_percent = (achieved_pbs_bfw_vls_dict / achieved_bfw_vls_dict) * 100
        percent_pbs_bfw_vls_dict = f"{pbs_bfw_vls_percent:.1f}"        
        # Biometrics Recaptured
        achieved_pbs_rec_bfw_vls_dict = int(data_1['BFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        pbs_rec_bfw_vls_percent = (achieved_pbs_rec_bfw_vls_dict / achieved_pbs_bfw_vls_dict) * 100
        percent_pbs_rec_bfw_vls_dict = f"{pbs_rec_bfw_vls_percent:.1f}"     
        ############################################################################################            
        # Create IP Summary Table
        data_1b = data_1.groupby('SurgeCommand', as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['BFW VLS (D)'] / data_1b['BFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['BFW VLS (N)'] / data_1b['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['SurgeCommand']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'BFW VL Eligible': plot1.vbar(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), top='BFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': plot1.vbar(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), top='BFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': plot1.vbar(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), top='BFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('SurgeCommand', -0.3, range=plot1.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', -0.1, range=plot1.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('SurgeCommand', 0.1, range=plot1.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('SurgeCommand', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'SurgeCommand' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        data_2 = data_2.groupby(['SurgeCommand', 'mmd'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['BFW VLS (D)'] / data_2['BFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['BFW VLS (N)'] / data_2['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # BFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        bfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        bfw_vls_temp_tbl_age = bfw_vls_temp_tbl_age.groupby(['SurgeCommand', 'AgeGroup'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        bfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (D)'] / bfw_vls_temp_tbl_age['BFW VL Eligible']) * 100, decimals=1)
        bfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (N)'] / bfw_vls_temp_tbl_age['BFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = bfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='BFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='BFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='BFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['SurgeCommand'].isin(selected_commands)] 
        data_7b = data_7.groupby('FacilityName')[['BFW VL Eligible','BFW VLS (D)', 'BFW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['BFW VLS (D)'] / data_7b['BFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['BFW VLS (N)'] / data_7b['BFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        comd_categories = data_7['FacilityName'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        plot_title = f'{comd_name} Breastfeeding Women VLS By Facility' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=comd_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_pvls by facility.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)]  
        data_6b = data_6.groupby('Facility Name')[['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_bfw_vls(comd_name):
            # Function to get the bfw_vls value for a given SurgeCommand
            bfw_vls_values = data_6b.groupby('Facility Name')['BFW VL Eligible'].sum()
            return bfw_vls_values.get(comd_name, "N/A")
        
        def get_map_bfw_vls2(comd_name):
            # Convert list to dictionary
            bfw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (D)'] / data_6b['BFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return bfw_vls_cov_dict.get(comd_name, "N/A")

        def get_map_bfw_vls3(comd_name):
            # Function to get the bfw_vls value for a given SurgeCommand
            bfw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (N)'] / data_6b['BFW VLS (D)']) * 100, decimals=1))))
            return bfw_vls_sup_dict.get(comd_name, "N/A")
        # Load GeoJSON file with Nigeria's SurgeCommand boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected SurgeCommands
        def filter_geojson(geo_data, selected_commands):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_commands]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_commands)        
                      
        # Get the coordinates for the first selected SurgeCommand
        comd_center = comd_coordinates.get(selected_commands[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=comd_center, zoom_start=8, height=450, width=600, tiles="cartodb positron")
        # Create a string that includes the selected SurgeCommand(s)
        comd_name = ', '.join([f'{command} Command' for command in selected_commands])
        # Update the HTML title to include the SurgeCommand names
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{comd_name} Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'BFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected SurgeCommands
        def get_locations_for_comds(selected_commands):
            locations = []
            for SurgeCommand in selected_commands:
                fac_names_in_comd = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['SurgeCommand'] == SurgeCommand]['Facility Name'].unique()
                for fac_name in fac_names_in_comd:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations    
            
        locations = get_locations_for_comds(selected_commands)
        # Add popup and tooltip for each SurgeCommand
        for loc in locations:
            bfw_vls_values = get_map_bfw_vls(loc["popup"])
            bfw_vls_formatted = format_with_thousand_separator(bfw_vls_values)     
            bfw_vls_cov_dict = get_map_bfw_vls2(loc["popup"])
            bfw_vls_sup_dict = get_map_bfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                bfw_vls_formatted, 
                                                bfw_vls_cov_dict, 
                                                bfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        bfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        bfw_pvls_temp_tbl_comd = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['SurgeCommand'].isin(selected_commands)] 
        plot19_html = bfw_pvls_temp_tbl_comd.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_bfw_vls_dict,
            'achieved': achieved_bfw_vls_dict,
            'achieved_pbs': achieved_pbs_bfw_vls_dict,
            'percent_pbs': percent_pbs_bfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_bfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_bfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': bfw_vls_button_json}, 
            'plot19': plot19_html

        } 


    ########################## Facility ###################### Facility ###################### Facility ########################
    ########################## Facility ###################### Facility ###################### Facility ########################and 
    elif selected_indicator == 'TX_CURR' and selected_facility:        
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment current indicator for selected Facility         
        data_1 = tx_curr_temp_tbl[tx_curr_temp_tbl['Facility Name'].isin(selected_facility)]  
        # print(data_1, end='\n')
        # Number of facilities
        fac_num_fac_curr_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_curr_dict_fac = int(data_1['TX_CURR'].sum())        
        # Biometrics Captured
        achieved_pbs_curr_dict_fac = int(data_1['Biometrics Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_curr_dict_fac > 0:
            pbs_curr_percent = (achieved_pbs_curr_dict_fac / achieved_tx_curr_dict_fac) * 100
            percent_pbs_curr_dict_fac = f"{pbs_curr_percent:.1f}"  
        else:
            percent_pbs_curr_dict_fac = None        
        # Biometrics Recaptured
        achieved_pbs_rec_tx_curr_dict_fac = int(data_1['Biometrics Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_curr_dict_fac > 0:
            pbs_rec_tx_curr_percent = (achieved_pbs_rec_tx_curr_dict_fac / achieved_pbs_curr_dict_fac) * 100
            percent_pbs_rec_tx_curr_dict_fac = f"{pbs_rec_tx_curr_percent:.1f}"     
        else:
            percent_pbs_rec_tx_curr_dict_fac = None 
        ############################################################################################
        # Handle data elements from the line list table        
        # Treatment Current By Pediatric & Adult Clients & Sex above 
        data_4 = df_curr_list[df_curr_list['FacilityName'].isin(selected_facility)]
        longfm1_fac_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_curr_widefm2_fac_age_sex = longfm1_fac_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='CurrentARTStatus_28Days')
        # Initialize plot1_html_fac to avoid UnboundLocalError
        plot1_html_fac = None
        # Ensure the pivot table has the expected columns
        expected_columns = ['Female', 'Male']
        missing_columns = [col for col in expected_columns if col not in tx_curr_widefm2_fac_age_sex.columns]
        if not missing_columns:
            # Create a title string that includes the selected Facility
            fac_name = ', '.join(selected_facility)
            plot_title = f'{fac_name} Treatment Current By Pediatric & Adult Clients & Sex'

            plot1=tx_curr_widefm2_fac_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                                fontsize={'xticks': 10, 'yticks': 10, 'title': 10},  width=plot_width, height=height, 
                                                title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")
        
            # Convert HoloViews object to Bokeh model'%.0f'
            bokeh_model = hv.render(plot1, backend='bokeh')
            # Adjust y-axis tick formatter to disable scientific notation and set to integer format
            bokeh_model.yaxis.formatter.use_scientific = False
            bokeh_model.yaxis.formatter.precision = 0
            # Format y-axis ticks with commas for thousand separators
            bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
            # Define hover tool with custom formatters
            hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_CURR', '@value{0,0}')])
            # Add hover tool to the plot
            bokeh_model.add_tools(hover)
            # Adjusting toolbar size
            bokeh_model.toolbar.autohide = True
        else:
            # Handle the case where the expected columns are missing
            bokeh_model = None      
        # Add the Bokeh model to the New document if it is not None
        if bokeh_model is not None:
            curdoc().add_root(bokeh_model)
            # Convert Bokeh model to JSON to embed in HTML
            plot1_html_fac = json_item(bokeh_model)
        else:
            # Handle the case where bokeh_model is None
            print("No valid data to display the plot")      
        
        # Create csv table for export
        source = ColumnDataSource(tx_curr_widefm2_fac_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr peed&adult age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)           
        button_json_fac = json_item(export_button)
        
                                       
        # Treatment Current Distribution By Sex 
        data_5 = df_curr_list[df_curr_list['FacilityName'].isin(selected_facility)]        
        data_5agg = data_5.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        # Define the Spectral color palette with supported sizes
        supported_sizes = [6, 7]
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))       
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b['Sex'].unique())
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:num_colors]   

        # data_5b['color'] = ["#2b9eb0", "#9ecae1"]         
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment Current By Sex'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html_fac = file_html((chart, export_button), CDN, "plot2")

       
        # Treatment Current By AgeGroup & Sex   
        data_2 = df_curr_list[df_curr_list['FacilityName'].isin(selected_facility)]     
        age_group_tx_curr = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
        age_group_tx_curr = age_group_tx_curr.set_index('AgeGroup')
        # Create a data source for Bokeh
        source = ColumnDataSource(age_group_tx_curr)
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment Current By 5-Year Age Band & Sex'
        plot3 = age_group_tx_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
        # Set the width and height of the plot
        plot3.plot.width = plot_width
        # Adjusting toolbar size
        plot3.toolbar.autohide = True
        # Remove the space between y-axis and the plot
        plot3.toolbar.logo = None
        plot3.x_range.start = 0        
        plot3.toolbar.active_scroll = None
        plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')        
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_curr)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html_fac = file_html((plot3, export_button), CDN, "plot3")


        # Biometrics Treatment Current By Age Group & Sex
        # Filter the data
        data_3 = df_pbs_list[df_pbs_list['FacilityName'].isin(selected_facility)]
        # Create crosstab
        age_group_pbs_curr = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_pbs_curr = age_group_pbs_curr.set_index('AgeGroup')
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(age_group_pbs_curr)
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment Current Biometrics By 5-Year Age Band & Sex'
        # Plot 
        plot4 = age_group_pbs_curr.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
        plot4.plot.width = plot_width
        # Adjusting toolbar size
        plot4.toolbar.autohide = True
        plot4.toolbar.logo = None       
        # Remove the space between y-axis and the plot
        plot4.x_range.start = 0       
        plot4.toolbar.active_scroll = None
        plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_curr 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html_fac = file_html((plot4, export_button), CDN, "plot4")
             

        # Treatment Current MMD Distribution
        data_5 = df_curr_list[df_curr_list['FacilityName'].isin(selected_facility)]        
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()        
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.41
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.41

        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        data_5b["value"] = data_5b['value'].astype(str)
        data_5b["value"] = data_5b["value"].str.pad(35, side="left")
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment Current By Multi-Month Dispensing (MMD)'
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@mmd: @formatted_value, Percentage: @percentage{0.0}%",x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, inner_radius=0.20, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='mmd', source=source)
      
        # Callouts for labels
        callouts = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-25, source=source, render_mode='canvas',
                            text_align="center", angle=0, text_font_size='10pt', text_color='#000000')
        chart.add_layout(callouts)
        percentage_callouts = LabelSet(x="cos2", y="sin2", y_offset=-25, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')
        chart.add_layout(percentage_callouts)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None   
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html_fac = file_html((chart, export_button), CDN, "plot5")


        # Treatment Current By MMD & 5-Year Age Band
        data_7 = df_curr_list[df_curr_list['FacilityName'].isin(selected_facility)]     
        # Perform crosstab to get counts by AgeGroup and MMD
        tx_curr_age_mmd = pd.crosstab(data_7['AgeGroup'], data_7['mmd']).reset_index()
        # Convert the DataFrame to a ColumnDataSource
        source = ColumnDataSource(tx_curr_age_mmd)
        # List of MMD factors
        # mmd_factors = tx_curr_age_mmd.columns[1:]
        mmd_factors = list(tx_curr_age_mmd.columns[1:])
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment Current By MMD & 5-Year Age Band'
        # Create the Bokeh figure for stacked column chart
        plot = figure(x_range=tx_curr_age_mmd['AgeGroup'], 
                    title=plot_title, x_axis_label="", y_axis_label="Number of clients", 
                    height=height, plot_width=plot_width, toolbar_location='right', 
                    tools=[CrosshairTool(), PanTool(), BoxZoomTool(), SaveTool(), ResetTool()])

        # Add a HoverTool to display details on hover
        hover = HoverTool(tooltips=[("Age Band", "@AgeGroup"), ("MMD", "$name"), ("TX_CURR", "@$name{0,0}")])
        plot.add_tools(hover)
        # Add stacked columns to the figure
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))       
        # Get the closest supported size for the Spectral palette
        num_colors = len(mmd_factors)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        colors = color_palette[:num_colors]  
        # colors = ["#2b9eb0", '#2beaea', '#2b9eea', "#9ecae1"]
        plot.vbar_stack(stackers=mmd_factors, x='AgeGroup', width=0.8, color=colors, 
                        source=source, legend_label=[str(mmd) for mmd in mmd_factors])
        # Customize plot
        plot.xaxis.major_label_orientation = 1.2
        plot.toolbar.logo = None
        plot.y_range.start = 0 
        # Format y-axis with thousand separators
        plot.yaxis.formatter = NumeralTickFormatter(format="0,0")
        # Add legend click policy
        plot.legend.click_policy = "hide"
        plot.toolbar.autohide = True
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr by MMD & 5yr age.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label="Export CSV", button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html_fac = file_html((plot, export_button), CDN, "plot6")


        # Treatment Current Distribution
        data_8 = tx_curr_temp_tbl[tx_curr_temp_tbl['Facility Name'].isin(selected_facility)] 
        data_8agg = data_8.groupby('Facility Name')[['TX_CURR']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_CURR']]   
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment Current'     
        plot9=data_8_sum.hvplot.bar(x="Facility Name", y='TX_CURR', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_CURR")                                

        labels = hv.Labels(data=data_8_sum, kdims=['Facility Name', 'TX_CURR'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # # Add HoverTool with formatted tooltips
        # hover = HoverTool()
        # hover.tooltips = [("Facility", "@Facility Name"), ("TX_CURR", "@TX_CURR{0,0}")]
        # bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility tx_curr.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html_fac = file_html((bokeh_model, export_button), CDN, "plot9")           


        # Treatment Current Map
        data_6 = tx_curr_temp_tbl[tx_curr_temp_tbl['Facility Name'].isin(selected_facility)]  
        data_6b = data_6.groupby('Facility Name')[['TX_CURR','Biometrics Captured', 'Biometrics Recaptured']].sum()   
        data_6b_curr=data_6b.reset_index()  

        def get_map_tx_curr(fac_name_name):
            # Function to get the TX_CURR value for a given Facility Name
            tx_curr_values = tx_curr_temp_tbl.groupby('Facility Name')['TX_CURR'].sum()
            return tx_curr_values.get(fac_name_name, "N/A")
                    
        def get_map_tx_curr2(fac_name_name):
            # Convert list to dictionary
            tx_curr_cap_dict = dict(zip(data_6b_curr['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Captured'] / data_6b_curr['TX_CURR']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_curr_cap_dict.get(fac_name_name, "N/A")

        def get_map_tx_curr3(fac_name_name):
            # Function to get the TX_PVLS value for a given Facility Name
            tx_curr_recap_dict = dict(zip(data_6b_curr['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_curr['Biometrics Recaptured'] / data_6b_curr['Biometrics Captured']) * 100, decimals=1))))
            return tx_curr_recap_dict.get(fac_name_name, "N/A")
        
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)
        
        # Define coordinates for the center of each Facility Name and Get the coordinates for the first selected Facility Name
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600
                            # , tiles="cartodb positron"
                            )
        # Create a string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        # Update the HTML title to include the Facility Name
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_name} Treatment Current Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))

        folium.Choropleth(
            geo_data=filtered_geo_data, name='choropleth', data=data_6b_curr, columns=['Facility Name', 'TX_CURR'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_CURR', highlight=True).add_to(ng_map)

        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_CURR: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''        
        # Define a function to get locations for the selected Facility
        def get_locations_for_facs(selected_facility):            
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = tx_curr_temp_tbl[tx_curr_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_facs(selected_facility)
        
        for loc in locations:
            tx_curr_value = get_map_tx_curr(loc["popup"])
            tx_curr_formatted = format_with_thousand_separator(tx_curr_value)            
            tx_curr_cap_dict = get_map_tx_curr2(loc["popup"])
            tx_curr_recap_dict = get_map_tx_curr3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_curr_formatted, 
                                                tx_curr_cap_dict, 
                                                tx_curr_recap_dict) 
            
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_curr)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_curr distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_curr_button_json_fac = json_item(export_button)
        # Convert map to HTML
        plot17_html_fac = ng_map.get_root().render()      

        ####################### DATATABLE ######################################################################################
        plot19_html_fac = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_fac_curr_dict,
            'achieved': achieved_tx_curr_dict_fac,
            'achieved_pbs': achieved_pbs_curr_dict_fac,
            'percent_pbs': percent_pbs_curr_dict_fac,
            'achieved_recapture': achieved_pbs_rec_tx_curr_dict_fac,
            'percent_recaptured': percent_pbs_rec_tx_curr_dict_fac,
            'plot1': {'main': plot1_html_fac, 'additional': button_json_fac},
            'plot2': plot2_html_fac,
            'plot3': plot3_html_fac,
            'plot4': plot4_html_fac,
            'plot5': plot5_html_fac,
            'plot6': plot6_html_fac,
            'plot9': plot9_html_fac,
            'plot17': {'main': plot17_html_fac, 'additional': tx_curr_button_json_fac}, 
            'plot19': plot19_html_fac
        }   


    elif (selected_indicator == 'TX_NEW' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_new_temp_tbl[tx_new_temp_tbl['Facility Name'].isin(selected_facility)]
        # Number of facilities
        fac_num_tx_new_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_new_dict = int(data_1['TX_NEW'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_new_dict = int(data_1['TX_NEW Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_new_dict > 0:
            pbs_new_percent = (achieved_pbs_tx_new_dict / achieved_tx_new_dict) * 100
            percent_pbs_tx_new_dict = f"{pbs_new_percent:.1f}"   
        else:
            percent_pbs_tx_new_dict = None     
        # Biometrics Recaptured
        achieved_pbs_rec_tx_new_dict = int(data_1['TX_NEW Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_new_dict > 0:
            pbs_rec_tx_new_percent = (achieved_pbs_rec_tx_new_dict / achieved_pbs_tx_new_dict) * 100
            percent_pbs_rec_tx_new_dict = f"{pbs_rec_tx_new_percent:.1f}"  
        else:
            percent_pbs_rec_tx_new_dict = None                   
        ############################################################################################
        # Handle data elements from the line list table               
        data_4 = df_new_list[df_new_list['FacilityName'].isin(selected_facility)]
        # Initialize age_sex_tx_new_month1 to an empty DataFrame to avoid UnboundLocalError
        tx_new_widefm2_fac_age_sex = pd.DataFrame()
        bokeh_model = None
        plot1_html = None  # Initialize plot1_html

        # Check if data_4 is not empty
        if not data_4.empty:
            # Ensure 'AgeGroup2' column is not empty and create the pivot table
            longfm1_fac_age_sex = data_4.query("AgeGroup2 != ''").groupby(['AgeGroup2', 'Sex']).count()

            if not longfm1_fac_age_sex.empty:
                tx_new_widefm2_fac_age_sex = longfm1_fac_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_NEW')

                # Ensure the pivot table has the expected columns
                expected_columns = ['Female', 'Male']
                missing_columns = [col for col in expected_columns if col not in tx_new_widefm2_fac_age_sex.columns]

                if not missing_columns:
                    # Create a title string that includes the selected Facility
                    fac_names = ', '.join(selected_facility)
                    plot_title = f'{fac_names} Treatment New By Pediatric & Adult Clients & Sex'
                    # Create the plot
                    plot1 = tx_new_widefm2_fac_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                                            fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height,
                                                            title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar="right")

                    # Convert HoloViews object to Bokeh model
                    bokeh_model = hv.render(plot1, backend='bokeh')
                    # Adjust y-axis tick formatter to disable scientific notation and set to integer format
                    bokeh_model.yaxis.formatter.use_scientific = False
                    bokeh_model.yaxis.formatter.precision = 0
                    # Format y-axis ticks with commas for thousand separators
                    bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
                    # Define hover tool with custom formatters
                    hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_NEW', '@value{0,0}')])
                    # Add hover tool to the plot
                    bokeh_model.add_tools(hover)
                    # Adjusting toolbar size
                    bokeh_model.toolbar.autohide = True
                else:
                    # Handle the case where the expected columns are missing
                    bokeh_model = None
            else:
                # Handle the case where the groupby and pivot result in an empty DataFrame
                bokeh_model = None
        else:
            # Handle the case where data_4 is empty
            bokeh_model = None

        # Add the Bokeh model to the New document if it is not None
        if bokeh_model is not None:
            curdoc().add_root(bokeh_model)
            plot1_html = json_item(bokeh_model)  # Assign plot1_html here
        else:
            # Handle the case where bokeh_model is None
            print("No valid data to display the plot")

        # Create csv table for export
        source = ColumnDataSource(tx_new_widefm2_fac_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Ensure plot1_html is defined before returning it
        if plot1_html is not None:
            plot3_html = plot1_html
        else:
            print("No valid data to display the plot")

            
        # Convert Bokeh model to JSON to embed in HTML
        if bokeh_model is not None:
            plot1_html = json_item(bokeh_model)
        else:
            # Handle the case where bokeh_model is None
            print("No valid data to display the plot")        
        button_json = json_item(export_button)


        # Treatment New CD4 Distribution
        data_5 = df_cd4_new_list[df_cd4_new_list['FacilityName'].isin(selected_facility)]   
        data_5agg = pd.DataFrame()    
        chart = None 
        data_5agg = data_5.TX_NEW_CD4.value_counts().reset_index().rename(columns={'index':'TX_NEW_CD4', 'TX_NEW_CD4':'value'})
        data_5b = data_5agg.copy()        

        total_count = data_5b['value'].sum()
        value = data_5b["value"].values
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)]        
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b) 
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Treatment New By CD4 Count' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_NEW_CD4: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_NEW_CD4', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
                        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        if chart is not None:
            plot2_html = file_html((chart, export_button), CDN, "plot2")
        else:
            print("No valid data to display the plot")   

               
        # Treatment New By AgeGroup & Sex
        data_2 = df_new_list[df_new_list['FacilityName'].isin(selected_facility)]
        age_group_tx_new = pd.DataFrame()
        plot3 = None  # Define plot3 initially as None
        plot3_html = None  # Initialize plot1_html
        # Check if data_2 is not empty
        if not data_2.empty:
            age_group_tx_new = pd.crosstab(data_2['AgeGroup'], data_2['Sex']).reset_index()
            age_group_tx_new = age_group_tx_new.set_index('AgeGroup')

            # Check if the crosstab result is not empty
            if not age_group_tx_new.empty:
                # Create a title string that includes the selected Facility
                fac_names = ', '.join(selected_facility)
                plot_title = f'{fac_names} Treatment New By 5-Year Age Band & Sex'
                plot3 = age_group_tx_new.plot_bokeh.barh(title=plot_title, legend="bottom_right", line_width=5.0, show_figure=False)
                
                # Set the width and height of the plot
                plot3.plot.width = plot_width
                # Adjusting toolbar size
                plot3.toolbar.autohide = True
                # Remove the space between y-axis and the plot
                plot3.x_range.start = 0
                plot3.toolbar.logo = None
                plot3.toolbar.active_scroll = None
                plot3.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
            else:
                print("No data available for the selected facility(s) in the specified age bands and sexes.")
        else:
            print("No data available for the selected facility(s).")

        # Create csv table for export
        source = ColumnDataSource(age_group_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        if plot3 is not None:
            plot3_html = file_html((plot3, export_button), CDN, "plot3")
        else:
            print("No valid data to display the plot")         


        # Biometrics Treatment New By Age Group & Sex
        data_3 = df_pbs_new_list[df_pbs_new_list['FacilityName'].isin(selected_facility)]
        age_group_pbs_tx_new = pd.DataFrame()
        plot4 = None  # Define plot3 initially as None
        plot4_html = None
        # Check if data_2 is not empty
        if not data_3.empty:
            age_group_pbs_tx_new = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
            age_group_pbs_tx_new = age_group_pbs_tx_new.set_index('AgeGroup')
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} Treatment New Biometrics By 5-Year Age Band & Sex' 
            plot4 = age_group_pbs_tx_new.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
            plot4.plot.width = plot_width
            # Adjusting toolbar size
            plot4.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot4.x_range.start = 0
            plot4.toolbar.logo = None   
            plot4.toolbar.active_scroll = None
            plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        else:
            print("No valid data to display the plot")  
        # Create csv table for export
        source = ColumnDataSource(age_group_pbs_tx_new)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new pbs by age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        if plot4 is not None:
            plot4_html = file_html((plot4, export_button), CDN, "plot4")
        else:
            print("No valid data to display the plot")         


        # TX_NEW By Month 
        data_8 = df_new_list[df_new_list['FacilityName'].isin(selected_facility)]
        data_8agg = data_8.TX_NEW_month.value_counts().reset_index().rename(columns={'index':'TX_NEW_month', 'TX_NEW_month':'value'})
        data_8_count = data_8agg.copy()
        data_8_count['formatted_value']=["{:,.0f}".format(val) for val in data_8_count['value']]    
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} TX_NEW By Month'     
        plot5new_days=data_8_count.hvplot.bar(x="TX_NEW_month", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='',  width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW_month")                                

        labels = hv.Labels(data=data_8_count, kdims=['TX_NEW_month', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format="0,0")
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new by month.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotnew_month_html = file_html((bokeh_model, export_button), CDN, "plot5")


        # Treatment New in Month 1 By AgeGroup & Sex
        data_9 = df_new_listmth1[df_new_listmth1['FacilityName'].isin(selected_facility)]
        # Initialize age_sex_tx_new_month1 to an empty DataFrame to avoid UnboundLocalError
        age_sex_tx_new_month1 = pd.DataFrame()
        # Check if data is not empty
        if not data_9.empty:
            # Create the crosstab
            age_sex_tx_new_month1 = pd.crosstab(data_9['AgeGroup'], data_9['Sex']).reset_index()
            age_sex_tx_new_month1 = age_sex_tx_new_month1.set_index('AgeGroup')
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} Treatment New In Month 1 By 5-Year Age Band & Sex'
            plot6 = age_sex_tx_new_month1.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False) 
            plot6.plot.width = plot_width
            plot6.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot6.y_range.start = 0
            plot6.toolbar.logo = None
            plot6.toolbar.active_scroll = None
            plot6.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        else:
            # Handle the case where data_10 is empty
            plot6 = None

        # Create csv table for export
        source = ColumnDataSource(age_sex_tx_new_month1)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'month 1 tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((plot6, export_button), CDN, "plot6") if plot6 else "<p>No Treatment New in Month 1 for the selected facility(s)</p>"


        # Treatment New in Month 2 By AgeGroup & Sex
        # Filter data based on the selected facility
        data_10 = df_new_listmth2[df_new_listmth2['FacilityName'].isin(selected_facility)]
        # Initialize age_sex_tx_new_month2 to an empty DataFrame to avoid UnboundLocalError
        age_sex_tx_new_month2 = pd.DataFrame()
        # Check if data is not empty
        if not data_10.empty:
            # Create the crosstab
            age_sex_tx_new_month2 = pd.crosstab(data_10['AgeGroup'], data_10['Sex']).reset_index()
            age_sex_tx_new_month2 = age_sex_tx_new_month2.set_index('AgeGroup')
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} Treatment New In Month 2 By 5-Year Age Band & Sex'
            # Create the plot
            plot9 = age_sex_tx_new_month2.plot_bokeh.bar(title=plot_title, legend = "top_right",line_width=8.0, show_figure=False) 
            # Set the width of the plot
            plot9.plot.width = 800
            # Adjusting toolbar size
            plot9.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot9.y_range.start = 0
            plot9.toolbar.logo = None
            plot9.toolbar.active_scroll = None
            plot9.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        else:
            # Handle the case where data_10 is empty
            plot9 = None

        # Create csv table for export
        source = ColumnDataSource(age_sex_tx_new_month2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'month 2 tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((plot9, export_button), CDN, "plot9") if plot9 else "<p>No Treatment New in Month 2 for the selected facility(s)</p>"


        # Treatment New in Month 3 By AgeGroup & Sex
        data_11 = df_new_listmth3[df_new_listmth3['FacilityName'].isin(selected_facility)]
        # Initialize age_sex_tx_new_month3 to an empty DataFrame to avoid UnboundLocalError
        age_sex_tx_new_month3 = pd.DataFrame()
        # Check if data is not empty
        if not data_11.empty:
            # Create the crosstab
            age_sex_tx_new_month3 = pd.crosstab(data_11['AgeGroup'], data_11['Sex']).reset_index()
            age_sex_tx_new_month3 = age_sex_tx_new_month3.set_index('AgeGroup')
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} Treatment New In Month 3 By 5-Year Age Band & Sex'
            # Set the width of the plot
            plot10.plot.width = 800
            # Adjusting toolbar size
            plot10.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot10.y_range.start = 0
            plot10.toolbar.logo = None
            plot10.toolbar.active_scroll = None
            plot10.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        else:
            # Handle the case where data is empty
            plot10 = None

        # Create csv table for export
        source = ColumnDataSource(age_sex_tx_new_month3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'month 3 tx_new 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((plot10, export_button), CDN, "plot10") if plot10 else "<p>No Treatment New in Month 3 for the selected facility(s)</p>"
        
                                       
        # Treatment New ML Distribution
        data_7 = df_ml_new_list[df_ml_new_list['FacilityName'].isin(selected_facility)]            
        data_7agg = data_7['TX_NEW ML'].value_counts().reset_index().rename(columns={'index':'TX_NEW ML', 'TX_NEW ML':'value'})
        data_7b = data_7agg.copy()
        if not data_7b.empty:
            total_count = data_7b['value'].sum()
            value = data_7b["value"].values
            data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
            data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
            data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.28
            data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.28
            data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
            data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
            data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
            data_7b['percentage'] = (data_7b['value'] / total_count) * 100
            data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
            # Define the Spectral color palette with supported sizes
            supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
            # Function to get the closest supported size for the Spectral palette
            def get_closest_palette_size(num_colors):
                return min(supported_sizes, key=lambda x: abs(x - num_colors))        
            # Get the closest supported size for the Spectral palette
            num_colors = len(data_7b)
            closest_size = get_closest_palette_size(num_colors)
            color_palette = Spectral[closest_size]
            # Repeat colors if there are more items than colors in the palette
            if num_colors > closest_size:
                color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

            data_7b['color'] = color_palette[:len(data_7b)]    
            # Pad the 'value' column with spaces to improve label alignment
            data_7b["value"] = data_7b['value'].astype(str)
            # Convert DataFrame to ColumnDataSource
            source = ColumnDataSource(data_7b)
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(fac_names, total_count)
            # Creating chart vertical
            chart = figure(height=height, width=620, title=plot_title, 
                            toolbar_location="above",  # Show toolbar above the plot
                            tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                            tooltips="@TX_NEW ML: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
            # Creating sectors
            chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                                start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                                line_color="white", fill_color='color', legend_field='TX_NEW ML', source=source)
            # Adding labels
            labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-9, source=source, render_mode='canvas',text_align="center", angle=0,
                    text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
            percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-9, text='label', text_align="center", angle=0, source=source,
                            render_mode='canvas', text_font_size='10pt', text_color='#000000')

            chart.add_layout(labels)
            chart.add_layout(percentage_labels)
            # Clearing interface
            chart.axis.axis_label=None
            chart.axis.visible=False
            chart.grid.grid_line_color = None
            # Remove Bokeh logo from the toolbar
            chart.toolbar.logo = None
            # Adjusting toolbar size
            chart.toolbar.autohide = True
            # Adjusting legend label size
            chart.legend.label_text_font_size = '9pt'
            chart.outline_line_color = None  
            
            # Create csv table for export
            source = ColumnDataSource(data_7agg)
            # CustomJS callback to export CSV
            export_csv_js = CustomJS(args=dict(source=source), code="""
                function table_to_csv(source) {
                    const columns = Object.keys(source.data);
                    const nrows = source.get_length();
                    const lines = [columns.join(',')];

                    for (let i = 0; i < nrows; i++) {
                        let row = [];
                        for (let col of columns) {
                            row.push(source.data[col][i]);
                        }
                        lines.push(row.join(','));
                    }
                    return lines.join('\\n').concat('\\n');
                }

                const filename = 'tx_new ml.csv';
                const filetext = table_to_csv(source);
                const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

                // Addresses IE
                if (navigator.msSaveBlob) {
                    navigator.msSaveBlob(blob, filename);
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.target = "_blank";
                    link.style.visibility = 'hidden';
                    link.dispatchEvent(new MouseEvent('click'));
                }
            """)
            # Button for exporting CSV
            export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
            export_button.js_on_click(export_csv_js)
            plot11_html = file_html((chart, export_button), CDN, "plot11") if chart else "<p>No TX_NEW ML for the selected facility(s)</p>"
        else:
            # Handle the empty data case
            plot11_html = "No Treatment New Mortality & Loss (TX_NEW ML) data available to plot."  

        # Treatment New Distribution
        data_11 = tx_new_temp_tbl[tx_new_temp_tbl['Facility Name'].isin(selected_facility)] 
        data_11agg = data_11.groupby('Facility Name')[['TX_NEW']].sum().reset_index()    
        data_11_sum = data_11agg.copy()
        data_11_sum['formatted_value']=["{:,.0f}".format(val) for val in data_11_sum['TX_NEW']]   
        # Create a title string that includes the selected Facility
        fac_name = ', '.join(selected_facility)
        plot_title = f'{fac_name} Treatment New'     
        plot12=data_11_sum.hvplot.bar(x="Facility Name", y='TX_NEW', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_NEW")                                

        labels = hv.Labels(data=data_11_sum, kdims=['Facility Name', 'TX_NEW'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot12 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_11agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility TX_NEW.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html_fac = file_html((bokeh_model, export_button), CDN, "plot12")    


        data_6 = tx_new_temp_tbl[tx_new_temp_tbl['Facility Name'].isin(selected_facility)]   
        data_6b = data_6.groupby('Facility Name')['TX_NEW', 'TX_NEW month 1','TX_NEW month 2', 'TX_NEW month 3'].sum()   
        data_6b_new=data_6b.reset_index() 

        def get_map_tx_new(fac_name):
            # Function to get the TX_NEW value for a given Facility Name
            tx_new_values = data_6b_new.groupby('Facility Name')['TX_NEW'].sum()
            return tx_new_values.get(fac_name, "N/A")
        
        def get_map_tx_new_month_1(fac_name):
            # Function to get the TX_NEW value for a given Facility Name
            tx_new_month_1 = data_6b_new.groupby('Facility Name')['TX_NEW month 1'].sum()
            return tx_new_month_1.get(fac_name, "N/A")
        
        def get_map_tx_new_month_2(fac_name):
            # Function to get the TX_NEW value for a given Facility Name
            tx_new_month_2 = data_6b_new.groupby('Facility Name')['TX_NEW month 2'].sum()
            return tx_new_month_2.get(fac_name, "N/A")
        
        def get_map_tx_new_month_3(fac_name):
            # Function to get the TX_NEW value for a given Facility Name
            tx_new_month_3 = data_6b_new.groupby('Facility Name')['TX_NEW month 3'].sum()
            return tx_new_month_3.get(fac_name, "N/A")

        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)
        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600
                            # , tiles="cartodb positron"
                            )
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility Name
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Treatment New Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_new, columns=['Facility Name', 'TX_NEW'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_NEW', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_NEW: {}<br>
                Month 1: {}<br>
                Month 2: {}<br>
                Month 3: {}
            </div>
        '''
        # Define a function to get locations for the selected Facility
        def get_locations_for_facs(selected_facility):
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = tx_new_temp_tbl[tx_new_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            tx_new_value = get_map_tx_new(loc["popup"])
            tx_new_formatted = format_with_thousand_separator(tx_new_value)  
            tx_new_month_1 = get_map_tx_new_month_1(loc["popup"])
            tx_new_mth_1_formatted = format_with_thousand_separator(tx_new_month_1) 

            tx_new_month_2 = get_map_tx_new_month_2(loc["popup"])
            tx_new_mth_2_formatted = format_with_thousand_separator(tx_new_month_2) 

            tx_new_month_3 = get_map_tx_new_month_3(loc["popup"])
            tx_new_mth_3_formatted = format_with_thousand_separator(tx_new_month_3)             
            
            popup_content = popup_style.format(loc["popup"], tx_new_formatted, tx_new_mth_1_formatted,
                                               tx_new_mth_2_formatted, tx_new_mth_3_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_new)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_new distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)        
        # Convert Bokeh model to JSON to embed in HTML          
        tx_new_button_json = json_item(export_button)
        # Convert map to HTML
        plot17_html = ng_map.get_root().render()
        
        
        ####################### DATATABLE ######################################################################################
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)
  
        data_response = {
            'fac_num': fac_num_tx_new_dict,
            'achieved': achieved_tx_new_dict,
            'achieved_pbs': achieved_pbs_tx_new_dict,
            'percent_pbs': percent_pbs_tx_new_dict,
            'achieved_recapture': achieved_pbs_rec_tx_new_dict,
            'percent_recaptured': percent_pbs_rec_tx_new_dict,
            'plot1': {'main': plot1_html, 'additional': button_json}, 
            'plot2': plot2_html,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plotnew_month_html,
            'plot6': plot6_html, 
            'plot9': plot9_html,  
            'plot10': plot10_html, 
            'plot11': plot11_html,        
            'plot12': plot12_html_fac,   
            'plot17': {'main': plot17_html, 'additional': tx_new_button_json}, 
            'plot19': plot19_html
        }       


    elif (selected_indicator == 'TX_ML' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment ml indicator
        data_1 = tx_ml_df[tx_ml_df['Facility Name'].isin(selected_facility)]
        # Number of facilities
        fac_num_tx_ml_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_ml_dict = int(data_1['TX_ML'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_ml_dict = int(data_1['TX_ML Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_ml_dict > 0:
            pbs_ml_percent = (achieved_pbs_tx_ml_dict / achieved_tx_ml_dict) * 100
            percent_pbs_tx_ml_dict = f"{pbs_ml_percent:.1f}"    
        else:
            percent_pbs_tx_ml_dict = None      
        # Biometrics Recaptured
        achieved_pbs_rec_tx_ml_dict = int(data_1['TX_ML Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_ml_dict > 0:
            pbs_rec_tx_ml_percent = (achieved_pbs_rec_tx_ml_dict / achieved_pbs_tx_ml_dict) * 100
            percent_pbs_rec_tx_ml_dict = f"{pbs_rec_tx_ml_percent:.1f}"    
        else:
            percent_pbs_rec_tx_ml_dict = None      
        #################################################################################################
        # Treatment Mortality & Loss By Pediatric & Adult Clients & Sex
        data_4 = df_ml_list[df_ml_list['FacilityName'].isin(selected_facility)]
        longfm1_fac_age_sex = data_4.query("AgeGroup2 !=''").groupby(['AgeGroup2', 'Sex']).count()
        tx_ml_widefm2_fac_age_sex = longfm1_fac_age_sex.reset_index().pivot(index='AgeGroup2', columns='Sex', values='TX_ML')
         # Initialize plot1_html_fac to avoid UnboundLocalError
        plot1_html = None
        # Ensure the pivot table has the expected columns
        expected_columns = ['Female', 'Male']
        missing_columns = [col for col in expected_columns if col not in tx_ml_widefm2_fac_age_sex.columns]
        if not missing_columns:
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} Treatment Mortality & Loss By Pediatric & Adult Clients & Sex' 
            plot1ml=tx_ml_widefm2_fac_age_sex.hvplot(kind='bar', y=['Female', 'Male'], xlabel='', ylabel="", grid=True, line_color=None,  # Remove the border completely
                                            fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, width=plot_width, height=height, 
                                            title=plot_title).opts(
                                            hooks=[remove_bokeh_logo], toolbar="right")
        
            # Convert HoloViews object to Bokeh model
            bokeh_model = hv.render(plot1ml, backend='bokeh')
            # Adjust y-axis tick formatter to disable scientific notation and set to integer format
            bokeh_model.yaxis.formatter.use_scientific = False
            bokeh_model.yaxis.formatter.precision = 0
            # Format y-axis ticks with commas for thousand separators
            bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
            # Define hover tool with custom formatters
            hover = HoverTool(tooltips=[('Age Band', '@AgeGroup2'), ('Sex', '@Sex'), ('TX_ML', '@value{0,0}')])
            # Add hover tool to the plot
            bokeh_model.add_tools(hover)
            # Adjusting toolbar size
            bokeh_model.toolbar.autohide = True
        else:
            bokeh_model = None
        
        # Add the Bokeh model to the New document if it is not None
        if bokeh_model is not None:
            curdoc().add_root(bokeh_model)
            plot1_html = json_item(bokeh_model)
        else:
            # Handle the case where bokeh_model is None
            print("No valid data to display the plot")
        
        # Create csv table for export
        source = ColumnDataSource(tx_ml_widefm2_fac_age_sex)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml peed&adult age_sex_widefm.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)             
        button_json = json_item(export_button)


        # Treatment Mortality & Loss Outcomes
        data_5 = df_ml_2_list[df_ml_2_list['FacilityName'].isin(selected_facility)]        
        data_5agg = data_5.TX_ML_Outcome_2.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome_2', 'TX_ML_Outcome_2':'value'})
        data_5b = data_5agg.copy()
        total_count = data_5b['value'].sum()
        data_5b['angle'] = data_5b['value'] / total_count * 2 * pi
        value = data_5b["value"].values
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_5b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_5b['color'] = color_palette[:len(data_5b)] 
        data_5b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_5b['cos'] = np.cos(data_5b['cumulative_angle']) * 0.32
        data_5b['sin'] = np.sin(data_5b['cumulative_angle']) * 0.32
        data_5b['cos2'] = np.cos(data_5b['cumulative_angle']) * 0.40
        data_5b['sin2'] = np.sin(data_5b['cumulative_angle']) * 0.40
        # Format the 'value' column with thousand separators
        data_5b['formatted_value']=["{:,.0f}".format(val) for val in data_5b['value']]
        data_5b['percentage'] = (data_5b['value'] / total_count) * 100
        data_5b['label']=["({:.1f}%)".format(val) for val in data_5b['percentage']]
        # Pad the 'value' column with spaces to improve label alignment
        data_5b["value"] = data_5b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_5b)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Treatment Mortality & Loss Outcomes' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,box_zoom,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome_2: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome_2', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-15, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 1e4d12
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-15, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml outcomes.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot2_html = file_html((chart, export_button), CDN, "plot2")        

        
        # Interrution in Treatment By Age Group & Sex 
        data_4b = df_ml_iit_list[df_ml_iit_list['FacilityName'].isin(selected_facility)]
        age_group_iit = pd.crosstab(data_4b['AgeGroup'], data_4b['Sex']).reset_index()
        age_group_iit = age_group_iit.set_index('AgeGroup')
        # Initialize plot to avoid UnboundLocalError
        plot4_html = None
        plot4 = None
        if not age_group_iit.empty:
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} IIT By 5-Year Age Band & Sex' 
            plot4 = age_group_iit.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)
            plot4.plot.width = plot_width
            # Adjusting toolbar size
            plot4.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot4.x_range.start = 0
            plot4.toolbar.logo = None  
            plot4.toolbar.active_scroll = None
            plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        else:
            print("No valid data to display the plot")
        # Create csv table for export
        source = ColumnDataSource(age_group_iit)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT By 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        if plot4 is not None:
            plot4_html = file_html((plot4, export_button), CDN, "plot4")
        else:
            print("No valid data to display the plot")        


        # Interrution in Treatment in Days 
        data_4c = df_ml_iit_days_list[df_ml_iit_days_list['FacilityName'].isin(selected_facility)]
        data_4agg = data_4c.IIT_duration_days.value_counts().reset_index().rename(columns={'index':'IIT_duration_days', 'IIT_duration_days':'value'})
        data_4c_count = data_4agg.copy()
        # Define the custom order
        custom_order = ['IIT for â‰¤30 days', 'IIT for 31 to 60 days', 'IIT for 61 to 180 days', 'IIT for >180 days']
        # Convert the IIT_duration_days column to a categorical type with the custom order
        data_4c_count['IIT_duration_days'] = pd.Categorical(data_4c_count['IIT_duration_days'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order   
        data_4c_count = data_4c_count.sort_values('IIT_duration_days')         
        data_4c_count['formatted_value']=["{:,.0f}".format(val) for val in data_4c_count['value']]  
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} IIT Duration (Days)'       
        plot1iit_days=data_4c_count.hvplot.bar(x="IIT_duration_days", y='value', height=height, color='#6d99ff', grid=True, rot=30, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')                             
        
        labels = hv.Labels(data=data_4c_count, kdims=['IIT_duration_days', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_iit = plot1iit_days * labels
        bokeh_model = hv.render(plot_iit, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis.formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)
        # Create csv table for export
        source = ColumnDataSource(data_4agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT duration in days.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotiit_days_html = file_html((bokeh_model, export_button), CDN, "plot4")

   
        # Facility Name level IIT Rate
        tx_ml_df_fac = tx_ml_df[tx_ml_df['Facility Name'].isin(selected_facility)]
        tx_ml_df_fac = tx_ml_df_fac.groupby('Facility Name', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_fac['IIT Rate (%)'] = np.round((tx_ml_df_fac['IIT'] / tx_ml_df_fac['TX_CURR']) * 100, decimals=1)
        data_7 = tx_ml_df_fac.copy()
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} IIT Rate'   
        # Create a new plot with a title and axis labels 700
        p = figure(x_range=FactorRange(*source.data['Facility Name']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="above")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('Facility Name', -0.3, range=p.x_range), top='TX_CURR', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('Facility Name', -0.1, range=p.x_range), top='IIT', width=0.18, source=source,
                                    color="#71aebf", legend_label="IIT")}        
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))
        # Add labels for bars
        p.text(x=dodge('Facility Name', -0.3, range=p.x_range), y='TX_CURR', text='TX_CURR',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('Facility Name', -0.1, range=p.x_range), y='IIT', text='IIT',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.2]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        # Format y-axis labels with thousands separators
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 
        # Hide the toolbar
        p.toolbar.autohide = True
        # Adjusting legend label size
        p.legend.label_text_font_size = '10pt'
        # Position the legend outside the plot area 
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        p.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'overall Facility Name IIT rate.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot5_html = file_html((p, export_button), CDN, "plot5")


        data_8 = tx_ml_df_fac_mmd[tx_ml_df_fac_mmd['FacilityName'].isin(selected_facility)]    
        # Define the data source
        source = ColumnDataSource(data_8)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} % IIT By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('mmd', -0.2, range=p.x_range), top='TX_CURR', width=0.2, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('mmd', 0.1, range=p.x_range), top='IIT', width=0.2, source=source,
                color="#71aebf", legend_label="IIT")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('mmd', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('mmd', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.1]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.legend.label_text_font_size = '10pt'
        p.add_layout(p.legend[0], 'below')
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"
        p.toolbar.logo = None
        p.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_8)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml IIT by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot6_html = file_html((p, export_button), CDN, "plot6")        


        # % IIT By Supported Facilities
        data_9 = tx_ml_df[tx_ml_df['Facility Name'].isin(selected_facility)]  
        tx_ml_df_fac = data_9.groupby('Facility Name', as_index=False)['TX_CURR','IIT'].sum()
        tx_ml_df_fac['IIT Rate (%)'] = np.round((tx_ml_df_fac['IIT'] / tx_ml_df_fac['TX_CURR']) * 100, decimals=1)   
        # Define the data source
        source = ColumnDataSource(tx_ml_df_fac)
        facility= source.data["Facility Name"]
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} % IIT' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=facility, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'TX_CURR': p.vbar(x=dodge('Facility Name', -0.2, range=p.x_range), top='TX_CURR', width=0.25, source=source,
                color="#c9d9d3", legend_label="TX_CURR"),
            'IIT': p.vbar(x=dodge('Facility Name', 0.1, range=p.x_range), top='IIT', width=0.25, source=source,
                color="#71aebf", legend_label="IIT")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', "@{Facility Name}"), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('Facility Name', -0.2, range=p.x_range), y='TX_CURR', text='TX_CURR',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('Facility Name', 0.1, range=p.x_range), y='IIT', text='IIT',
            text_font_size='10pt', text_align='center', text_baseline='bottom', source=source)

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')

        # Plot the line and circles for percentages
        percentage_metrics = ['IIT Rate (%)']
        colors = ["red"]
        dodge_values = [-0.05]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('Facility Name', dodge_val, range=p.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '10pt'        
        p.add_layout(p.legend[0], 'right')
        p.legend.click_policy = "hide"
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(tx_ml_df_fac)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility IIT.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((p, export_button), CDN, "plot9")


        # Interrution in Treatment Distribution
        data_7 = df_ml_iit_list[df_ml_iit_list['FacilityName'].isin(selected_facility)]        
        data_7agg = data_7.TX_ML_Outcome.value_counts().reset_index().rename(columns={'index':'TX_ML_Outcome', 'TX_ML_Outcome':'value'})
        data_7b = data_7agg.copy()
        total_count = data_7b['value'].sum()
        value = data_7b["value"].values
        data_7b['angle'] = data_7b['value'] / total_count * 2 * pi
        data_7b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_7b['cos'] = np.cos(data_7b['cumulative_angle']) * 0.27
        data_7b['sin'] = np.sin(data_7b['cumulative_angle']) * 0.27
        data_7b['cos2'] = np.cos(data_7b['cumulative_angle']) * 0.35
        data_7b['sin2'] = np.sin(data_7b['cumulative_angle']) * 0.35
        data_7b['formatted_value']=["{:,.0f}".format(val) for val in data_7b['value']]
        data_7b['percentage'] = (data_7b['value'] / total_count) * 100
        data_7b['label']=["({:.1f}%)".format(val) for val in data_7b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_7b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_7b['color'] = color_palette[:len(data_7b)]       
        data_7b["value"] = data_7b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = "{} Treatment New Mortality & Loss Total = {:,.0f}".format(fac_names, total_count)
        # Creating chart vertical
        chart = figure(height=height, width=620, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interactive tools
                        tooltips="@TX_ML_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_ML_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_7agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'IIT disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot10_html = file_html((chart, export_button), CDN, "plot10") 

        
        data_6 = tx_ml_df[tx_ml_df['Facility Name'].isin(selected_facility)]    
        data_6b = data_6.groupby('Facility Name')['TX_ML','IIT', 'Stopped Treatment', 'Transferred Out', 'Dead'].sum() 
        data_6b_df = data_6b.reset_index()
        def get_map_tx_ml(fac_name):
            # Function to get the TX_ML value for facilities in a given Facility Name
            tx_ml_values = data_6b_df.groupby('Facility Name')['TX_ML'].sum()
            return tx_ml_values.get(fac_name, "N/A")
        
        def get_map_tx_ml_iit(fac_name):
            # Function to get the IIT value for a given Facility Name
            tx_ml_iit = data_6b_df.groupby('Facility Name')['IIT'].sum()
            return tx_ml_iit.get(fac_name, "N/A")
        
        def get_map_tx_ml_stopped(fac_name):
            # Function to get the Stopped value for a given Facility Name
            tx_ml_stopped = data_6b_df.groupby('Facility Name')['Stopped Treatment'].sum()
            return tx_ml_stopped.get(fac_name, "N/A")
        
        def get_map_tx_ml_to(fac_name):
            # Function to get the Transferred Out value for a given Facility Name
            tx_ml_to = data_6b_df.groupby('Facility Name')['Transferred Out'].sum()
            return tx_ml_to.get(fac_name, "N/A")
        
        def get_map_tx_ml_dead(fac_name):
            # Function to get the Dead value for a given Facility Name
            tx_ml_dead = data_6b_df.groupby('Facility Name')['Dead'].sum()
            return tx_ml_dead.get(fac_name, "N/A")
   
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility Names
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600)
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Treatment Mortality & Loss Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['Facility Name', 'TX_ML'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='TX_ML', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_ML: {}<br>
                IIT: {}<br>
                Stopped: {}<br>
                Transferred Out: {}<br>
                Dead: {}
            </div>
        '''

        # Define a function to get locations for the selected Facility Names
        def get_locations_for_facs(selected_facility):            
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = tx_ml_df_sorted[tx_ml_df_sorted['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations        
        
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            tx_ml_value = get_map_tx_ml(loc["popup"])
            tx_ml_formatted = format_with_thousand_separator(tx_ml_value)   
            tx_ml_iit = get_map_tx_ml_iit(loc["popup"])
            tx_ml_iit_formatted = format_with_thousand_separator(tx_ml_iit)  

            tx_ml_stopped = get_map_tx_ml_stopped(loc["popup"])
            tx_ml_stopped_formatted = format_with_thousand_separator(tx_ml_stopped) 

            tx_ml_to = get_map_tx_ml_to(loc["popup"])
            tx_ml_to_formatted = format_with_thousand_separator(tx_ml_to) 

            tx_ml_dead = get_map_tx_ml_dead(loc["popup"])
            tx_ml_dead_formatted = format_with_thousand_separator(tx_ml_dead) 

            popup_content = popup_style.format(loc["popup"], tx_ml_formatted, tx_ml_iit_formatted, tx_ml_stopped_formatted, 
                                               tx_ml_to_formatted, tx_ml_dead_formatted)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_ml distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_ml_button_json = json_item(export_button)  
        plot17_html = ng_map.get_root().render()       
   
        
    ####################### DATATABLE ######################################################################################
        plot19_html = data_6.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)
        
        data_response = {
            'fac_num': fac_num_tx_ml_dict,
            'achieved': achieved_tx_ml_dict,
            'achieved_pbs': achieved_pbs_tx_ml_dict,
            'percent_pbs': percent_pbs_tx_ml_dict,
            'achieved_recapture': achieved_pbs_rec_tx_ml_dict,
            'percent_recaptured': percent_pbs_rec_tx_ml_dict,
            'plot1': {'main': plot1_html, 'additional': button_json},
            'plot2': plot2_html,
            'plot3': plot4_html,
            'plot4': plotiit_days_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot9': plot9_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': tx_ml_button_json}, 
            'plot19': plot19_html
        }               
    

    elif (selected_indicator == 'TX_RTT' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment New indicator
        data_1 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['Facility Name'].isin(selected_facility)]
        # Number of facilities
        fac_num_tx_rtt_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_rtt_dict = int(data_1['TX_RTT'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_rtt_dict = int(data_1['TX_RTT Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_rtt_dict > 0:
            pbs_rtt_percent = (achieved_pbs_tx_rtt_dict / achieved_tx_rtt_dict) * 100
            percent_pbs_tx_rtt_dict = f"{pbs_rtt_percent:.1f}"       
        else:
            percent_pbs_tx_rtt_dict = None   
        # Biometrics Recaptured
        achieved_pbs_rec_tx_rtt_dict = int(data_1['TX_RTT Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_rtt_dict > 0:
            pbs_rec_tx_rtt_percent = (achieved_pbs_rec_tx_rtt_dict / achieved_pbs_tx_rtt_dict) * 100
            percent_pbs_rec_tx_rtt_dict = f"{pbs_rec_tx_rtt_percent:.1f}"    
        else:
            percent_pbs_rec_tx_rtt_dict = None         
        ############################################################################################
        # Returned To Treatment Distribution By Sex 
        data_2 = df_rtt_list[df_rtt_list['FacilityName'].isin(selected_facility)]        
        data_2agg = data_2.Sex.value_counts().reset_index().rename(columns={'index':'Sex', 'Sex':'value'})
        data_2b = data_2agg.copy()
        total_count = data_2b['value'].sum()
        data_2b['angle'] = data_2b['value'] / total_count * 2 * pi
        value = data_2b["value"].values
        data_2b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_2b['cos'] = np.cos(data_2b['cumulative_angle']) * 0.32
        data_2b['sin'] = np.sin(data_2b['cumulative_angle']) * 0.32
        data_2b['cos2'] = np.cos(data_2b['cumulative_angle']) * 0.41
        data_2b['sin2'] = np.sin(data_2b['cumulative_angle']) * 0.41
        data_2b['formatted_value']=["{:,.0f}".format(val) for val in data_2b['value']]
        data_2b['percentage'] = (data_2b['value'] / total_count) * 100
        data_2b['label']=["({:.1f}%)".format(val) for val in data_2b['percentage']]
        data_2b['color'] = ['#2b9eea', '#2beaea'] 
        # Pad the 'value' column with spaces to improve label alignment
        data_2b["value"] = data_2b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_2b)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Returned To Treatment By Sex' 
        # Creating chart
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@Sex: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors 
        chart.annular_wedge(x=0, y=0, outer_radius=0.27, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='Sex', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=0, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=0, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')

        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_2agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((chart, export_button), CDN, "plot3")


        # Returned To Treatment Distribution
        data_3 = df_rtt_list[df_rtt_list['FacilityName'].isin(selected_facility)]        
        data_3agg = data_3.TX_RTT_Outcome.value_counts().reset_index().rename(columns={'index':'TX_RTT_Outcome', 'TX_RTT_Outcome':'value'})
        data_3b = data_3agg.copy()
        total_count = data_3b['value'].sum()
        value = data_3b["value"].values
        data_3b['angle'] = data_3b['value'] / total_count * 2 * pi
        data_3b["cumulative_angle"] = [(sum(value[0:i + 1]) - (item / 2)) / sum(value) * 2 * pi for i, item in enumerate(value)]
        data_3b['cos'] = np.cos(data_3b['cumulative_angle']) * 0.27
        data_3b['sin'] = np.sin(data_3b['cumulative_angle']) * 0.27
        data_3b['cos2'] = np.cos(data_3b['cumulative_angle']) * 0.35
        data_3b['sin2'] = np.sin(data_3b['cumulative_angle']) * 0.35
        data_3b['formatted_value']=["{:,.0f}".format(val) for val in data_3b['value']]
        data_3b['percentage'] = (data_3b['value'] / total_count) * 100
        data_3b['label']=["({:.1f}%)".format(val) for val in data_3b['percentage']]  
        # Define the Spectral color palette with supported sizes
        supported_sizes = [3, 4, 5, 6, 7, 8, 9, 10, 11]
        # Function to get the closest supported size for the Spectral palette
        def get_closest_palette_size(num_colors):
            return min(supported_sizes, key=lambda x: abs(x - num_colors))        
        # Get the closest supported size for the Spectral palette
        num_colors = len(data_3b)
        closest_size = get_closest_palette_size(num_colors)
        color_palette = Spectral[closest_size]
        # Repeat colors if there are more items than colors in the palette
        if num_colors > closest_size:
            color_palette = (color_palette * (num_colors // closest_size + 1))[:num_colors]

        data_3b['color'] = color_palette[:len(data_3b)]              
        # Pad the 'value' column with spaces to improve label alignment
        data_3b["value"] = data_3b['value'].astype(str)
        # Convert DataFrame to ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Creating chart vertical
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = "{} Returned To Treatment (TX_RTT) Total = {:,.0f}".format(fac_names, total_count)
        chart = figure(height=height, width=plot_width, title=plot_title, 
                        toolbar_location="above",  # Show toolbar above the plot
                        tools="tap,pan,wheel_zoom,reset,save",  # Add interYes tools
                        tooltips="@TX_RTT_Outcome: @formatted_value, Percentage: @percentage{0.0}%", x_range=(-0.5, 0.5))
        # Creating sectors
        chart.annular_wedge(x=0, y=0, inner_radius=0.18, outer_radius=0.25, direction="anticlock",
                            start_angle=cumsum('angle', include_zero=True), end_angle=cumsum('angle'),
                            line_color="white", fill_color='color', legend_field='TX_RTT_Outcome', source=source)
        # Adding labels
        labels = LabelSet(x="cos", y="sin", text='formatted_value', y_offset=-30, source=source, render_mode='canvas',text_align="center", angle=0,
                text_font_size='10pt', text_color='#000000')  # Adjust font size and color here 
        percentage_labels = LabelSet(x="cos2", y="sin2", y_offset=-30, text='label', text_align="center", angle=0, source=source,
                        render_mode='canvas', text_font_size='10pt', text_color='#000000')
        
        chart.add_layout(labels)
        chart.add_layout(percentage_labels)
        # Clearing interface
        chart.axis.axis_label=None
        chart.axis.visible=False
        chart.grid.grid_line_color = None
        # Remove Bokeh logo from the toolbar
        chart.toolbar.logo = None
        # Adjusting toolbar size
        chart.toolbar.autohide = True
        # Adjusting legend label size
        chart.legend.label_text_font_size = '9pt'
        chart.outline_line_color = None
        # Create csv table for export
        source = ColumnDataSource(data_3agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt disaggregation.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Convert Bokeh model to JSON to embed in HTML
        plot4_html = file_html((chart, export_button), CDN, "plot4")


        # Returned To Treatment By AgeGroup & Sex        
        age_group_tx_rtt = pd.crosstab(data_3['AgeGroup'], data_3['Sex']).reset_index()
        age_group_tx_rtt = age_group_tx_rtt.set_index('AgeGroup')       
        plot5 = None
        plot5_html = None
        if not age_group_tx_rtt.empty:
            # Create a data source for Bokeh
            source = ColumnDataSource(age_group_tx_rtt)
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} Returned To Treatment By 5-Year Age Band & Sex' 
            plot5 = age_group_tx_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)      
            # Set the width and height of the plot
            plot5.plot.width = plot_width
            # Adjusting toolbar size
            plot5.toolbar.autohide = True
            # Remove the space between y-axis and the plot
            plot5.x_range.start = 0
            plot5.toolbar.logo = None    
            plot5.toolbar.active_scroll = None
            plot5.xaxis[0].formatter = NumeralTickFormatter(format='0,0')
        else:
            print("No valid data to display the plot")
        # Create csv table for export
        source = ColumnDataSource(age_group_tx_rtt)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt 5yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)   
        # Ensure plot1_html is defined before returning it
        if plot5 is not None:
            plot5_html = file_html((plot5, export_button), CDN, "plot5")  
        else:
            print("No valid data to display the plot")     
        # Convert Bokeh plot to HTML
             


        # Returned To Treatment By Age Group & Sex (Biometrics)
        # Filter the data
        data_4 = rtt_pbs_list[rtt_pbs_list['FacilityName'].isin(selected_facility)]
        # Create crosstab
        age_group_pbs_rtt = pd.crosstab(data_4['AgeGroup'], data_4['Sex']).reset_index()
        age_group_pbs_rtt = age_group_pbs_rtt.set_index('AgeGroup')
        plot4 = None
        plot6_html = None
        if not age_group_pbs_rtt.empty:
            # Convert the DataFrame to a ColumnDataSource
            source = ColumnDataSource(age_group_pbs_rtt)
            # Create a title string that includes the selected Facility
            fac_names = ', '.join(selected_facility)
            plot_title = f'{fac_names} TX_RTT Biometrics Captured By 5-Year Age Band & Sex' 
            # Plot 
            plot4 = age_group_pbs_rtt.plot_bokeh.barh(title=plot_title, legend = "bottom_right",line_width=5.0, show_figure=False)        
            plot4.plot.width = plot_width
            # Adjusting toolbar size
            plot4.toolbar.autohide = True
            plot4.toolbar.logo = None       
            # Remove the space between y-axis and the plot
            plot4.x_range.start = 0        
            plot4.toolbar.active_scroll = None
            plot4.xaxis[0].formatter = NumeralTickFormatter(format='0,0')               
        else:
            print("No valid data to display the plot")
        # Create csv table for export
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbs_rtt 5 yr age_sex.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        # Ensure plot1_html is defined before returning it
        if plot4 is not None:
            plot6_html = file_html((plot4, export_button), CDN, "plot6")
        else:
            print("No valid data to display the plot")
        


        # Returned To Treatment MMD Distribution
        data_5 = df_rtt_list[df_rtt_list['FacilityName'].isin(selected_facility)]  
        data_5agg = data_5.mmd.value_counts().reset_index().rename(columns={'index':'mmd', 'mmd':'value'})
        # Define the custom order
        custom_order = ['MMD <3', 'MMD 3', 'MMD 4-5', 'MMD 6']
        # Convert the mmd column to a categorical type with the custom order
        data_5agg['mmd'] = pd.Categorical(data_5agg['mmd'], categories=custom_order, ordered=True)
        # Sort the DataFrame based on the custom order
        data_5agg = data_5agg.sort_values('mmd')
        data_5_count = data_5agg.copy()
        data_5_count['formatted_value'] = ["{:,.0f}".format(val) for val in data_5_count['value']]
        # Define colors for each bar
        colors = ['#ff6f61', '#6aff99', '#6d99ff', '#aa66cc']
        data_5_count['color'] = colors[:len(data_5_count)]
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Returned To Treatment By MMD' 
        # Create the bar plot
        plot5new_days = data_5_count.hvplot.barh(
            x="mmd", y='value', height=height, color='color', grid=True, xlabel='', line_color=None, fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, 
            ylabel='', width=plot_width, title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above')

        # Add labels
        labels = hv.Labels(data=data_5_count, kdims=['mmd', 'value'], vdims='formatted_value')
        # Overlay labels on the bar plot
        plot_new = plot5new_days * labels
        # Get the underlying Bokeh plot
        bokeh_plot = hv.render(plot_new)
        # Format the x-axis with a thousand separator
        bokeh_plot.xaxis[0].formatter = NumeralTickFormatter(format="0,0")         
        # Create csv table for export
        source = ColumnDataSource(data_5agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)

        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot7_html = file_html((bokeh_plot, export_button), CDN, "plot7")           

        
        # Returned To Treatment CD4 Distribution
        data_6 = rtt_cd4_list[rtt_cd4_list['FacilityName'].isin(selected_facility)]
        data_6agg = data_6.TX_RTT_CD4.value_counts().reset_index().rename(columns={'index':'TX_RTT_CD4', 'TX_RTT_CD4':'value'})
        data_6_count = data_6agg.copy()
        data_6_count['formatted_value']=["{:,.0f}".format(val) for val in data_6_count['value']]    
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Returned To Treatment By CD4 Count'     
        plot5new_days=data_6_count.hvplot.bar(x="TX_RTT_CD4", y='value', height=height, color='#6d99ff', grid=True, xlabel='', line_color=None,  # Remove the border completely
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=plot_width, 
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT_CD4")                                

        labels = hv.Labels(data=data_6_count, kdims=['TX_RTT_CD4', 'value'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot5new_days * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_6agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt by CD4 count.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot8_html = file_html((bokeh_model, export_button), CDN, "plot8")   


        # Returned To Treatment Distribution
        data_8 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['Facility Name'].isin(selected_facility)] 
        data_8agg = data_8.groupby('Facility Name')[['TX_RTT']].sum().reset_index()    
        data_8_sum = data_8agg.copy()
        data_8_sum['formatted_value']=["{:,.0f}".format(val) for val in data_8_sum['TX_RTT']]   
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Returned To Treatment'     
        plot9=data_8_sum.hvplot.bar(x="Facility Name", y='TX_RTT', height=height, color='#409efc', grid=True, xlabel='', line_color=None, 
                                        fontsize={'xticks': 10, 'yticks': 10, 'title': 10}, ylabel='', width=1115, rot=30,
                                        title=plot_title).opts(hooks=[remove_bokeh_logo], toolbar='above').sort("TX_RTT")                                

        labels = hv.Labels(data=data_8_sum, kdims=['Facility Name', 'TX_RTT'], vdims='formatted_value')
        # use the * symbol to overlay your labels on your plot
        plot_new = plot9 * labels
        bokeh_model = hv.render(plot_new, backend='bokeh')        
        bokeh_model.toolbar.autohide = True
        # Format y-axis ticks with commas for thousand separators
        bokeh_model.yaxis[0].formatter = NumeralTickFormatter(format='0,0')
        # # Add HoverTool with formatted tooltips
        # hover = HoverTool()
        # hover.tooltips = [("Facility", "@{Facility Name}"), ("TX_RTT", "@TX_RTT{0,0}")]
        # bokeh_model.add_tools(hover)
        # Add the Bokeh model to the ml document
        curdoc().add_root(bokeh_model)       
        # Create csv table for export
        source = ColumnDataSource(data_8agg)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility tx_rtt.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot9_html = file_html((bokeh_model, export_button), CDN, "plot9")          


        data_7 = tx_rtt_temp_tbl[tx_rtt_temp_tbl['Facility Name'].isin(selected_facility)]  
        data_7b_rtt = data_7.groupby('Facility Name', as_index=True)[['TX_RTT','TX_RTT Captured', 'TX_RTT Recaptured']].sum()   
        data_7b_rtt=data_7b_rtt.reset_index()  

        def get_map_tx_rtt(fac_name):
            # Function to get the TX_RTT value for Facilities in a given Facility Name
            tx_rtt_values = data_7b_rtt.groupby('Facility Name')['TX_RTT'].sum()            
            return tx_rtt_values.get(fac_name, "N/A")
        
        def get_map_tx_rtt2(fac_name):
            # Convert list to dictionary
            tx_rtt_cap_dict = dict(zip(data_7b_rtt['Facility Name'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Captured'] / data_7b_rtt['TX_RTT']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_rtt_cap_dict.get(fac_name, "N/A")

        def get_map_tx_rtt3(fac_name):
            # Function to get the TX_PVLS value for a given Facility Name
            tx_rtt_recap_dict = dict(zip(data_7b_rtt['Facility Name'], map(lambda x: str(x) + "%", np.round((data_7b_rtt['TX_RTT Recaptured'] / data_7b_rtt['TX_RTT Captured']) * 100, decimals=1))))
            return tx_rtt_recap_dict.get(fac_name, "N/A")
        
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility Names
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)
        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600)
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Returned To Treatment Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_7b_rtt, columns=['Facility Name', 'TX_RTT'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.8, line_opacity=0.3, legend_name='TX_RTT', highlight=True).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                TX_RTT: {}<br>
                % Captured: {}<br>
                % Recaptured: {}
            </div>
        '''

        # Define a function to get locations for Facilities in the selected Facility Names
        def get_locations_for_facs(selected_facility):
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = tx_rtt_temp_tbl[tx_rtt_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            tx_rtt_value = get_map_tx_rtt(loc["popup"])
            tx_rtt_formatted = format_with_thousand_separator(tx_rtt_value)            
            tx_rtt_cap_dict = get_map_tx_rtt2(loc["popup"])
            tx_rtt_recap_dict = get_map_tx_rtt3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_rtt_formatted, 
                                                tx_rtt_cap_dict, 
                                                tx_rtt_recap_dict) 
            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Create ColumnDataSource from the DataFrame
        source = ColumnDataSource(data_7b_rtt)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_rtt distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)              
        tx_rtt_button_json = json_item(export_button)
        plot17_html = ng_map.get_root().render() 

        ####################### DATATABLE ######################################################################################
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_rtt_dict,
            'achieved': achieved_tx_rtt_dict,
            'achieved_pbs': achieved_pbs_tx_rtt_dict,
            'percent_pbs': percent_pbs_tx_rtt_dict,
            'achieved_recapture': achieved_pbs_rec_tx_rtt_dict,
            'percent_recaptured': percent_pbs_rec_tx_rtt_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot5': plot5_html,
            'plot6': plot6_html,
            'plot7': plot7_html,
            'plot8': plot8_html,
            'plot9': plot9_html,
            'plot17': {'main': plot17_html, 'additional': tx_rtt_button_json}, 
            'plot19': plot19_html

        }  


    elif (selected_indicator == 'TX_PVLS' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['Facility Name'].isin(selected_facility)]    
        # Number of facilities
        fac_num_tx_pvls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_tx_pvls_dict = int(data_1['TX_PVLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_tx_pvls_dict = int(data_1['TX_PVLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_tx_pvls_dict > 0:
            pbs_tx_pvls_percent = (achieved_pbs_tx_pvls_dict / achieved_tx_pvls_dict) * 100
            percent_pbs_tx_pvls_dict = f"{pbs_tx_pvls_percent:.1f}"  
        else:
            percent_pbs_tx_pvls_dict = None         
        # Biometrics Recaptured
        achieved_pbs_rec_tx_pvls_dict = int(data_1['TX_PVLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_tx_pvls_dict > 0:
            pbs_rec_tx_pvls_percent = (achieved_pbs_rec_tx_pvls_dict / achieved_pbs_tx_pvls_dict) * 100
            percent_pbs_rec_tx_pvls_dict = f"{pbs_rec_tx_pvls_percent:.1f}"    
        else:
            percent_pbs_rec_tx_pvls_dict = None  
        ############################################################################################################
        data_1b = tx_pvls_fac[tx_pvls_fac['Facility Name'].isin(selected_facility)] 
        source = ColumnDataSource(data_1b)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Viral Load Suppression Performance' 
        # Create a new plot with a title and axis labels 
        plot1 = figure(x_range=FactorRange(*source.data['Facility Name']), plot_height=height, plot_width=plot_width, title=plot_title,
                    toolbar_location="right")
        # Render bars
        bars = {
            'Eligible for VL': plot1.vbar(x=dodge('Facility Name', -0.3, range=plot1.x_range), top='Eligible for VL', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': plot1.vbar(x=dodge('Facility Name', -0.1, range=plot1.x_range), top='TX_PVLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': plot1.vbar(x=dodge('Facility Name', 0.1, range=plot1.x_range), top='TX_PVLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N)"),
            'Undetected VL <50': plot1.vbar(x=dodge('Facility Name', 0.3, range=plot1.x_range), top='Undetected VL <50', width=0.18, source=source,
                                            color="#A8B9E2", legend_label="Undetected VL <50")
        }

        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('Facility Name', -0.3, range=plot1.x_range), y='Eligible for VL', text='Eligible for VL',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', -0.1, range=plot1.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', 0.1, range=plot1.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', 0.3, range=plot1.x_range), y='Undetected VL <50', text='Undetected VL <50',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression', '% Undetected']
        colors = ["Magenta", "green", "blue"]
        dodge_values = [-0.2, 0, 0.2]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '4.5pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below')   #Valid place values are: above, below, left, right or center
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        # Remove Bokeh logo from the toolbar
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        data_2 = grouped_pvls_fac[grouped_pvls_fac['FacilityName'].isin(selected_facility)] 
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Viral Load Coverage & Suppression By MMD' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")
             
        
        ############################################################################################
        # Clients' Viral Load Suppression By Age Band
        data_3 = pvls_temp_tbl_all_age_fac[pvls_temp_tbl_all_age_fac['FacilityName'].isin(selected_facility)]   
        data_3b = data_3.groupby('AgeGroup')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()    
        data_3b.loc[:, '% Coverage'] = np.round((data_3b['TX_PVLS (D)'] / data_3b['Eligible for VL']) * 100, decimals=1)
        data_3b.loc[:, '% Suppression'] = np.round((data_3b['TX_PVLS (N)'] / data_3b['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Ensure AgeGroup values are unique
        age_groups = data_3['AgeGroup'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_3b)
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f"{fac_names} Clients' Viral Load Suppression By Age Band"
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")

        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible for VL', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             

        source = ColumnDataSource(data_3b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")        


        # Female Clients' Viral Load Suppression By Age Band
        data_4 = pvls_temp_tbl_age_fac_female[pvls_temp_tbl_age_fac_female['FacilityName'].isin(selected_facility)]    
        # Define the data source
        source = ColumnDataSource(data_4)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f"{fac_names} Female Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Female)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Female)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Female)"),
            'TX_PVLS (D, Female)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Female)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Female)"),
            'TX_PVLS (N, Female)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Female)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Female)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis        
        # Add value labels  
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Female)', text='Eligible (Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Female)', text='TX_PVLS (D, Female)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Female)', text='TX_PVLS (N, Female)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Female)', '% Suppression (Female)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_4)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'female tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsf_html = file_html((p, export_button), CDN, "plot10")


        # Male Clients' Viral Load Suppression By Age Band
        data_5 = pvls_temp_tbl_age_fac_male[pvls_temp_tbl_age_fac_male['FacilityName'].isin(selected_facility)]    
        # Define the data source
        source = ColumnDataSource(data_5)
        # Age Groups
        age_groups = source.data["AgeGroup"]
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f"{fac_names} Male Clients' Viral Load Suppression By Age Band" 
        # Create a new plot with a title and axis labels
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'Eligible (Male)': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='Eligible (Male)', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="Eligible (Male)"),
            'TX_PVLS (D, Male)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='TX_PVLS (D, Male)', width=0.2, source=source,
                                    color="#71aebf", legend_label="TX_PVLS (D, Male)"),
            'TX_PVLS (N, Male)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='TX_PVLS (N, Male)', width=0.2, source=source,
                                    color="#718dbf", legend_label="TX_PVLS (N, Male)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0  # Adjusting the start of the y-axis
        # Add value labels 
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='Eligible (Male)', text='Eligible (Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='TX_PVLS (D, Male)', text='TX_PVLS (D, Male)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source)
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='TX_PVLS (N, Male)', text='TX_PVLS (N, Male)',
            text_font_size='7pt', text_align='center', text_baseline='middle', source=source)        

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage (Male)', '% Suppression (Male)']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"  
        # Create csv table for export
        source = ColumnDataSource(data_5)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'male tx_pvls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsm_html = file_html((p, export_button), CDN, "plot11")


        data_7 = pvls_temp_tbl_all_age_fac[pvls_temp_tbl_all_age_fac['FacilityName'].isin(selected_facility)]   
        fac_categories = data_7['FacilityName'].unique()      
        data_7 = data_7.groupby('FacilityName')[['Eligible for VL','TX_PVLS (D)', 'TX_PVLS (N)']].sum()  
        data_7.loc[:, '% Coverage'] = np.round((data_7['TX_PVLS (D)'] / data_7['Eligible for VL']) * 100, decimals=1)
        data_7.loc[:, '% Suppression'] = np.round((data_7['TX_PVLS (N)'] / data_7['TX_PVLS (D)']) * 100, decimals=1)
        # Step 2: Create a ColumnDataSource
        source = ColumnDataSource(data_7)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Viral Load Coverage & Suppression' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=fac_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'Eligible for VL': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='Eligible for VL', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="Eligible for VL"),
            'TX_PVLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='TX_PVLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="TX_PVLS (D)"),
            'TX_PVLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='TX_PVLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="TX_PVLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='Eligible for VL', text='Eligible for VL',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='TX_PVLS (D)', text='TX_PVLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='TX_PVLS (N)', text='TX_PVLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["Magenta", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility tx_pvls.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot12_html = file_html((p, export_button), CDN, "plot12")


        data_6 = tx_pvls_temp_tbl[tx_pvls_temp_tbl['Facility Name'].isin(selected_facility)]  
        data_6b = data_6.groupby('Facility Name')[['Eligible for VL', 'VL sample taken in 1 year', 'TX_PVLS (D)', 'TX_PVLS (N)']].sum() 
        data_6b_df=data_6b.reset_index()   

        def get_map_tx_pvls(fac_name):
            # Function to get the TX_PVLS value for a given Facility Name
            tx_pvls_values = data_6b_df.groupby('Facility Name')['Eligible for VL'].sum()
            return tx_pvls_values.get(fac_name, "N/A")
        
        def get_map_tx_pvls2(fac_name):
            # Convert list to dictionary
            tx_pvls_cov_dict = dict(zip(data_6b_df['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (D)'] / data_6b_df['Eligible for VL']) * 100, decimals=1))))
            # Use get method on dictionary
            return tx_pvls_cov_dict.get(fac_name, "N/A")

        def get_map_tx_pvls3(fac_name):
            # Function to get the TX_PVLS value for a given Facility Name
            tx_pvls_sup_dict = dict(zip(data_6b_df['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b_df['TX_PVLS (N)'] / data_6b_df['TX_PVLS (D)']) * 100, decimals=1))))
            return tx_pvls_sup_dict.get(fac_name, "N/A")
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility Names
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600)
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Viral Load Suppression Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b_df, columns=['Facility Name', 'Eligible for VL'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name="Patients' Viral Load Suppression (PVLS)", nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected Facility Names
        def get_locations_for_facs(selected_facility):
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = tx_pvls_temp_tbl[tx_pvls_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations            
        
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            tx_pvls_values = get_map_tx_pvls(loc["popup"])
            tx_pvls_formatted = format_with_thousand_separator(tx_pvls_values)     
            tx_pvls_cov_dict = get_map_tx_pvls2(loc["popup"])
            tx_pvls_sup_dict = get_map_tx_pvls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                tx_pvls_formatted, 
                                                tx_pvls_cov_dict, 
                                                tx_pvls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"],
                popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)
        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b_df)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'tx_pvls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        tx_pvls_button_json = json_item(export_button)    
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        tx_pvls_fac3b = tx_pvls_fac3[tx_pvls_fac3['Facility'].isin(selected_facility)] 

        plot18_html = tx_pvls_fac3b.to_html(index=False, classes=['cascade', 'table table-bordered',"display"], escape=False)
        
        plot19_html = data_1.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_tx_pvls_dict,
            'achieved': achieved_tx_pvls_dict,
            'achieved_pbs': achieved_pbs_tx_pvls_dict,
            'percent_pbs': percent_pbs_tx_pvls_dict,
            'achieved_recapture': achieved_pbs_rec_tx_pvls_dict,
            'percent_recaptured': percent_pbs_rec_tx_pvls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plotvlsf_html,
            'plot11': plotvlsm_html,
            'plot12': plot12_html,
            'plot17': {'main': plot17_html, 'additional': tx_pvls_button_json}, 
            'plot18': plot18_html,
            'plot19': plot19_html
        }      


    elif (selected_indicator == 'PBFW VLS' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['Facility Name'].isin(selected_facility)]  
        # Number of facilities
        fac_num_pbfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pbfw_vls_dict = int(data_1['PBFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pbfw_vls_dict = int(data_1['PBFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_pbfw_vls_dict > 0:
            pbs_pbfw_vls_percent = (achieved_pbs_pbfw_vls_dict / achieved_pbfw_vls_dict) * 100
            percent_pbs_pbfw_vls_dict = f"{pbs_pbfw_vls_percent:.1f}"    
        else:
            percent_pbs_pbfw_vls_dict = None     
        # Biometrics Recaptured
        achieved_pbs_rec_pbfw_vls_dict = int(data_1['PBFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_pbfw_vls_dict > 0:
            pbs_rec_pbfw_vls_percent = (achieved_pbs_rec_pbfw_vls_dict / achieved_pbs_pbfw_vls_dict) * 100
            percent_pbs_rec_pbfw_vls_dict = f"{pbs_rec_pbfw_vls_percent:.1f}"     
        else:
            percent_pbs_rec_pbfw_vls_dict = None  
        ############################################################################################
        # Create IP Summary Table
        data_1b = data_1.groupby('Facility Name', as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PBFW VLS (D)'] / data_1b['PBFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PBFW VLS (N)'] / data_1b['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant & Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['Facility Name']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PBFW VL Eligible': plot1.vbar(x=dodge('Facility Name', -0.3, range=plot1.x_range), top='PBFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': plot1.vbar(x=dodge('Facility Name', -0.1, range=plot1.x_range), top='PBFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': plot1.vbar(x=dodge('Facility Name', 0.1, range=plot1.x_range), top='PBFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('Facility Name', -0.3, range=plot1.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', -0.1, range=plot1.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', 0.1, range=plot1.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'Facility' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        data_2 = data_2.groupby(['FacilityName', 'mmd'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PBFW VLS (D)'] / data_2['PBFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PBFW VLS (N)'] / data_2['PBFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant & Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PBFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pbfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        pbfw_vls_temp_tbl_age = pbfw_vls_temp_tbl_age.groupby(['FacilityName', 'AgeGroup'], as_index=False)['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)'].count()
        pbfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (D)'] / pbfw_vls_temp_tbl_age['PBFW VL Eligible']) * 100, decimals=1)
        pbfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pbfw_vls_temp_tbl_age['PBFW VLS (N)'] / pbfw_vls_temp_tbl_age['PBFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pbfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant & Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PBFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PBFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PBFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        # Ensure Facility values are unique
        fac_categories = data_7['FacilityName'].unique()   
        data_7b = data_7.groupby('FacilityName')[['PBFW VL Eligible','PBFW VLS (D)', 'PBFW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PBFW VLS (D)'] / data_7b['PBFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PBFW VLS (N)'] / data_7b['PBFW VLS (D)']) * 100, decimals=1)
        # Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant & Breastfeeding Women VLS' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=fac_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PBFW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='PBFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PBFW VL Eligible"),
            'PBFW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='PBFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PBFW VLS (D)"),
            'PBFW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='PBFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PBFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='PBFW VL Eligible', text='PBFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='PBFW VLS (D)', text='PBFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='PBFW VLS (N)', text='PBFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility pbfw_pvls.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['Facility Name'].isin(selected_facility)]  
        data_6b = data_6.groupby('Facility Name')[['PBFW VL Eligible', 'PBFW VLS (D)', 'PBFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pbfw_vls(fac_name):
            # Function to get the pbfw_vls value for a given Facility Name
            pbfw_vls_values = data_6b.groupby('Facility Name')['PBFW VL Eligible'].sum()
            return pbfw_vls_values.get(fac_name, "N/A")
        
        def get_map_pbfw_vls2(fac_name):
            # Convert list to dictionary
            pbfw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (D)'] / data_6b['PBFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pbfw_vls_cov_dict.get(fac_name, "N/A")

        def get_map_pbfw_vls3(fac_name):
            # Function to get the pbfw_vls value for a given Facility Name
            pbfw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PBFW VLS (N)'] / data_6b['PBFW VLS (D)']) * 100, decimals=1))))
            return pbfw_vls_sup_dict.get(fac_name, "N/A")
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility Names
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)
        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600)
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Pregnant & Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'PBFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant & Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected Facility Names
        def get_locations_for_facs(selected_facility):
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations 
        
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            pbfw_vls_values = get_map_pbfw_vls(loc["popup"])
            pbfw_vls_formatted = format_with_thousand_separator(pbfw_vls_values)     
            pbfw_vls_cov_dict = get_map_pbfw_vls2(loc["popup"])
            pbfw_vls_sup_dict = get_map_pbfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pbfw_vls_formatted, 
                                                pbfw_vls_cov_dict, 
                                                pbfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pbfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pbfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################        
        pbfw_pvls_temp_tbl_fac = pbfw_pvls_temp_tbl[pbfw_pvls_temp_tbl['Facility Name'].isin(selected_facility)] 
        plot19_html = pbfw_pvls_temp_tbl_fac.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pbfw_vls_dict,
            'achieved': achieved_pbfw_vls_dict,
            'achieved_pbs': achieved_pbs_pbfw_vls_dict,
            'percent_pbs': percent_pbs_pbfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pbfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pbfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': pbfw_vls_button_json}, 
            'plot19': plot19_html
        } 


    elif (selected_indicator == 'PW VLS' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['Facility Name'].isin(selected_facility)]  
        # Number of facilities
        fac_num_pw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_pw_vls_dict = int(data_1['PW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_pw_vls_dict = int(data_1['PW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_pw_vls_dict > 0:
            pbs_pw_vls_percent = (achieved_pbs_pw_vls_dict / achieved_pw_vls_dict) * 100
            percent_pbs_pw_vls_dict = f"{pbs_pw_vls_percent:.1f}"        
        else:
            percent_pbs_pw_vls_dict = None 
        # Biometrics Recaptured
        achieved_pbs_rec_pw_vls_dict = int(data_1['PW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_pw_vls_dict > 0:
            pbs_rec_pw_vls_percent = (achieved_pbs_rec_pw_vls_dict / achieved_pbs_pw_vls_dict) * 100
            percent_pbs_rec_pw_vls_dict = f"{pbs_rec_pw_vls_percent:.1f}"     
        else:
            percent_pbs_rec_pw_vls_dict = None 
        ############################################################################################ 
        # Create IP Summary Table
        data_1b = data_1.groupby('Facility Name', as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['PW VLS (D)'] / data_1b['PW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['PW VLS (N)'] / data_1b['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['Facility Name']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'PW VL Eligible': plot1.vbar(x=dodge('Facility Name', -0.3, range=plot1.x_range), top='PW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': plot1.vbar(x=dodge('Facility Name', -0.1, range=plot1.x_range), top='PW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': plot1.vbar(x=dodge('Facility Name', 0.1, range=plot1.x_range), top='PW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('Facility Name', -0.3, range=plot1.x_range), y='PW VL Eligible', text='PW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', -0.1, range=plot1.x_range), y='PW VLS (D)', text='PW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', 0.1, range=plot1.x_range), y='PW VLS (N)', text='PW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'Facility Name' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        data_2 = data_2.groupby(['Facility Name', 'mmd'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['PW VLS (D)'] / data_2['PW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['PW VLS (N)'] / data_2['PW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # PW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        pw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        pw_vls_temp_tbl_age = pw_vls_temp_tbl_age.groupby(['FacilityName', 'AgeGroup'], as_index=False)['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)'].count()
        pw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((pw_vls_temp_tbl_age['PW VLS (D)'] / pw_vls_temp_tbl_age['PW VL Eligible']) * 100, decimals=1)
        pw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((pw_vls_temp_tbl_age['PW VLS (N)'] / pw_vls_temp_tbl_age['PW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = pw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='PW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='PW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='PW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        fac_categories = data_7['FacilityName'].unique() 
        data_7b = data_7.groupby('FacilityName')[['PW VL Eligible','PW VLS (D)', 'PW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['PW VLS (D)'] / data_7b['PW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['PW VLS (N)'] / data_7b['PW VLS (D)']) * 100, decimals=1)
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Pregnant Women VLS' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=fac_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'PW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='PW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="PW VL Eligible"),
            'PW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='PW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="PW VLS (D)"),
            'PW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='PW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="PW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0
        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='PW VL Eligible', text='PW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='PW VLS (D)', text='PW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='PW VLS (N)', text='PW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'Facility tx_pvls.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = pw_pvls_temp_tbl[pw_pvls_temp_tbl['Facility Name'].isin(selected_facility)]  
        data_6b = data_6.groupby('Facility Name')[['PW VL Eligible', 'PW VLS (D)', 'PW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_pw_vls(fac_name):
            # Function to get the pw_vls value for a given Facility Name
            pw_vls_values = data_6b.groupby('Facility Name')['PW VL Eligible'].sum()
            return pw_vls_values.get(fac_name, "N/A")
        
        def get_map_pw_vls2(fac_name):
            # Convert list to dictionary
            pw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (D)'] / data_6b['PW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return pw_vls_cov_dict.get(fac_name, "N/A")

        def get_map_pw_vls3(fac_name):
            # Function to get the pw_vls value for a given Facility Name
            pw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['PW VLS (N)'] / data_6b['PW VLS (D)']) * 100, decimals=1))))
            return pw_vls_sup_dict.get(fac_name, "N/A")
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility Names
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)
        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600)
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Pregnant Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'PW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Pregnant Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected Facility Names
        def get_locations_for_facs(selected_facility):
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = pw_pvls_temp_tbl[pw_pvls_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations
        
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            pw_vls_values = get_map_pw_vls(loc["popup"])
            pw_vls_formatted = format_with_thousand_separator(pw_vls_values)     
            pw_vls_cov_dict = get_map_pw_vls2(loc["popup"])
            pw_vls_sup_dict = get_map_pw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                pw_vls_formatted, 
                                                pw_vls_cov_dict, 
                                                pw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'pw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        pw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        


        ####################### DATATABLE ######################################################################################
        pw_pvls_temp_tbl_fac = pw_pvls_temp_tbl[pw_pvls_temp_tbl['Facility Name'].isin(selected_facility)] 
        plot19_html = pw_pvls_temp_tbl_fac.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_pw_vls_dict,
            'achieved': achieved_pw_vls_dict,
            'achieved_pbs': achieved_pbs_pw_vls_dict,
            'percent_pbs': percent_pbs_pw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_pw_vls_dict,
            'percent_recaptured': percent_pbs_rec_pw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': pw_vls_button_json}, 
            'plot19': plot19_html

        } 


    elif (selected_indicator == 'BFW VLS' and selected_facility):
        ############## Handle data elements from the facility summary table ##############################################
        # Query data for treatment pvls indicator
        data_1 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['Facility Name'].isin(selected_facility)]   
        # Number of facilities
        fac_num_bfw_vls_dict = int(data_1['DATIMCode'].nunique())        
        # Number of Clients
        achieved_bfw_vls_dict = int(data_1['BFW VLS (D)'].sum())        
        # Biometrics Captured
        achieved_pbs_bfw_vls_dict = int(data_1['BFW VLS (D) Captured'].sum())        
        # Biometrics Coverage (%)
        if achieved_bfw_vls_dict > 0:
            pbs_bfw_vls_percent = (achieved_pbs_bfw_vls_dict / achieved_bfw_vls_dict) * 100
            percent_pbs_bfw_vls_dict = f"{pbs_bfw_vls_percent:.1f}"        
        else:
            percent_pbs_bfw_vls_dict = None  
        # Biometrics Recaptured
        achieved_pbs_rec_bfw_vls_dict = int(data_1['BFW VLS (D) Recaptured'].sum())        
        # Recaptured Biometrics Coverage (%)
        if achieved_pbs_bfw_vls_dict > 0:
            pbs_rec_bfw_vls_percent = (achieved_pbs_rec_bfw_vls_dict / achieved_pbs_bfw_vls_dict) * 100
            percent_pbs_rec_bfw_vls_dict = f"{pbs_rec_bfw_vls_percent:.1f}"     
        else:
            percent_pbs_rec_bfw_vls_dict = None     
        ############################################################################################            
        # Create IP Summary Table
        data_1b = data_1.groupby('Facility Name', as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].sum()
        data_1b['% Coverage'] = np.round((data_1b['BFW VLS (D)'] / data_1b['BFW VL Eligible']) * 100, decimals=1)
        data_1b['% Suppression'] = np.round((data_1b['BFW VLS (N)'] / data_1b['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_1b)        
        # Create a new plot with a title and axis labels 
        # Create a title string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Breastfeeding Women VLS Performance' 
        plot1 = figure(x_range=FactorRange(*source.data['Facility Name']), plot_height=height, plot_width=plot_width, 
                       title=plot_title, toolbar_location="right")
        # Render bars
        bars = {
            'BFW VL Eligible': plot1.vbar(x=dodge('Facility Name', -0.3, range=plot1.x_range), top='BFW VL Eligible', width=0.18, source=source,
                                        color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': plot1.vbar(x=dodge('Facility Name', -0.1, range=plot1.x_range), top='BFW VLS (D)', width=0.18, source=source,
                                    color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': plot1.vbar(x=dodge('Facility Name', 0.1, range=plot1.x_range), top='BFW VLS (N)', width=0.18, source=source,
                                    color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            plot1.add_tools(HoverTool(renderers=[bar], tooltips=[(label, f"@{{{label}}}{{0,0}}")]))

        # Add labels for bars
        plot1.text(x=dodge('Facility Name', -0.3, range=plot1.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', -0.1, range=plot1.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        plot1.text(x=dodge('Facility Name', 0.1, range=plot1.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        
        # Secondary y-axis for percentages
        plot1.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        plot1.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [-0.2, 0]        
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            plot1.text(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, text=metric,
                    text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                    text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = plot1.circle(x=dodge('Facility Name', dodge_val, range=plot1.x_range), y=metric, source=source,
                                line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            plot1.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))
        # Format y-axis labels with thousands separators
        plot1.yaxis.formatter = NumeralTickFormatter(format="0,0")
        plot1.y_range.start = 0 
        # Hide the toolbar
        plot1.toolbar.autohide = True
        # Adjusting legend label size
        plot1.legend.label_text_font_size = '7pt'
        # Position the legend outside the plot area
        plot1.add_layout(plot1.legend[0], 'below') 
        plot1.legend.orientation = "horizontal"
        plot1.legend.click_policy = "hide"
        plot1.toolbar.logo = None
        # Create csv table for export
        source = ColumnDataSource(data_1b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls performance.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot3_html = file_html((plot1, export_button), CDN, "plot3")

        
        # Filter and group by 'Facility' and 'mmd'
        data_2 = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        data_2 = data_2.groupby(['FacilityName', 'mmd'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        data_2['% Coverage'] = np.round((data_2['BFW VLS (D)'] / data_2['BFW VL Eligible']) * 100, decimals=1)
        data_2['% Suppression'] = np.round((data_2['BFW VLS (N)'] / data_2['BFW VLS (D)']) * 100, decimals=1)
        source = ColumnDataSource(data_2)
        mmd_categories = ["MMD <3", "MMD 3", "MMD 4-5", "MMD 6"]
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Breastfeeding Women VLS By MMD' 
        p = figure(x_range=mmd_categories, plot_height=height, plot_width=plot_width, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('mmd', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('mmd', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('mmd', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('MMD', '@mmd'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('mmd', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('mmd', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('mmd', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '7pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Create csv table for export
        source = ColumnDataSource(data_2)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by MMD.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot4_html = file_html((p, export_button), CDN, "plot4")

        ############################################################################################
        # BFW Viral Load Suppression By Age Band        
        # Create IP Summary Table By Age
        bfw_vls_temp_tbl_age = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        bfw_vls_temp_tbl_age = bfw_vls_temp_tbl_age.groupby(['FacilityName', 'AgeGroup'], as_index=False)['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)'].count()
        bfw_vls_temp_tbl_age.loc[:, '% Coverage'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (D)'] / bfw_vls_temp_tbl_age['BFW VL Eligible']) * 100, decimals=1)
        bfw_vls_temp_tbl_age.loc[:, '% Suppression'] = np.round((bfw_vls_temp_tbl_age['BFW VLS (N)'] / bfw_vls_temp_tbl_age['BFW VLS (D)']) * 100, decimals=1)
        # Replacing NaN with '0.0%'
        data_3 = bfw_vls_temp_tbl_age.replace('nan%', '0.0%', regex=True)
        age_groups = data_3['AgeGroup'].unique()

        source = ColumnDataSource(data_3)
        # Create a new plot with a title and axis labels
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Breastfeeding Women VLS By Age Band' 
        p = figure(x_range=age_groups, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="above", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('AgeGroup', -0.2, range=p.x_range), top='BFW VL Eligible', width=0.2, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('AgeGroup', 0, range=p.x_range), top='BFW VLS (D)', width=0.2, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('AgeGroup', 0.2, range=p.x_range), top='BFW VLS (N)', width=0.2, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}
        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Age Band', '@AgeGroup'), (label, f"@{{{label}}}{{0,0}}")]))            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0 # Adjusting the start of the y-axis

        # Add value labels
        p.text(x=dodge('AgeGroup', -0.2, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('AgeGroup', 0.2, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='7pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]
        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('AgeGroup', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size = '9pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"             
        # Create csv table for export
        source = ColumnDataSource(data_3)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls by age band.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plotvlsage_html = file_html((p, export_button), CDN, "plot9")    


        data_7 = df_pbfw_list[df_pbfw_list['FacilityName'].isin(selected_facility)] 
        data_7b = data_7.groupby('FacilityName')[['BFW VL Eligible','BFW VLS (D)', 'BFW VLS (N)']].count()   
        data_7b.loc[:, '% Coverage'] = np.round((data_7b['BFW VLS (D)'] / data_7b['BFW VL Eligible']) * 100, decimals=1)
        data_7b.loc[:, '% Suppression'] = np.round((data_7b['BFW VLS (N)'] / data_7b['BFW VLS (D)']) * 100, decimals=1)
        # Step 2: Ensure SurgeCommand values are unique
        fac_categories = data_7['FacilityName'].unique()
        # Step 3: Create a ColumnDataSource
        source = ColumnDataSource(data_7b)
        # Create a title string that includes the selected Facility(s)
        fac_names = ', '.join(selected_facility)
        plot_title = f'{fac_names} Breastfeeding Women VLS' 
        # Create a new plot with a title and axis labels
        p = figure(x_range=fac_categories, plot_height=height, plot_width=1115, title=plot_title,
                toolbar_location="right", tools="pan,box_zoom,wheel_zoom,reset,save")
        # Render bars
        bars = {
            'BFW VL Eligible': p.vbar(x=dodge('FacilityName', -0.3, range=p.x_range), top='BFW VL Eligible', width=0.30, source=source,
                                    color="#c9d9d3", legend_label="BFW VL Eligible"),
            'BFW VLS (D)': p.vbar(x=dodge('FacilityName', 0, range=p.x_range), top='BFW VLS (D)', width=0.30, source=source,
                                color="#71aebf", legend_label="BFW VLS (D)"),
            'BFW VLS (N)': p.vbar(x=dodge('FacilityName', 0.3, range=p.x_range), top='BFW VLS (N)', width=0.30, source=source,
                                color="#718dbf", legend_label="BFW VLS (N)")}

        # Add hover tool for each bar
        for label, bar in bars.items():
            p.add_tools(HoverTool(renderers=[bar], tooltips=[('Facility', '@FacilityName'), (label, f"@{{{label}}}{{0,0}}")]))
            
        # Add labels
        p.yaxis.formatter = NumeralTickFormatter(format="0,0")
        p.y_range.start = 0

        # Add value labels
        p.text(x=dodge('FacilityName', -0.3, range=p.x_range), y='BFW VL Eligible', text='BFW VL Eligible',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0, range=p.x_range), y='BFW VLS (D)', text='BFW VLS (D)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')
        p.text(x=dodge('FacilityName', 0.3, range=p.x_range), y='BFW VLS (N)', text='BFW VLS (N)',
            text_font_size='8.5pt', text_align='center', text_baseline='bottom', source=source, text_color='black')

        # Secondary y-axis for percentages
        p.extra_y_ranges = {"percentage": Range1d(start=0, end=100)}
        p.add_layout(LinearAxis(y_range_name="percentage", axis_label="Percentage"), 'right')
        # Plot the line and circles for percentages
        percentage_metrics = ['% Coverage', '% Suppression']
        colors = ["blue", "green"]
        dodge_values = [0, 0.3]

        # Add percentage labels
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            p.text(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, text=metric,
                text_font_size='10pt', text_align='center', text_baseline='bottom', source=source,
                text_color=color, y_range_name="percentage")

        percentage_lines = []
        for metric, color, dodge_val in zip(percentage_metrics, colors, dodge_values):
            circle = p.circle(x=dodge('FacilityName', dodge_val, range=p.x_range), y=metric, source=source,
            line_color=color, fill_color=color, size=10, y_range_name="percentage", legend_label=metric)
            percentage_lines.append((metric, circle))

        # Add hover tool for percentage lines
        for metric, circle in percentage_lines:
            p.add_tools(HoverTool(renderers=[circle], tooltips=[(metric, f"@{{{metric}}}{{0.00}}%")]))

        p.toolbar.autohide = True
        p.toolbar.logo = None
        p.outline_line_color = None
        p.legend.label_text_font_size =  '8pt'
        p.add_layout(p.legend[0], 'below') 
        p.legend.orientation = "horizontal"
        p.legend.click_policy = "hide"        
        # Rotate x-axis labels
        p.xaxis.major_label_orientation = np.pi / 6
        # Create csv table for export
        source = ColumnDataSource(data_7b)
        # CustomJS callback to export CSV
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'facility bfw_pvls.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)
        plot10_html = file_html((p, export_button), CDN, "plot10")


        data_6 = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['Facility Name'].isin(selected_facility)]  
        data_6b = data_6.groupby('Facility Name')[['BFW VL Eligible', 'BFW VLS (D)', 'BFW VLS (N)']].sum()  
        data_6b=data_6b.reset_index() 

        def get_map_bfw_vls(fac_name):
            # Function to get the bfw_vls value for a given Facility Name
            bfw_vls_values = data_6b.groupby('Facility Name')['BFW VL Eligible'].sum()
            return bfw_vls_values.get(fac_name, "N/A")
        
        def get_map_bfw_vls2(fac_name):
            # Convert list to dictionary
            bfw_vls_cov_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (D)'] / data_6b['BFW VL Eligible']) * 100, decimals=1))))
            # Use get method on dictionary
            return bfw_vls_cov_dict.get(fac_name, "N/A")

        def get_map_bfw_vls3(fac_name):
            # Function to get the bfw_vls value for a given Facility Name
            bfw_vls_sup_dict = dict(zip(data_6b['Facility Name'], map(lambda x: str(x) + "%", np.round((data_6b['BFW VLS (N)'] / data_6b['BFW VLS (D)']) * 100, decimals=1))))
            return bfw_vls_sup_dict.get(fac_name, "N/A")
        # Load GeoJSON file with Nigeria's Facility Name boundaries to create a map
        geo_json_path = r"NGN.json"
        geo_data = json.load(open(geo_json_path))        
        # Filter the GeoJSON data to include only selected Facility Names
        def filter_geojson(geo_data, selected_facility):
            filtered_features = [feature for feature in geo_data['features'] if feature['properties']['name'] in selected_facility]
            return {'type': 'FeatureCollection', 'features': filtered_features}

        filtered_geo_data = filter_geojson(geo_data, selected_facility)
        
        # Define coordinates for the center of each Facility and Get the coordinates for the first selected Facility
        fac_center = lga_coordinates.get(selected_facility[0], [9.0820, 8.6753])
        
        ng_map = folium.Map(location=fac_center, zoom_start=8, height=450, width=600)
        # Create a string that includes the selected Facility
        fac_names = ', '.join(selected_facility)
        # Update the HTML title to include the Facility
        title_html = f'<p style="text-align:center; color: #333; font-weight: bold;">{fac_names} Breastfeeding Women Distribution</p>'
        ng_map.get_root().html.add_child(folium.Element(title_html))
        # Add choropleth layer
        folium.Choropleth(
            geo_data=geo_data, name='choropleth', data=data_6b, columns=['Facility Name', 'BFW VL Eligible'], key_on='feature.properties.name', 
            fill_color='BuGn', fill_opacity=0.5, line_opacity=0.6, legend_name='Breastfeeding Women VLS', nan_fill_color ='blue', highlight=True
        ).add_to(ng_map)        
        # Define popup style
        popup_style = '''
            <div style="background-color: #ffffff;
                        border: 2px solid #333333;
                        font-weight: bold; 
                        color: green;
                        border-radius: 5px;
                        padding: 10px;
                        font-family: Arial, sans-serif;
                        font-size: 13px;">
                <strong>{}</strong><br>
                Eligible: {}<br>
                % Coverage: {}<br>
                % Suppression: {}
            </div>
        '''
        # Define a function to get locations for the selected Facility Names
        def get_locations_for_facs(selected_facility):
            locations = []
            for facility in selected_facility:
                fac_names_in_fac = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['Facility Name'] == facility]['Facility Name'].unique()
                for fac_name in fac_names_in_fac:
                    coordinates = fac_coordinates.get(fac_name, [9.0820, 8.6753])
                    locations.append({"location": coordinates, "popup": fac_name})
            return locations    
            
        locations = get_locations_for_facs(selected_facility)
        # Add popup and tooltip for each Facility Name
        for loc in locations:
            bfw_vls_values = get_map_bfw_vls(loc["popup"])
            bfw_vls_formatted = format_with_thousand_separator(bfw_vls_values)     
            bfw_vls_cov_dict = get_map_bfw_vls2(loc["popup"])
            bfw_vls_sup_dict = get_map_bfw_vls3(loc["popup"])
            
            popup_content = popup_style.format(loc["popup"], 
                                                bfw_vls_formatted, 
                                                bfw_vls_cov_dict, 
                                                bfw_vls_sup_dict)            
            # Create a tooltip
            tooltip = Tooltip(popup_content)
            
            folium.Marker(location=loc["location"], popup=folium.Popup(popup_content, max_width=300),
                tooltip=tooltip).add_to(ng_map)

        # Add layer control
        folium.LayerControl().add_to(ng_map)
        # Create csv table for export
        # Convert data_6b to a DataFrame
        source = ColumnDataSource(data_6b)
        export_csv_js = CustomJS(args=dict(source=source), code="""
            function table_to_csv(source) {
                const columns = Object.keys(source.data);
                const nrows = source.get_length();
                const lines = [columns.join(',')];

                for (let i = 0; i < nrows; i++) {
                    let row = [];
                    for (let col of columns) {
                        row.push(source.data[col][i]);
                    }
                    lines.push(row.join(','));
                }
                return lines.join('\\n').concat('\\n');
            }

            const filename = 'bfw_vls distribution.csv';
            const filetext = table_to_csv(source);
            const blob = new Blob([filetext], { type: 'text/csv;charset=utf-8;' });

            // Addresses IE
            if (navigator.msSaveBlob) {
                navigator.msSaveBlob(blob, filename);
            } else {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.target = "_blank";
                link.style.visibility = 'hidden';
                link.dispatchEvent(new MouseEvent('click'));
            }
        """)
        # Button for exporting CSV
        export_button = Button(label='Export CSV', button_type="success", width=80, height=30)
        export_button.js_on_click(export_csv_js)               
        bfw_vls_button_json = json_item(export_button)   
        plot17_html = ng_map.get_root().render()        

        ####################### DATATABLE ######################################################################################
        bfw_pvls_temp_tbl_fac = bfw_pvls_temp_tbl[bfw_pvls_temp_tbl['Facility Name'].isin(selected_facility)] 
        plot19_html = bfw_pvls_temp_tbl_fac.to_html(index=False, classes=['tbl_fac', 'table table-bordered',"display"], escape=False)

        data_response = {
            'fac_num': fac_num_bfw_vls_dict,
            'achieved': achieved_bfw_vls_dict,
            'achieved_pbs': achieved_pbs_bfw_vls_dict,
            'percent_pbs': percent_pbs_bfw_vls_dict,
            'achieved_recapture': achieved_pbs_rec_bfw_vls_dict,
            'percent_recaptured': percent_pbs_rec_bfw_vls_dict,
            'plot3': plot3_html,
            'plot4': plot4_html,
            'plot9': plotvlsage_html,
            'plot10': plot10_html,
            'plot17': {'main': plot17_html, 'additional': bfw_vls_button_json}, 
            'plot19': plot19_html

        } 


    if not data_response:
        return jsonify({"error": "No data found"}), 204

    return jsonify(data_response)
    